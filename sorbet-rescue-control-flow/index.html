<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-09-04 23:12:12 -0400">
<meta name="description" content="A quick post explaining why exception handling in Sorbet is weird, by way of a buggy program and some pretty pictures.">
<title>Sorbet’s weird approach to exception handling – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Sorbet’s weird approach to exception handling</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2022-09-04 23:12:12 -0400">September 4, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#control-flow-and-rescue-in-sorbet"
  id="toc-control-flow-and-rescue-in-sorbet">Control flow and
  <code>rescue</code> in Sorbet</a></li>
  <li><a href="#a-brief-history-of-rescue-in-sorbet"
  id="toc-a-brief-history-of-rescue-in-sorbet">A brief history of
  <code>rescue</code> in Sorbet</a></li>
  <li><a href="#the-bigger-picture" id="toc-the-bigger-picture">The
  bigger picture</a></li>
  </ul>
</nav>

<main>
<p>Here’s a fun bug in Sorbet:</p>
<figure class="left-align-caption">
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ruby numberLines hl-11 hl-12"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">def</span> example</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="cf">begin</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    loop_count <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="cf">while</span> <span class="dv">true</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>      <span class="fu">sleep</span>(<span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7"></a>      loop_count <span class="kw">+=</span> <span class="dv">1</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">end</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="cf">rescue</span> <span class="dt">Interrupt</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">if</span> loop_count</span>
<span id="cb1-11"><a href="#cb1-11"></a>      <span class="fu">puts</span>(<span class="st">&quot;Looped </span><span class="sc">#{</span>loop_count<span class="sc">}</span><span class="st"> times&quot;</span>)</span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="co"># ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: This code is unreachable</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    <span class="cf">end</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="cf">end</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">end</span></span></code></pre></div>
<figcaption>
<a
href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Adef%20example%0A%20%20begin%0A%20%20%20%20loop_count%20%3D%200%0A%0A%20%20%20%20while%20true%0A%20%20%20%20%20%20sleep%281%29%0A%20%20%20%20%20%20loop_count%20%2B%3D%201%0A%20%20%20%20end%0A%20%20rescue%20Interrupt%0A%20%20%20%20if%20loop_count%0A%20%20%20%20%20%20puts%28%22Looped%20%23%7Bloop_count%7D%20times%22%29%0A%20%20%20%20end%0A%20%20end%0Aend">→View
on sorbet.run</a>
</figcaption>
</figure>
<p>Sorbet thinks that <code>loop_count</code> is <code>nil</code> at the
start of the <code>rescue</code> block, which causes it to declare the
<code>puts</code> line unreachable (because <code>nil</code> is never
truthy).</p>
<p>But why? Clearly we can see that <code>loop_count</code> is an
<code>Integer</code>. We’d expect Sorbet to <em>at least</em> think
<code>loop_count</code> has type <code>T.nilable(Integer)</code>, if not
simply <code>Integer</code> outright.</p>
<p>Sometimes Sorbet takes shortcuts—especially when the short cut is
good enough 99% of the time while being simple and fast. Sorbet’s
approach to <code>rescue</code> and exception handling is one of these
shortcuts.</p>
<h1 id="control-flow-and-rescue-in-sorbet">Control flow and
<code>rescue</code> in Sorbet</h1>
<p>I mentioned in <a href="/syntactic-control-flow/">my last post</a>
that Sorbet builds a <span class="smallcaps"><strong>control flow
graph</strong></span> (CFG) in order to model control-flow sensitive
types throughout the body of a method. For <code>rescue</code> nodes, it
pretends that there are only two jumps into the <code>rescue</code>
block: once <strong>before any</strong> any code in the
<code>begin</code> block has run, and once after all the code in
<code>begin</code> block has run. It looks a little something like
this:</p>
<div class="only-light-mode">
<figure>
<img src="/assets/img/rescue-cfg-light-mode.png"
alt="An example CFG with a rescue block" />
<figcaption aria-hidden="true">An example CFG with a <code>rescue</code>
block</figcaption>
</figure>
</div>
<div class="only-dark-mode">
<figure>
<img src="/assets/img/rescue-cfg-dark-mode.png"
alt="An example CFG with a rescue block" />
<figcaption aria-hidden="true">An example CFG with a <code>rescue</code>
block</figcaption>
</figure>
</div>
<p>This is a simplified view of a CFG in Sorbet.<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">If you have <a
href="https://graphviz.org/">Graphviz</a> installed, you can get Sorbet
to dump its internal CFG for a given file with the
<code>cfg-view.sh</code> script in the Sorbet repo. The CFG for the
example above looks like <a
href="/assets/img/rescue-example-01.svg">like this</a>.<br />
<br />
</span></span> The boxes contain hunks of straight-line code (code
without control flow), and all control flow is made explicit by
branching on a specified variable at the end of each block. For the case
of <code>rescue</code>, the branches read from a magical
<code>&lt;exn-value&gt;</code> variable, which Sorbet treats as <span
class="smallcaps"><strong>unanalyzable</strong></span>: Sorbet doesn’t
attempt to track how the value is initialized nor how control flow
affects it.</p>
<p>Knowing this, we can explain the weird dead code error from the
snippet above:</p>
<ul>
<li>The first jump into the <code>rescue</code> block happens before any
code in the <code>begin</code> block runs. At that point, the
<code>loop_count</code> variable is still uninitialized, and thus has
type <code>NilClass</code> when taking that branch.</li>
<li>The second jump into the <code>rescue</code> block happens after the
<code>begin</code> block finishes. But from Sorbet’s point of view, the
<code>begin</code> block in the <code>loop_count</code> snippet never
finishes! Sorbet sees the infinite <code>while true</code> loop and
says, “it doesn’t matter where to branch at the end of the
<code>begin</code> block—the infinite loop won’t allow control to flow
there.”<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote">If you’re fearless, you can prove that this is what’s
happening in the <a href="/assets/img/rescue-example-01.svg">rendered
CFG</a> for the above example.<br />
<br />
</span></span> Despite it being able to tell that
<code>loop_count</code> has type <code>Integer</code> inside the
<code>begin</code>, only the <code>NilClass</code> branch is live in the
<code>rescue</code> block.</li>
</ul>
<p>That second point about <code>while true</code> is <a
href="https://github.com/sorbet/sorbet/issues/4108">simply a bug</a>.
Sorbet should be smart enough to suspend the normal flow-sensitivity
rules for infinite loops while checking code in a <code>begin</code>
block that has a <code>rescue</code>.<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="sidenote">Of course, easier said than done.<br />
<br />
</span></span> But still, fixing that bug would only fix half the
problem: Sorbet would think that <code>loop_count</code> has type
<code>T.nilable(Integer)</code> in the <code>rescue</code> body, but we
said the best outcome would be for Sorbet to know that
<code>loop_count</code> is <strong>always</strong> initialized, having
type <code>Integer</code>.</p>
<p>Before we can see what it would take for Sorbet to infer
<code>Integer</code>, some history.</p>
<h1 id="a-brief-history-of-rescue-in-sorbet">A brief history of
<code>rescue</code> in Sorbet</h1>
<p>Sorbet’s <a
href="https://github.com/sorbet/sorbet/commit/9189734a6c061071c3d3cd4398a5d7874a8c0c49">first
commit</a> dates to October 3, 2017. Six weeks later, the <a
href="https://github.com/sorbet/sorbet/commit/afb234741f4ccd98ca2903d1621746c64a2da5ab">initial
support for <code>rescue</code></a> landed. The pull request description
is from a time when all pull requests were not public, so I’ll quote it
here:</p>
<blockquote>
<p>This does most of the work in the CFG, preserving the semantics in
the desugarer. […]</p>
<p>It introduces a series of uncomputable <code>if</code>s since 0 or
more instructions from the first block will execute then one of the
<code>rescue</code>s could match and then if none do the
<code>else</code> will match.</p>
</blockquote>
<p>The approach it’s describing is what most people might do
intuitively: any instruction in a <code>begin</code> might raise,<span
class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span
class="sidenote">This is not quite true: <code>x = 0</code> doesn’t
raise, and Sorbet can <a href="/syntactic-control-flow/">see that
syntactically</a>. This might be something to take advantage of in the
future.<br />
<br />
</span></span> so let’s record an unanalyzable jump after each
instruction, into the <code>rescue</code> block. In picture form:</p>
<div class="only-light-mode">
<figure>
<img src="/assets/img/rescue-cfg-multi-block-light-mode.png"
alt="A diagram depicting the implementation described in the above commit" />
<figcaption aria-hidden="true">A diagram depicting the implementation
described in the above commit</figcaption>
</figure>
</div>
<div class="only-dark-mode">
<figure>
<img src="/assets/img/rescue-cfg-multi-block-dark-mode.png"
alt="A diagram depicting the implementation described in the above commit" />
<figcaption aria-hidden="true">A diagram depicting the implementation
described in the above commit</figcaption>
</figure>
</div>
<p>Note how every line of the <code>begin</code> body gets its own, tiny
basic block with an unanalyzable jump to the <code>rescue</code> block,
or to the next line of the body. This implementation wouldn’t have
exhibited the bug in our <code>loop_count</code> example—there would be
a jump after the <code>loop_count = 0</code> assignment into the
<code>rescue</code> block, which would have been enough for Sorbet to
infer a type of <code>Integer</code> (regardless of whether that
<code>while true</code> bug were fixed method).</p>
<p>But importantly, this original approach was thrown out, <a
href="https://github.com/sorbet/sorbet/commit/a6ed41e0b8deee28ff592063934b28676ac77927#diff-c9b037996e9c16464e031136abe5d9df567c72f283d572b070d108228b733127R335-R342">almost
exactly 9 months later</a><span
class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span
class="sidenote">And only two days after I joined the team 😅<br />
<br />
</span></span>, when the shortcut we’ve been discussing arrived. In
fact, a comment from that commit persists unchanged in the codebase
today:</p>
<blockquote>
<figure class="left-align-caption">
<p>We have a simplified view of the control flow here but in practise it
has been reasonable on our codebase. We don’t model that each expression
in the <code>body</code> or <code>else</code> could throw, instead we
model only never running anything in the body, or running the whole
thing. To do this we have a magic Unanalyzable variable at the top of
the body using <code>rescueStartTemp</code> and one at the end of the
else using <code>rescueEndTemp</code> which can jump into the rescue
handlers.</p>
<figcaption>
<a
href="https://github.com/sorbet/sorbet/blob/e63d2893edecc30e3eda5cd3378e02b8996e866f/cfg/builder/builder_walk.cc#L761-L768">→
View in <code>cfg/builder/builder_walk.cc</code></a>
</figcaption>
</figure>
</blockquote>
<p>Why adopt this shortcut approach if it <em>causes</em> bugs like this
to happen? Well for starters, the original approach had an even more
insidious bug. Consider this example:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  x <span class="kw">=</span> might_raise()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cf">rescue</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sorbet would assume `x` was always set</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">puts</span>(x)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>In this example, the first instruction in the block is an assignment
(<code>x = ...</code>). But Sorbet would only record the jump after the
assignment entirely, not between the method call and the assignment.
This meant Sorbet would think that <code>x</code> was unconditionally
set, but in fact it’s <strong>not</strong> set when
<code>might_raise()</code> does actually raise. At the time, Sorbet
tripped this bug all the time on real-world code—there were beta users
of Sorbet chiming in on the PR eagerly waiting for the bug to be fixed.
Meanwhile, code that looked like our <code>loop_count</code> example
either did not exist or was simply rewritten<span
class="sidenote-wrapper"><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle"/><span
class="sidenote">There’s an easy workaround: use <code>T.let</code> to
pin the type of the variable outside the <code>begin</code> block.<br />
<br />
</span></span> to avoid the bug.</p>
<p>But this still doesn’t quite paint the full picture. I’ve told you,
“There was a bug, and Sorbet fixed it by introducing another bug.” Which
leads us to out second point: having a lot of tiny, jumpy basic blocks
is slow to typecheck. There are lots of reasons:</p>
<ul>
<li><p>After building a CFG, Sorbet does a bunch of post-processing on
it. For example, it computes which variables each basic block reads and
writes, tries to dealias variable writes, and merges adjacent blocks if
possible. When there are fewer basic blocks, these post-processing steps
run faster to begin with, and are more likely to drastically shrink the
CFG size (making type inference run faster).</p></li>
<li><p>When typechecking a method, every basic block in the CFG requires
its own <a
href="https://github.com/sorbet/sorbet/blob/master/infer/environment.h#L127"><code>Environment</code></a>
data structure, which maps variables to their types within that block.
Sorbet either has to allocate a separate <code>Environment</code> per
block (what it currently does) or incur complexity from making them <a
href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>. <a
href="https://blog.nelhage.com/post/why-sorbet-is-fast/">Allocating is
slow</a> and we really like to avoid complexity.</p></li>
<li><p>Before typechecking a basic block, Sorbet has to merge the
environments of all incoming blocks. Merging environments involves doing
slow type checking operations, like checking whether two
possibly-arbitrary types are subtypes of each other and allocating union
types.</p></li>
<li><p>Not only are there more basic blocks, there are more
instructions! Each <code>&lt;exn-value&gt;</code> variable has to be
populated before Sorbet can branch on it, and that each tiny basic block
has not only the single instruction inside it, but also an extra
instruction to initialize the <code>&lt;exn-valu&gt;</code> variable.
That basically doubles the number of instructions Sorbet emits for a
<code>begin</code> block, making more work for type inference.</p></li>
</ul>
<p>The new “only before and after” shortcut is pretty clever. In
practice, it models the case when even the very first assignment might
raise, while generating far fewer basic blocks, thus running much
faster.</p>
<h1 id="the-bigger-picture">The bigger picture</h1>
<p>There are a lot of these clever “good enough” tricks in Sorbet. Many
of them are only possible because of the stakes: Sorbet <em>already</em>
allows <a
href="https://sorbet.org/docs/gradual"><code>T.untyped</code></a>, so
depending on your viewpoint, either:</p>
<ul>
<li>There is already the holy grail of all hacks in the type system, so
why not cut more corners when it makes sense.</li>
<li><em>Because</em> <code>T.untyped</code> is in the type system, at
least the user can use <code>T.untyped</code> to not be completely
blocked from writing the code they need to write.</li>
</ul>
<p>Either way, in some sense the stakes are low. In a compiler where the
stakes for being wrong are higher (the code computes the wrong answer),
maybe shortcuts aren’t the best idea. And in fact, <a
href="https://github.com/sorbet/sorbet/pull/2962">multiple</a> <a
href="https://github.com/sorbet/sorbet/pull/3044">distinct</a> <a
href="https://github.com/sorbet/sorbet/pull/4488">exception</a> <a
href="https://github.com/sorbet/sorbet/pull/4531">changes</a> landed in
Sorbet’s CFG code to support the Sorbet Compiler.</p>
<p>It’s now been over four years since we shipped the change to model
<code>rescue</code> this way. I’m not aware of a single incident caused
by this shortcut, and I can only even remember explaining this behavior
to a confused Sorbet user twice. I can’t find any performance numbers
from when the original change landed, but we can still put it into
perspective: it’s the difference between a handful of people being
confused over the course of 4 years, or thousands of people getting
faster typechecking results thousands of times per day. Seems like a
reasonable trade-off.</p>
<p>Though eventually it would be nice to at least fix <a
href="https://github.com/sorbet/sorbet/issues/4108">that
<code>while true</code> bug</a>. 😅</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#types">types</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#in-pictures">in-pictures</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

