<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-02-22 03:56:34 -0500">
<meta name="description" content="This is the second post in a series about "things I've learned while making improvements to Sorbet's parser." Specifically, it's about approaches I considered but decided against.
">
<title>Parse Error Recovery in Sorbet: Part 2 â€“ Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Parse Error Recovery in Sorbet: Part 2</h1>
    <blockquote class="metadata">
    <p class="subtitle">What I Didn't Do</p>
    <p class="date before-toc"><time datetime="2022-02-22 03:56:34 -0500">February 22, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">â† Return home</a><br>
</nav>

<main>
<p>This is the second post in a series about â€œthings Iâ€™ve learned while
making improvements to Sorbetâ€™s parser.â€ Specifically, itâ€™s about
approaches I considered but decided against.</p>
<!-- more -->
<ul>
<li><a href="/error-recovery-part-1/">Part 1: Why Recover from Syntax
Errors</a></li>
<li><strong><a href="/error-recovery-part-2/">Part 2: What I Didnâ€™t
Do</a></strong></li>
<li><a href="/error-recovery-part-3/">Part 3: Tools and Techniques for
Debugging a (Bison) Parser</a></li>
<li><a href="/error-recovery-part-4/">Part 4: Bisonâ€™s <code>error</code>
Token</a></li>
<li>(<em>coming soon</em>) Part 5: Backtracking, aka Lexer Hacks</li>
<li>(<em>coming soon</em>) Part 6: Falling Back on Indentation, aka More
Lexer Hacks</li>
</ul>
<p>Before we get started, I should say: Iâ€™m not, like, an expert at
writing parsers. In fact of all the changes Iâ€™ve made to Sorbet, itâ€™s
definitely up there for â€œchanges Iâ€™ve been least qualified to have
made.â€ But at the end of the day my test cases passed <span
class="emoji" data-emoji="upside_down_face">ğŸ™ƒ</span> Take my
experiences with as many or as few grains of salt as youâ€™d like. This
also means that if you want to suggest other alternatives or otherwise
teach me something new, Iâ€™m all ears!</p>
<p>First, a little bit of history. Sorbetâ€™s parser was originally a part
of the <a href="https://github.com/typedruby/typedruby">TypedRuby</a>
project.<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote"><a
href="https://github.com/typedruby/typedruby">TypedRuby</a> was an
aspirational Ruby type checker implemented in Rust that predated Sorbet.
It is now abandoned.<br />
<br />
</span></span> In turn, TypedRuby sourced its parser by porting the
grammar file in the <a
href="https://github.com/whitequark/parser">whitequark parser</a> from
<a href="https://rubygems.org/gems/racc">Racc</a> (a Yacc-like parser
generator for Ruby) to <a
href="https://www.gnu.org/software/bison/">Bison</a> (a Yacc-like parser
generator for C/C++). Sorbet imported the source code of the TypedRuby
parser and continued to modify it over time as Ruby syntax evolved. The
lexer uses <a href="http://www.colm.net/open-source/ragel/">Ragel</a>
(also inherited from whitequark by way of TypedRuby) and tends to be
quite stateful compared to other lexers Iâ€™ve seenâ€”a point which weâ€™ll
come back to in future posts.</p>
<p>Importantlyâ€¦</p>
<ul>
<li><p>Sorbetâ€™s parser does not use <a
href="https://ruby-doc.org/stdlib-2.7.3/libdoc/ripper/rdoc/Ripper.html">Ripper</a>,
the parser built into the Ruby VM itself.</p>
<p>Ripper is meant to be used as a library from Ruby code, not from C++
like Sorbet needs for performance.</p>
<p>Okay technically thatâ€™s a lie. The <a
href="https://github.com/penelopezone/rubyfmt">rubyfmt</a> project
manages to depend on Ripper from Rust by exposing it via Rubyâ€™s support
for native (C) extensions. <strong>But</strong> doing that comes with <a
href="https://github.com/penelopezone/rubyfmt/blob/trunk/librubyfmt/build.rs">significant
build complexity</a>, because it has the effect of basically importing
Rubyâ€™s whole <code>configure &amp;&amp; make</code> build step.</p>
<p>Meanwhile it was super easy to import the TypedRuby parser as a
self-contained unit with basically no questions asked (and remember:
Sorbet predates rubyfmt). Itâ€™s also nice to be free from upstream<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote">I should note that Iâ€™m not opposed to upstreaming the
changes Iâ€™ve made to Sorbetâ€™s parser. Some of them intentionally break
Ruby compatibility (in minor ways), and even the changes that donâ€™t
would likely require effort to get them merged properly. If you find my
changes and want to submit them upstream, please go ahead!<br />
<br />
</span></span> constraints: I can mess around in Sorbetâ€™s parser as much
as I want and the only people I have to defend my choices to are my
teammates, not the Ruby maintainers.</p></li>
<li><p>Sorbetâ€™s parser does not use <a
href="https://tree-sitter.github.io/tree-sitter/">tree-sitter</a>.</p>
<p>Tree-sitter is tool whose main goals are basically 100% aligned with
Sorbetâ€™s needs in a parser: fast enough to run on every keystoke, robust
enough to handle syntax errors, and native-code friendly. It would seem
like a no-brainer for Sorbet to use.</p>
<p>Unfortunately when I looked closely, it didnâ€™t actually pan out. I
used the <a
href="https://tree-sitter.github.io/tree-sitter/playground">tree-sitter
playground</a> to test a bunch of syntax errors where I wanted to be
able to respond to completion requests for to see what the parse result
looked like. In some cases it worked okay, but for the cases I cared
about the most (mostly those involving <code>x.</code>), the results
werenâ€™t good enough. If I was going to have to manually hack on a parser
to get it to do what I wanted, I figured Iâ€™d rather just stick with what
Sorbet already had.</p>
<p>On top of that tree-sitter is still pretty young, and almost everyone
who is using tree-sitter right now is using it for two use cases: syntax
highlighting, and code navigation. If the parse result generates the
wrong thing (imagine thereâ€™s a bug in the grammar file that no one else
has reported yet), oh well, maybe the colors are wrong or the
jump-to-def goes to the wrong place. In Sorbet, it would mean either
reporting an error when there isnâ€™t one, or not reporting an error when
there is one, both of which are particularly bad.</p>
<p>Given that it was both (1) going to take extra hacks<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="sidenote">After publishing this post, I wrote more about my <a
href="/tree-sitter-limitations/">thoughts on tree-sitter</a>.<br />
<br />
</span></span> to get working instead of being a drop-in solution and
(2) potentially trade Sorbetâ€™s mature parser for a less-mature parser,
it didnâ€™t seem worth pursuing.</p></li>
<li><p>Sorbetâ€™s parser is not hand-written with <a
href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive
descent</a>.</p>
<p>Many people whose opinions I respect have told me that thereâ€™s a
reason why so many people hand-write their parsers: error recovery is
easier when given the flexibility to bend the whole parser to your
will.</p>
<p>But there isnâ€™t an existing hand-written Ruby parser I could start
from, and I didnâ€™t want to completely stall progress with a bug-for-bug
rewrite when I already had some ideas for how to make the existing
parser better. Basically this approach has the same tradeoffs as
adopting tree-sitter (lots of work with too many unknowns).</p></li>
</ul>
<p>All of these claims about Sorbetâ€™s parser were true when I started,
and they havenâ€™t changed. Youâ€™ll notice that in most cases the
justification is â€œI donâ€™t have time to do Xâ€ and not â€œdoing X is wrong.â€
My biggest constraint in improving the parser has been making small,
fast, iterative improvements. I wanted to be left with something to show
even if I had to stop working on the parser sooner than expected. Itâ€™s
possible that someone with more time or more patience will want to
revisit one of these approaches in the future, and if you do Iâ€™d love to
hear about it!</p>
<p>Anyways, that rules out the most common refrains from onlookers. But
there was another, more unconventional approach I considered and decided
against: using <a
href="https://github.com/zombocom/dead_end">dead_end</a>.
<code>dead_end</code> isnâ€™t a Ruby parser but rather a tool that hijacks
Rubyâ€™s syntax error reporting mechanism<span
class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span
class="sidenote">It turns out, all (â€œallâ€) you have to do is is monkey
patch <code>require</code> to <code>rescue   SyntaxError</code>. Thanks
Ruby <span class="emoji"
data-emoji="slightly_smiling_face">ğŸ™‚</span><br />
<br />
</span></span> to improve the message for certain syntax errors.
Specifically, itâ€™ll try to show error messages in cases like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ruby numberLines hl-4 hl-8"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">class</span> A</span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="cf">def</span> foo</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="co"># ... lots of code ...</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="co"># â† dead_end error: missing `end` keyword</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="cf">def</span> bar</span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="cf">end</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="cf">end</span> <span class="co"># â† ruby default error: unexpected token &quot;end of file&quot;</span></span></code></pre></div>
<p>Missing an <code>end</code> keyword is a super common class of Ruby
syntax errors,<span
class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span
class="sidenote">One of my biggest Ruby syntax gripes is that it isnâ€™t a
curly brace language like C or JavaScript. Any sensibly editor will
<strong>immediately</strong> insert the matching <code>}</code> after
first typing <code>{</code>. But most Ruby editors will only insert the
<code>end</code> matching some statement after a full line has been
typed and <code>&lt;Enter&gt;</code> has been pressed, if anything. This
means that unclosed
<code>if</code>/<code>while</code>/<code>do</code>/<code>def</code>/<code>class</code>
statements are <strong>abundantly</strong> common in Ruby, and this
class of error (mismatched pairs) is trickier than the average
error.<br />
<br />
</span></span> and <code>dead_end</code> already works particularly well
at reporting them, so it was tempting to <del>steal</del> reuse either
the code or the ideas.</p>
<p>Early on I had decided not to use the code directly (itâ€™s written in
Ruby, and I didnâ€™t want to add a runtime dependency on Ruby to Sorbet).
But in the end, I decided not to use its recovery algorithm either.</p>
<p>The algorithm is <a
href="https://schneems.com/2020/12/01/squash-unexpectedend-errors-with-syntaxsearch/">described
in more detail here</a>, but the tl;dr is that it uses indentation to
search for mismatched snippets, expanding and discarding lines from the
search frontier when it finds portions of a Ruby file that properly
parse at a given indentation level.</p>
<p>The problem with taking that idea verbatim is that the end result is
basically just a set of lines in the source file that contain the error.
But knowing those lines, thereâ€™s still no parse result for those lines.
For example:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource ruby numberLines hl-3"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1"></a><span class="cf">def</span> foo</span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="co"># ... code before ...</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="cf">if</span> arbitrary_expression()<span class="kw">.</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="co"># ... code after ...</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="cf">end</span></span></code></pre></div>
<p><code>dead_end</code> could point to line 3 as the problem, but then
Iâ€™d still have to parse that line to be able to e.g.Â service a
completion request after the <code>.</code>, which is <em>basically</em>
the situation we started with, because the parser would still be on the
hook for the full complexity of what that
<code>arbitrary_expression()</code> could represent. So I put the
<code>dead_end</code> algorithm itself aside as well.</p>
<p><strong>But!</strong> the general idea of using indentation to guide
recovery proved out to be pretty usefulâ€”most Ruby editors will
auto-indent and -dedent correctly for most editsâ€”and there was another
way to take advantage of it in Sorbetâ€™s parser, along with some other
tricks. The next few posts will discuss those tricks!</p>
<p style="width: 50%; float: left; text-align: left;">
<a href="/error-recovery-part-1/">â† Part 1: Why Recover from Syntax
Errors</a>
</p>
<p style="width: 50%; float: right; text-align: right;">
<a href="/error-recovery-part-3/">Part 3: Tools and Techniques for
Debugging a (Bison) Parser â†’</a>
</p>
<p><br></p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#parsing">parsing</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#tree-sitter">tree-sitter</a></strong></span>
        
      </p>
      <p><a href="/">â† Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

