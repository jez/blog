<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2017-10-28 22:04:01 -0400">
<meta name="description" content="Nearly every interesting programming language feature derives its power from variables. Functions wouldn't be functions if not for variables. Modularity and linking reduce to variables and substitution. I've written in the past about all sorts of cool variables in types, as well as how parametric polymorphism in System F is the result of using type variables in two ways within the same system.
">
<title>Variables and Binding – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">

  <script src="/assets/libs/KaTeX/0.11.1/katex.min.js"></script>
  <script src="/assets/js/enable_katex.js"></script>
  <link rel="stylesheet" href="/assets/libs/KaTeX/0.11.1/katex.min.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Variables and Binding</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2017-10-28 22:04:01 -0400">October 28, 2017</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#variable-capture" id="toc-variable-capture">Variable
  Capture</a></li>
  <li><a href="#explicit-variables" id="toc-explicit-variables">Explicit
  Variables</a></li>
  <li><a href="#de-bruijn-indices" id="toc-de-bruijn-indices">De Bruijn
  Indices</a></li>
  <li><a href="#de-bruijn-indices-and-lifting"
  id="toc-de-bruijn-indices-and-lifting">De Bruijn Indices and
  Lifting</a></li>
  <li><a href="#locally-nameless-terms"
  id="toc-locally-nameless-terms">Locally Nameless Terms</a></li>
  <li><a href="#closing-considerations"
  id="toc-closing-considerations">Closing Considerations</a></li>
  </ul>
</nav>

<main>
<p>Variables are central<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">Nearly every interesting programming language feature
derives its power from variables. Functions wouldn’t be functions if not
for variables. Modularity and linking reduce to variables and
substitution. I’ve written in the past about all sorts of cool <a
href="/variables-in-types">variables in types</a>, as well as how <a
href="/system-f-param">parametric polymorphism in System F</a> is the
result of using type variables in two ways within the same system.<br />
<br />
</span></span> to programming languages, yet they’re often overlooked.
Academic PL theory papers usually take for granted having proper
implementations of variables. Most popular languages butcher variables,
<a
href="https://existentialtype.wordpress.com/2012/02/01/words-matter/">confusing
them with assignables</a>. Despite being taken for granted, implementing
substitution on variables is easy to get wrong.</p>
<!-- more -->
<p>There are a number of different solutions for handling variables and
binding within a programming language implementation. We’ll take a look
at these three:</p>
<ul>
<li>explicit variables,</li>
<li>de Bruijn indices, and</li>
<li>locally nameless terms</li>
</ul>
<p>Before we get to solutions, we need to outline the problem.
Implementing variables and binding reduces to implementing substitution
(because variables are giving meaning by substitution!), and the
trickiest part of substitution is variable capture.</p>
<h1 id="variable-capture">Variable Capture</h1>
<p>The most common way to get variables and binding wrong is to
accidentally let variables be <strong>captured</strong> during
substitution. Consider this example:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python tight-code"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>                      ◀────────────────┐</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>                             ┌──────┐  │</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                       (λx. λy. x <span class="op">+</span> y) y</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                         └──────┘</span></code></pre></div>
<p>There are two distinct <code>y</code> variables here:</p>
<ul>
<li>one which refers to the variable bound by the nested lambda</li>
<li>one which refers to some <code>y</code> in the surrounding
scope</li>
</ul>
<p>For this example, let’s say we choose to represent variables as
string identifiers. If we step the function application, it steps to a
substitution of <code>y</code> for <code>x</code>:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  (λx. λy. x <span class="op">+</span> y) y</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Apply the function, giving us:</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>→ [y <span class="op">/</span> x] (λy. x <span class="op">+</span> y)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Traverse under the lambda:</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>→ λy. [y <span class="op">/</span> x] (x <span class="op">+</span> y)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Distribute:</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>→ λy. ([y <span class="op">/</span> x] x) <span class="op">+</span> ([y <span class="op">/</span> x] y)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Substitute y where we found an x:</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>→ λy. y <span class="op">+</span> y</span></code></pre></div>
<p><strong>Note</strong>: <code>[e₁ / x] e₂</code> is read as
“substitute <code>e₁</code> for <code>x</code> in <code>e₂</code>.”</p>
<p>We started with a function which would take two numbers and sum them.
After partially applying that function, we’ve ended up with a function
that doubles it’s argument. Whoops! We can look at the issue visually in
this diagram:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python tight-code"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>           ◀─────┐             ┃         ┌──┐</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>             λy. y <span class="op">+</span> y         ┃        λy. y <span class="op">+</span> y</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>              └──────┘         ┃         └──────┘</span></code></pre></div>
<p>We were expecting to get out the binding structure on the left, but
instead we got the binding structure on the right. This is called
“variable capture” or just <span
class="smallcaps"><strong>capture</strong></span> for short. The
<code>y</code> that we applied to the summing function was captured by
the binding site of the nested lambda.</p>
<h1 id="explicit-variables">Explicit Variables</h1>
<p>When we’re implementing substitution (whether for terms, for types,
or for any other sort of syntax), our primary goal is to implement <span
class="smallcaps"><strong>capture-avoiding substitution</strong></span>.
There are many internal representations we can pick from to achieve
this. The strategy above where variables were simple strings is called
<span class="smallcaps"><strong>explicit variables</strong></span>.</p>
<p>Explicit variables are nice because we can represent them directly
with an algebraic data type. For example, for the lambda calculus we
might have this:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> term</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  = Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  | Lam <span class="kw">of</span> <span class="dt">string</span> * term</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  | App <span class="kw">of</span> term * term</span></code></pre></div>
<p>Implementing capture-avoiding substitution using this representation
isn’t pleasant, but it is possible. It uses the observation that there’s
no difference between, say <code>λx. x</code> and <code>λy. y</code>.
Our choice of variable names doesn’t matter—they’re both the identity
function.</p>
<p>Being able to rename bound variables at will is called <span
class="smallcaps"><strong>α-varying</strong></span>, and when two terms
can be made identical by just α-varying them, we say they’re <span
class="smallcaps"><strong>α-equivalent</strong></span>.</p>
<p>It only makes sense to α-vary bound variables, not free variables. If
we have two functions like <code>λx. x + y</code> and
<code>λx. x + z</code>, we can’t safely α-vary <code>y</code> to
<code>z</code>, because we have no way of knowing whether <code>y</code>
and <code>z</code> are the same! Their same-ness depends on the
context.</p>
<p>We can implement capture-avoiding substitution for the explicit
variable representation by α-varying whenever we detect that a variable
might be captured. To revisit our example from earlier:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  (λx. λy. x <span class="op">+</span> y) y</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>→ [y <span class="op">/</span> x] (λy. x <span class="op">+</span> y)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># our free &#39;y&#39; will get captured by going under</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># this λ, so let&#39;s α-vary the bound &#39;y&#39; to &#39;z&#39;:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>→ [y <span class="op">/</span> x] (λz. x <span class="op">+</span> z)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>→ λz. [y <span class="op">/</span> x] (x <span class="op">+</span> z)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>→ λz. y <span class="op">+</span> z</span></code></pre></div>
<p>The trick here is that by picking <code>z</code> we picked a name
that doesn’t collide with any of the free variables with in
<code>λy. x + y</code>. Namely, we’re glad we didn’t α-vary
<code>y</code> to <code>x</code>! To ensure this, our implementation can
either</p>
<ul>
<li>calculate the set of free variables used in a subexpression and make
sure not to use one of those, or</li>
<li>generate a globally unique name by incrementing a global counter,
giving us names like <code>x1</code>, <code>x2</code>, <code>x3</code>,
etc.</li>
</ul>
<p>On the surface, explicit variables look rather naïve, and maybe they
are. However, they work perfectly if you don’t need substitution in the
first place! For example, a compiler never needs to substitute a term
for a variable in another term because compilers don’t evaluate code:
they translate one intermediate language into another.</p>
<p>On the other hand, interpreters use term substitution heavily, and
even compilers need to substitute types for variables in other types and
in terms. We’ll now look at some better solutions for implementing
capture-avoiding substitution.</p>
<h1 id="de-bruijn-indices">De Bruijn Indices</h1>
<p>With explicit variables, we had to keep track of names in use and
check whether to α-vary before a collision happened. The next
representation we’ll look at sidesteps this problem by not giving names
to variables at all! Let’s take a look at our picture from before:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python tight-code"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>                             ┌──────┐</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                        λx. λy. x <span class="op">+</span> y</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                         └──────┘</span></code></pre></div>
<p>In this picture, the only thing that’s really important to us is the
binding structure; we don’t actually care that <code>x</code> is called
<code>x</code>, we just care that applying this function sticks the
argument everywhere the line on the bottom points to. We could omit the
names entirely, as long as we can still remember where the lines should
connect to:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python tight-code"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>                            ┌─────┐</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                       (λ. λ. ◆ <span class="op">+</span> ◆)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                         └────┘</span></code></pre></div>
<p>One way of doing this is to count how many bindings sites up you have
to go before you arrive at the location the variable is bound. Under
this representation, variables are indices into a list of the binding
sites; we call these indices <span class="smallcaps"><strong>de Bruijn
indices</strong></span>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>                       (λ. λ. ① <span class="op">+</span> ⓪)</span></code></pre></div>
<p><strong>Note</strong>: I’m using circled numbers like <code>⓪</code>
for the variable with de Bruijn index <code>0</code>.</p>
<p>Under this representation, a de Bruijn index of 1 means “skip over
one lambda” and an index of 0 means “skip over zero lambdas” or simply
“go to the closest lambda.” In code, de Bruijn terms can be represented
with this datatype:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> term</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  = Var <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  | Lam <span class="kw">of</span> term</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  | App <span class="kw">of</span> term * term</span></code></pre></div>
<p><code>Var</code> now takes an <code>int</code> instead of a
<code>string</code>. <code>Lam</code> only takes the body of the lambda
(it used to also take a name for it’s argument). To refer to argument of
a lambda function, we count back the appropriate number of
<code>Lam</code>s to skip over.</p>
<p>Now that all variables are represented by indices, it’s much easier
to know which variables are free and which are bound: a variable is free
if its index is larger than the number of lambdas it’s under.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python tight-code"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>                      ◀───────────────┐</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>                            ┌──────┐  │</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                       (λ. λ. ① <span class="op">+</span> ⓪) ③</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                         └────┘</span></code></pre></div>
<p>The <code>③</code> is free because it’s under zero lambdas. Put
another way, if we were keeping a list of the binding sites we’d
traverse under to reach <code>③</code> our list would be empty, so
accessing index 3 would be out of bounds.</p>
<p>With this representation, capture avoiding substitution becomes much
more manageable.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  (λ. λ. ① <span class="op">+</span> ⓪) ③</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>→ [③ <span class="op">/</span> ⓪] (λ. ① <span class="op">+</span> ⓪)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co"># We increment free variables as we descend under binders</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>→ λ. [④ <span class="op">/</span> ①] (① <span class="op">+</span> ⓪)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>→ λ. ([④ <span class="op">/</span> ①] ①) <span class="op">+</span> ([④ <span class="op">/</span> ①] ⓪)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>→ λ. ④ <span class="op">+</span> ⓪</span></code></pre></div>
<p>Note how the <code>③</code> changed to a <code>④</code>: its new
location in the program lies under one extra lambda than before. Thus to
refer to the same position as at the start of the substitution, we
increment to record that we’ll have to skip over that extra lambda. This
process of adding one when going under a binder is called <span
class="smallcaps"><strong>lifting</strong></span> (or sometimes, <span
class="smallcaps"><strong>shifting</strong></span>).</p>
<p>Lifting takes the guesswork out of implementing substitution. As a
bonus, we’ve actually forced α-equivalent terms to have identical
structure! Checking for α-equivalence is now a straightforward tree
traversal: we check that both nodes are pairwise equal, then that their
children are α-equivalent.</p>
<h1 id="de-bruijn-indices-and-lifting">De Bruijn Indices and
Lifting</h1>
<p>On the other hand, working with de Bruijn indices can still be
tricky. It’s easy enough to remember to lift variables when
substituting, but more generally, you have to remember to lift
<strong>whenever</strong> you put a free variable into a context
different from where it was defined. This can get really hairy; spotting
when a usage context diverges from a definition context is a skill
that’s often learned the hard way! Namely, by forgetting to lift
somewhere, pouring over the code and the types for hours, then finally
spotting the mistake.<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote">If it wasn’t clear, this has happened to me many times,
and yes I’m still getting over it 😓<br />
<br />
</span></span></p>
<p>To make this a little more concrete, I’ll use a specific example. It
comes from the judgement for deciding whether two type constructors are
equivalent in System F<sub>ω</sub>. Focus on the variables and contexts
in use (don’t pay too much attention to what the judgement actually
is):</p>
<p><span class="math display">
\frac{
\Gamma, \alpha :: \kappa_1 \; \vdash \; c \, \alpha \iff c&#39; \,
\alpha :: \kappa_2
}{
\Gamma \; \vdash \; c \iff c&#39; :: \kappa_1 \to \kappa_2
}
</span></p>
<p>In words, “to check whether type constructors <code>c</code> and
<code>c'</code> are equivalent, assume that <code>α</code> is a type
constructor of kind <code>κ₁</code>, then apply <code>α</code> to
<code>c</code> and <code>c'</code> and see if you get the same result in
both cases.” Though again, understanding this judgement is beside the
point.</p>
<p>The real tricky part here is obscured by the fact that we’re
representing variables with names instead of de Bruijn indices. If we
were to take a naive pass at translating this rule to use de Bruijn
indices, we might end up with:</p>
<p><span class="math display">
\frac{
\Gamma, \kappa_1 \; \vdash \; c \, ⓪ \iff c&#39; \, ⓪ :: \kappa_2
}{
\Gamma \; \vdash \; c \iff c&#39; :: \kappa_1 \to \kappa_2
}
</span></p>
<p>Note how <code>Γ</code> became a stack instead of a map because we’re
mapping <em>indices</em> to kinds (instead of string keys to kinds). The
element we just pushed on (<code>κ₁</code>) is on the top of the stack
at index <code>0</code>, and everything else in the context can now be
found at <code>index + 1</code>. That means that above the line,
<code>⓪</code> refers to the <code>κ₁</code> in the context.</p>
<p>But <code>⓪</code> might <strong>also</strong> be in use at the top
level of <code>c</code> or <code>c'</code>! In either of these terms,
<code>⓪</code> at the top level is a free variable referring to the
first thing in <code>Γ</code>. The problem is that we’re checking
<code>c ⓪ &lt;=&gt; c' ⓪</code> with context <code>Γ, κ₁</code> rather
than <code>Γ</code>, so all our indices are off.</p>
<p>To make all the indices in <code>c</code> and <code>c'</code> route
to the correct variable in the new context, we have to go through
<code>c</code> and <code>c'</code> and lift all free variables by one to
reflect the fact that we just injected something into the surrounding
context:</p>
<p><span class="math display">
\frac{
\Gamma, \kappa_1 \; \vdash \; (c \uparrow) \, ⓪ \iff (c&#39; \uparrow)
\, ⓪ :: \kappa_2
}{
\Gamma \; \vdash \; c \iff c&#39; :: \kappa_1 \to \kappa_2
}
</span></p>
<p>In this rule, <code>↑</code> is the lifting operator, which traverses
through a term’s free variables and increments them. After it’s run,
there will be no free variables in <code>c</code> or <code>c'</code>
with index 0, which gives us room to use <code>⓪</code> for our own
purposes.</p>
<p>In some sense, this is the opposite problem that we had when we used
explicit variables. For that, we had to go through and rename
<strong>bound variables</strong> so that nothing clashed. Now, we have
to lift <strong>free variables</strong> so that nothing clashes. Put
another way, explicit variables excel at dealing with free variables,
while de Bruijn indices excel at representing bound variables.</p>
<p>The next representation we’ll look at, locally nameless terms,
effectively steals the best of each, combining them into one
representation.</p>
<h1 id="locally-nameless-terms">Locally Nameless Terms</h1>
<p>We identified that de Bruijn indices represent bound variables well
at the expense of free variables. <span
class="smallcaps"><strong>Locally nameless terms</strong></span> solve
this by giving free variables explicit names, but using indices instead
of names for bound (or “local”) variables, thus the name.<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="sidenote">We could, by analogy, refer to the de Bruijn index
representation as the globally nameless representation, which is more
descriptive but isn’t something you’ll hear used anywhere.<br />
<br />
</span></span></p>
<p>Locally nameless terms might be represented by a data type like
this:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> term</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  = FV <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  | BV <span class="kw">of</span> <span class="dt">int</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  | Lam <span class="kw">of</span> term</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  | App <span class="kw">of</span> term * term</span></code></pre></div>
<p><code>FV</code> constructs a free variable, and similarly
<code>BV</code> constructs a bound variable. <code>FV</code> takes a
<code>string</code>, because free variables get names, and
<code>BV</code> takes an <code>int</code>, because bound variables are
nameless de Bruijn indices. As before, <code>Lam</code> only takes the
body of the lambda function; we’ll use de Bruijn indices to count back
to the appropriate binding site of a variable.</p>
<p>In practice, locally nameless terms are best provided through a
library, where this internal implementation is hidden and the user
interacts with an abstract interface:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode sml"><code class="sourceCode sml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* The actual type of a locally nameless term with *)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* a distinction between FV and BV is hidden       *)</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> term</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">(* termView is only one level deep: after that, *)</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* you end up with a term, which is abstract    *)</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">datatype</span> termView</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  = Var <span class="kw">of</span> <span class="dt">string</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  | Lam <span class="kw">of</span> <span class="dt">string</span> * term</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  | App <span class="kw">of</span> term * term</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">(* Convert between the abstract and view types *)</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> out : term -&gt; termView</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> into : termView -&gt; term</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">(* Substitution and alpha equivalence work on abstract terms *)</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> subst : term -&gt; <span class="dt">string</span> -&gt; term</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="kw">val</span> aeq : term -&gt; term -&gt; <span class="dt">bool</span></span></code></pre></div>
<p>The fresh name generation from explicit variables is handled under
the hood by <code>out</code>. Lifting is handled automatically every
time we call <code>into</code> on a <code>Lam</code>. By only
implementing operations like <code>subst</code> and <code>aeq</code> on
the abstract representations, we’ve effectively forced the type system
to check that we lift and generate fresh names in all the right
places!</p>
<h1 id="closing-considerations">Closing Considerations</h1>
<p>Locally nameless terms are generally pretty great. They blend the
strengths of explicit variables and de Bruijn indices into a new
structure that makes working with variables and binding hard to get
wrong. That being said, I’d be remiss if I didn’t point out two
drawbacks:</p>
<ul>
<li>Locally nameless terms can be slow.
<ul>
<li>In most code, we’ll find ourselves converting between
<code>term</code>s and <code>termView</code>s. This brings with it the
overhead of the function call, allocating new memory for the new
structures, and can even sometimes make a linear algorithm accidentally
quadratic.</li>
</ul></li>
<li>It’s more annoying to use pattern matching.
<ul>
<li>Most of the time we’ll have things of type <code>term</code>. Since
<code>term</code> is abstract, we can’t pattern match on it directly; we
have to instead call <code>out</code> and pattern match the result.</li>
</ul></li>
</ul>
<p>Despite these drawbacks, I still prefer locally nameless terms.</p>
<ul>
<li><p>I’ll gladly trade correctness for performance, and it’s
definitely easier to be correct when working with locally nameless
terms. We can always optimize for performance later by profiling the
code to find the slowness!</p></li>
<li><p>Calling <code>out</code> in a few places is a small ergonomic
price to pay for correctness. When you forget to call <code>out</code>
or <code>into</code>, the type checker will remind you. There are also
some cool language extensions which can make calling <code>out</code>
and <code>in</code> syntactically more pleasant, like <a
href="https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html">View
Patterns</a> in Haskell.</p></li>
</ul>
<p>Variables show up in the most interesting places, and I always smile
when I find them being used in new and surprising ways. On the flip
side, languages that don’t implement variables and binding suffer no end
of trouble and programmers are forced to cope with their absence.<span
class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span
class="sidenote">It’s for this very reason that variables are the first
topic we cover in <a
href="https://www.cs.cmu.edu/~rwh/courses/ppl/">15-312 Principles of
Programming Languages</a>.<br />
<br />
</span></span></p>
<p>I think variables are just so cool!</p>
<!-- vim:tw=72
-->
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#plt">plt</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

