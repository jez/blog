<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2018-04-19 01:43:26 -0400">
<meta name="description" content="Union types are powerful yet often overlooked. At work, I've been using Flow which thankfully supports union types. But as I've refactored more of our code to use union types, I've noticed that our bundle size has been steadily increasing!
">
<title>Union Types in Flow & Reason ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  




</head>
<body>
  




  <header>
    <h1 class="title">Union Types in Flow & Reason</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2018-04-19 01:43:26 -0400">April 19, 2018</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">‚äï</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#setup-union-types-in-a-react-component">Setup: Union Types in a React Component</a></li>
  <li><a href="#switch-optimizing-for-exhaustiveness"><code>switch</code>: Optimizing for Exhaustiveness</a></li>
  <li><a href="#correctness-but-at-what-cost">Correctness, but at what cost?</a></li>
  <li><a href="#types-and-optimizing-compilers">Types and Optimizing Compilers</a></li>
  <li><a href="#appendix-other-compile-to-js-runtimes">Appendix: Other Compile-to-JS Runtimes</a>
  <ul>
  <li><a href="#typescript">TypeScript</a></li>
  <li><a href="#purescript">PureScript</a></li>
  <li><a href="#elm">Elm</a></li>
  </ul></li>
  </ul>
</nav>

<main>
<p>Union types are powerful yet often overlooked. At work, I‚Äôve been using Flow which <a href="https://flow.org/en/docs/types/unions/">thankfully supports union types</a>. But as I‚Äôve refactored more of our code to use union types, I‚Äôve noticed that our bundle size has been steadily increasing!</p>
<!-- more -->
<p>In this post, we‚Äôre going to explore why that‚Äôs the case. We‚Äôll start with a problem which union types can solve, flesh out the problem to motivate why union types are definitely the solution, then examine the resulting cost of introducing them. In the end, we‚Äôll compare Flow to other compile-to-JS languages on the basis of how they represent union types in the compiled output. I‚Äôm especially excited about <a href="https://reasonml.github.io/">Reason</a>, so we‚Äôll talk about it the most.</p>
<h1 id="setup-union-types-in-a-react-component">Setup: Union Types in a React Component</h1>
<p>Let‚Äôs consider we‚Äôre writing a simple React 2FA<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">2FA: two-factor authentication<br />
<br />
</span></span> modal. We‚Äôll be using Flow, but you can pretend it‚Äôs TypeScript if you want. The mockup we were given looks like this:</p>
<p><a href="/assets/img/2fa-mockup.jpeg"><img src="/assets/img/2fa-mockup.jpeg" alt="A sample mockup for a two-factor authenticaion modal" /></a></p>
<p>In this mockup:</p>
<ul>
<li>There‚Äôs a loading state while we send the text message.</li>
<li>We‚Äôll show an input for the code after the message is sent.</li>
<li>There‚Äôs no failure screen (it hasn‚Äôt been drawn up yet).</li>
</ul>
<p>We‚Äôll need some way for our component to know which of the three screens is visible. Let‚Äôs use a <a href="https://flow.org/en/docs/types/unions/">union type</a> in Flow:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>type Screen <span class="op">=</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;LoadingScreen&#39;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;CodeEntryScreen&#39;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;SuccessScreen&#39;</span><span class="op">;</span></span></code></pre></div>
<p>Union types are a perfect fit! üéâ Union types document intent and can help guard against mistakes. Fellow developers and our compiler can know ‚Äúthese are all the cases.‚Äù In particular, Flow can warn us when we‚Äôve <a href="/flow-exhaustiveness/">forgotten a case</a>.</p>
<p>Our initial implementation is working great. After sharing it with the team, someone suggests adding a ‚Äúcancel‚Äù button in the top corner. It doesn‚Äôt make sense to cancel when the flow has already succeeded, so we‚Äôll exclude it from the last screen:</p>
<p><a href="/assets/img/2fa-close-btn.jpeg"><img src="/assets/img/2fa-close-btn.jpeg" alt="Adding a close button to our modal" /></a></p>
<p>No problem: let‚Äôs write a function called <code>needsCancelButton</code> to determine if we need to put a cancel button in the header of a particular screen:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> needsCancelButton <span class="op">=</span> (<span class="bu">screen</span><span class="op">:</span> Screen)<span class="op">:</span> boolean <span class="kw">=&gt;</span> {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// Recall: &#39;SuccessScreen&#39; is the last screen,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// so it shouldn&#39;t have a cancel button.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">screen</span> <span class="op">!==</span> <span class="st">&#39;SuccessScreen&#39;</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Short and sweet. üëå Everything seems to be working great, until‚Ä¶</p>
<h1 id="switch-optimizing-for-exhaustiveness"><code>switch</code>: Optimizing for Exhaustiveness</h1>
<p>The next day, we get some updated mocks from the design team. This time, they‚Äôve also drawn up a ‚Äúfailure‚Äù screen for when the customer has entered the wrong code too many times:</p>
<p><a href="/assets/img/2fa-failure-screen.jpeg"><img src="/assets/img/2fa-failure-screen.jpeg" alt="The failure screen for our modal" /></a></p>
<p>We can handle this‚Äîwe‚Äôll just add a case to our <code>Screen</code> type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>type Screen <span class="op">=</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;LoadingScreen&#39;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;CodeEntryScreen&#39;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;SuccessScreen&#39;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// New case to handle too many wrong attempts:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&#39;FailureScreen&#39;</span><span class="op">;</span></span></code></pre></div>
<p>But now <strong>there‚Äôs a bug</strong> in our <code>needsCancelButton</code> function. üòß We should only show a close button on screens where it makes sense, and <code>'FailureScreen'</code> is not one of those screens. Our first reaction after discovering the bug would be to just blacklist <code>'FailureScreen'</code> too:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> needsCancelButton <span class="op">=</span> (<span class="bu">screen</span><span class="op">:</span> Screen)<span class="op">:</span> boolean <span class="kw">=&gt;</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">screen</span> <span class="op">!==</span> <span class="st">&#39;SuccessScreen&#39;</span> <span class="op">||</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">screen</span> <span class="op">!==</span> <span class="st">&#39;FailureScreen&#39;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  )<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>But we can do better than just fixing the <strong>current</strong> bug. We should write code so that when we add a new case to a union type, our type checker alerts us before a <strong>future</strong> bug even happens. What if instead of a silent bug, we got this cheery message from our type checker?</p>
<blockquote>
<p>Hey, you forgot to add a case to <code>needsCancelButton</code> for the new screen you added. <em>üôÇ</em></p>
<p>‚Äî your friendly, neighborhood type checker</p>
</blockquote>
<p>Let‚Äôs go back and rewrite <code>needsCancelButton</code> so that it <strong>will</strong> tell us this when adding new cases. We‚Äôll use a <code>switch</code> statement with <a href="/flow-exhaustiveness/">something special in the <code>default</code> case</a>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> impossible <span class="op">=</span> <span class="op">&lt;</span>T<span class="op">&gt;</span>(x<span class="op">:</span> empty)<span class="op">:</span> T <span class="kw">=&gt;</span> {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&#39;This case is impossible.&#39;</span>)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> needsCancelButton <span class="op">=</span> (<span class="bu">screen</span><span class="op">:</span> Screen)<span class="op">:</span> boolean <span class="kw">=&gt;</span> {</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> (<span class="bu">screen</span>) {</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;LoadingScreen&#39;</span><span class="op">:</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;CodeEntryScreen&#39;</span><span class="op">:</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;SuccessScreen&#39;</span><span class="op">:</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">// (I named this function &#39;absurd&#39; in my earlier post:</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">// https://blog.jez.io/flow-exhaustiveness/)</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>      <span class="co">// This function asks Flow to check for exhaustiveness.</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>      <span class="co">//</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>      <span class="co">// [flow]: Error: Cannot call `impossible` with `screen` bound to `x` because string literal `FailureScreen` [1] is incompatible with empty [2].</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="fu">impossible</span>(<span class="bu">screen</span>)<span class="op">;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiAuBPADgU1AZQMYBOWWAdqALyKigA+oA5ADKwCGAJgJakDmBxZBtTqMAwrHZYAoqRSE0-EqSE16DXAFd8+LAGddiwcLUAxVp2gbih5QG5k+WKV0pQnALYZY+zgCNoOBSgADwAKgB8ABQAHgBcoFie6ACU8aGU4aAA3sIoABaECKCkWPCgUoSFhJEMoXmcuqD4rLo4DW6e3rp+AQB0DMn2AL4OTi7FJOy6oqykOtAAQhooKE6UoJG6RErxNqmgvrCwAbMZ2cK68Jwo+HkbWwKkyec0NM2tjCwc3HzbgrHCV6gYgoKzkOQaLD2IHvHAMcSSGRyBR-ZQAoE0EFg0AQqGApotOGabR6AyohjojFYwjkSCsaCtaGvECgACqc1g7ncZFcq1AkE40RxeRwJjgZSwlVghHxLNhjDMFisWBsFNlYGBWFBNP59MZ+MkdI00BQlKB1PIHi8Pn8WE2qMGwhGQyAA"><strong>(Play with it on Try Flow ‚Üí)</strong></a></p>
<p>Now Flow is smart enough to give us an error! Making our code safer, one <code>switch</code> statement at a time. üòÖ Union types in Flow are a powerful way to use types to guarantee correctness. But to get the most out of union types, <strong>always</strong><span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">‚ÄúAlways‚Äù is a very strong statement. Please use your best judgement. But know that if you‚Äôre not using a <code>switch</code>, you‚Äôre trading off the burden of exhaustiveness &amp; correctness from the type checker to the programmer!<br />
<br />
</span></span> access them through a <code>switch</code> statement. Every time we use a union type without an exhaustive switch statement, we make it harder for Flow to tell us where we‚Äôve missed something.</p>
<h1 id="correctness-but-at-what-cost">Correctness, but at what cost?</h1>
<p>You might not have noticed, but we paid a subtle cost in rewriting our <code>needsCancelButton</code> function. Let‚Äôs compare our two functions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// ----- before: 62 bytes (minified) -----</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> needsCancelButton <span class="op">=</span> (<span class="bu">screen</span>) <span class="kw">=&gt;</span> {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">screen</span> <span class="op">!==</span> <span class="st">&#39;SuccessScreen&#39;</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">// ----- after: 240 bytes (minified) -----</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> impossible <span class="op">=</span> (x) <span class="kw">=&gt;</span> {</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&#39;This case is impossible.&#39;</span>)<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> needsCancelButton <span class="op">=</span> (<span class="bu">screen</span>) <span class="kw">=&gt;</span> {</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> (<span class="bu">screen</span>) {</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;LoadingScreen&#39;</span><span class="op">:</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;CodeEntryScreen&#39;</span><span class="op">:</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;SuccessScreen&#39;</span><span class="op">:</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="fu">impossible</span>(<span class="bu">screen</span>)<span class="op">;</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>With just an equality check, our function was small: 62 bytes minified. But when we refactored to use a <code>switch</code> statement, its size shot up to 240 bytes! That‚Äôs a 4x increase, just to get exhaustiveness. Admittedly, <code>needsCancelButton</code> is a bit of a pathological case. But in general: as we make our code bases <strong>more safe</strong> using Flow‚Äôs union types of string literals, our <strong>bundle size bloats</strong>!</p>
<h1 id="types-and-optimizing-compilers">Types and Optimizing Compilers</h1>
<p>One of the many overlooked promises of types is the claim that by writing our code with <strong>higher-level abstractions</strong>, we give more information to the compiler. The compiler can then generate code that captures our original intent, but as efficiently as possible.</p>
<p>Flow is decidedly <strong>not</strong> a compiler: it‚Äôs only a type checker. To run JavaScript annotated with Flow types, we first strip the types (with something like Babel). All information about the types vanishes when we run the code.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Even though TypeScript defines both a language <strong>and</strong> a compiler for that language, in practice it‚Äôs not much different from Flow here. A goal of the TypeScript compiler is to generate JavaScript that closely resembles the original TypeScript, so it doesn‚Äôt do compile-time optimizations based on the types.<br />
<br />
</span></span> What can we achieve if we were to <strong>keep the types around</strong> all the way through compilation?</p>
<p><a href="https://reasonml.github.io/">Reason</a> (i.e., ReasonML) is an exciting effort to bring all the benefits of the OCaml tool chain to the web. In particular, Reason works using OCaml‚Äôs mature optimizing compiler alongside BuckleScript (which turns OCaml to JavaScript) to emit great code.</p>
<p>To see what I mean, let‚Äôs re-implement our <code>Screen</code> type and <code>needsCancelButton</code> function, this time in Reason:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>type <span class="bu">screen</span> <span class="op">=</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> LoadingScreen</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> CodeEntryScreen</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> SuccessScreen<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> needsCancelButton <span class="op">=</span> (<span class="bu">screen</span><span class="op">:</span> <span class="bu">screen</span>)<span class="op">:</span> bool <span class="kw">=&gt;</span> {</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> (<span class="bu">screen</span>) {</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> LoadingScreen <span class="kw">=&gt;</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> CodeEntryScreen <span class="kw">=&gt;</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> SuccessScreen <span class="kw">=&gt;</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p>Looks pretty close to JavaScript with Flow types, doesn‚Äôt it? The biggest difference is that the <code>case</code> keyword was replaced with the <code>|</code> character. Making the way we define and use union types look the same is a subtle reminder to always pair union types with <code>switch</code> statements! <span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">More than being a nice reminder, it makes it easy to copy / paste our type definition as boilerplate to start writing a new function!<br />
<br />
</span></span> Another difference: Reason handles exhaustiveness checking out of the box. üôÇ</p>
<p>What does the Reason output look like?</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Generated by BUCKLESCRIPT VERSION 3.0.1, PLEASE EDIT WITH CARE</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="st">&#39;use strict&#39;</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">needsCancelButton</span>(<span class="bu">screen</span>) {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="bu">screen</span> <span class="op">&gt;=</span> <span class="dv">2</span>) {</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p><a href="https://reasonml.github.io/en/try.html?rrjsx=true&amp;reason=C4TwDgpgBAzgxgJwhAdlAvAKClAPlAGQHsBDAEwEsUBzAZUWRWzygGEiyIBRFYBEeklTN8tAK5w4EGDEGMA3JkwAbCMCgpkZGKxIopygEJjgwImnRQAFPCEoAXLAaoAlI4BGRIsowA+KADezDAA7hTAcAAW1raMLoEihKSUNHKoflB8YhCKOPjsnDx8As4W-lk5ieKS0rKlGQBmJMowlTgAvpjtikA"><strong>(Play with it on Try Reason ‚Üí)</strong></a></p>
<p>Not bad! Telling Reason that our function was exhaustive let it optimize the entire <code>switch</code> statement back down to a single <code>if</code> statement. In fact, it gets even better: when we run this through <code>uglifyjs</code>, it removes the redundant <code>true</code> / <code>false</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;use strict&quot;</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">needsCancelButton</span>(n){</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">!</span>(n<span class="op">&gt;=</span><span class="dv">2</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Wow! This is actually <strong>better</strong> than our initial, hand-written <code>if</code> statement. Reason compiled what used to be a string literal <code>'SuccessScreen'</code> to just the number <code>2</code>. Reason can do this safely because custom-defined types in Reason <strong>aren‚Äôt</strong> strings, so it doesn‚Äôt matter if the names get mangled.</p>
<p>Taking a step back, Reason‚Äôs type system delivered on the promise of types in a way Flow couldn‚Äôt:</p>
<ul>
<li>We wrote high-level, expressive code.</li>
<li>The type checker gave us strong guarantees about our code‚Äôs correctness via exhaustiveness.</li>
<li>The compiler translated that all to tiny, performant output.</li>
</ul>
<p>I‚Äôm really excited about Reason. üòÑ It has a delightful type system and is backed by a decades-old optimizing compiler tool chain. I‚Äôd love to see more people take advantage of improvements in type systems to write better code!</p>
<hr />
<h1 id="appendix-other-compile-to-js-runtimes">Appendix: Other Compile-to-JS Runtimes</h1>
<p>The above analysis only considered Flow + Babel and Reason. But then I got curious about how other typed languages that compile to JavaScript compare on the optimizations front:</p>
<h2 id="typescript">TypeScript</h2>
<p>Despite being a language <strong>and</strong> compiler, TypeScript maintains a goal of compiling to JavaScript that closely resembles the source TypesScript code. TypeScript has three language constructs for working with exhaustiveness:</p>
<ol type="1">
<li>union types (identical to the Flow unions that we‚Äôve been talking about),</li>
<li><code>enum</code>s, which are sort of like definition a group of variable constants all at once, and</li>
<li><code>const enum</code>s which are like <code>enum</code>s except that they‚Äôre represented more succinctly in the compiled output.</li>
</ol>
<p>TypeScript‚Äôs union type over string literals are represented the same way as Flow, so I‚Äôm going to skip (1) and focus instead on (2) and (3).</p>
<p>TypeScript‚Äôs <code>enum</code> and <code>const enum</code> are subtly different. Not having used the language much, I‚Äôll refer you to <a href="https://www.typescriptlang.org/docs/handbook/enums.html">the TypeScript documentation</a> to learn more about the differences. But for sure, <code>const enum</code>s compile much better than normal <code>enum</code>s.</p>
<p>Here‚Äôs what normal <code>enum</code>s look like in TypeScript‚Äîthey‚Äôre <strong>even worse</strong> than unions of string literals:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> Screen_<span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">function</span> (Screen_) {</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    Screen_[Screen_[<span class="st">&quot;LoadingScreen&quot;</span>] <span class="op">=</span> <span class="dv">0</span>] <span class="op">=</span> <span class="st">&quot;LoadingScreen&quot;</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    Screen_[Screen_[<span class="st">&quot;CodeEntryScreen&quot;</span>] <span class="op">=</span> <span class="dv">1</span>] <span class="op">=</span> <span class="st">&quot;CodeEntryScreen&quot;</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    Screen_[Screen_[<span class="st">&quot;SuccessScreen&quot;</span>] <span class="op">=</span> <span class="dv">2</span>] <span class="op">=</span> <span class="st">&quot;SuccessScreen&quot;</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>})(Screen_ <span class="op">||</span> (Screen_ <span class="op">=</span> {}))<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> impossible <span class="op">=</span> <span class="kw">function</span> (x) {</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&#39;This case is impossible.&#39;</span>)<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> needsCancelButton <span class="op">=</span> <span class="kw">function</span> (<span class="bu">screen</span>) {</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (<span class="bu">screen</span>) {</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Screen_<span class="op">.</span><span class="at">LoadingScreen</span><span class="op">:</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Screen_<span class="op">.</span><span class="at">CodeEntryScreen</span><span class="op">:</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> Screen_<span class="op">.</span><span class="at">SuccessScreen</span><span class="op">:</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">impossible</span>(<span class="bu">screen</span>)<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p><a href="https://www.typescriptlang.org/play/#src=enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error(&#39;This%20case%20is%20impossible.&#39;)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground ‚Üí</strong></a></p>
<p>So for normal <code>enum</code>s:</p>
<ul>
<li>It‚Äôs not smart enough to optimize away the <code>impossible</code> call.</li>
<li>It keeps around a JavaScript object representing the collection of enum values at run time, in a format that doesn‚Äôt minify well.</li>
</ul>
<p>And then here‚Äôs what <code>const enum</code>s look like‚Äîyou can see that TypeScript represents them under the hood without any sort of <code>Screen_</code> object:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> impossible <span class="op">=</span> <span class="kw">function</span> (x) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&#39;This case is impossible.&#39;</span>)<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> needsCancelButton <span class="op">=</span> <span class="kw">function</span> (<span class="bu">screen</span>) {</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (<span class="bu">screen</span>) {</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">0</span> <span class="co">/* LoadingScreen */</span><span class="op">:</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">1</span> <span class="co">/* CodeEntryScreen */</span><span class="op">:</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> <span class="dv">2</span> <span class="co">/* SuccessScreen */</span><span class="op">:</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fu">impossible</span>(<span class="bu">screen</span>)<span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<p><a href="https://www.typescriptlang.org/play/#src=const%20enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error(&#39;This%20case%20is%20impossible.&#39;)%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground ‚Üí</strong></a></p>
<ul>
<li>It uses numbers instead of strings.</li>
<li>It still uses a switch statement, instead of reducing to just an <code>if</code> statement.</li>
</ul>
<h2 id="purescript">PureScript</h2>
<p>PureScript is another high-level language like Reason. Both Reason and PureScript have data types where we can define unions with custom constructor names. Despite that, PureScript‚Äôs generated code is significantly worse than Reason‚Äôs.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;use strict&quot;</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> LoadingScreen <span class="op">=</span> (<span class="kw">function</span> () {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">LoadingScreen</span>() {}<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    LoadingScreen<span class="op">.</span><span class="at">value</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">LoadingScreen</span>()<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> LoadingScreen<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>})()<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> CodeEntryScreen <span class="op">=</span> (<span class="kw">function</span> () {</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">CodeEntryScreen</span>() {}<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    CodeEntryScreen<span class="op">.</span><span class="at">value</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">CodeEntryScreen</span>()<span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> CodeEntryScreen<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>})()<span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> SuccessScreen <span class="op">=</span> (<span class="kw">function</span> () {</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> <span class="fu">SuccessScreen</span>() {}<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    SuccessScreen<span class="op">.</span><span class="at">value</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">SuccessScreen</span>()<span class="op">;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> SuccessScreen<span class="op">;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>})()<span class="op">;</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> needsCancelButton <span class="op">=</span> <span class="kw">function</span> (v) {</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (v <span class="kw">instanceof</span> LoadingScreen) {</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (v <span class="kw">instanceof</span> CodeEntryScreen) {</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (v <span class="kw">instanceof</span> SuccessScreen) {</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    }<span class="op">;</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;Failed pattern match at Main line 10, column 1 - line 10, column 39: &quot;</span> <span class="op">+</span> [ v<span class="op">.</span><span class="at">constructor</span><span class="op">.</span><span class="at">name</span> ])<span class="op">;</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span></code></pre></div>
<ul>
<li>It‚Äôs generating ES5 classes for each data constructor.</li>
<li>It compiles pattern matching to a series of <code>instanceof</code> checks.</li>
<li>Even though it <strong>knows</strong> the match is exhaustive, it still emits a <code>throw</code> statement in case the pattern match fails!</li>
</ul>
<p>Admittedly, I didn‚Äôt try that hard to turn on optimizations in the compiler. Maybe there‚Äôs a flag I can pass to get this <code>Error</code> to go away. But that‚Äôs pretty disappointing, compared to how small Reason‚Äôs generated code was!</p>
<h2 id="elm">Elm</h2>
<p>I list Elm in the same class as Reason and PureScript. Like the other two, it lets us define custom data types, and will automatically warn when us pattern matches aren‚Äôt exhaustive. Here‚Äôs the code Elm generates:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> _user$project$Main$needsCancelButton <span class="op">=</span> <span class="kw">function</span> (page) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">var</span> _p0 <span class="op">=</span> page<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> (_p0<span class="op">.</span><span class="at">ctor</span>) {</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;LoadingScreen&#39;</span><span class="op">:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&#39;CodeEntryScreen&#39;</span><span class="op">:</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">default</span><span class="op">:</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> _user$project$Main$SuccessScreen <span class="op">=</span> {<span class="dt">ctor</span><span class="op">:</span> <span class="st">&#39;SuccessScreen&#39;</span>}<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> _user$project$Main$CodeEntryScreen <span class="op">=</span> {<span class="dt">ctor</span><span class="op">:</span> <span class="st">&#39;CodeEntryScreen&#39;</span>}<span class="op">;</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> _user$project$Main$LoadingScreen <span class="op">=</span> {<span class="dt">ctor</span><span class="op">:</span> <span class="st">&#39;LoadingScreen&#39;</span>}<span class="op">;</span></span></code></pre></div>
<ul>
<li>It‚Äôs using string literals, much like Flow and TypeScript.</li>
<li>It‚Äôs smart enough to collapse the last case to just use <code>default</code> (at least it doesn‚Äôt <code>throw</code> in the <code>default</code> case!)</li>
<li>The variable names are long, but these would still minify well.</li>
</ul>
<p>It‚Äôs interesting to see that even though Reason, PureScript, and Elm all have ML-style datatypes, Reason is the only one that uses an integer representation for the constructor tags.</p>
<!-- vim:tw=72
-->
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#flow">flow</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#types">types</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#javascript">javascript</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#reasonml">reasonml</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

