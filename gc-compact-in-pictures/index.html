<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2020-12-18 15:03:58 -0500">
<meta name="description" content="Ruby's opt-in GC compaction is both really cool and also kind of scary, so we're going to chat about both, with pictures.">
<title>GC.compact in Pictures ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">GC.compact in Pictures</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2020-12-18 15:03:58 -0500">December 18, 2020</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">‚Üê Return home</a><br>
</nav>

<main>
<blockquote>
<p><strong>Editing note</strong>: This post first appeared in a work-internal email. It was first cross-posted to this blog December 12, 2022.</p>
</blockquote>
<p>At a high level, Ruby‚Äôs garbage collection algorithm is a mark-and-sweep collector. In Ruby 2.7, Ruby‚Äôs GC algorithm gets a little more sophisticated: not only does it mark-and-sweep, but it can be asked to compact memory!</p>
<p>This is both really cool and also kind of scary, so we‚Äôre going to chat about both, with pictures.</p>
<p>The Ruby VM manages memory on behalf of the programmer. Internally, it knows which parts of memory correspond to allocated and free things:</p>
<p><img src="/assets/img/light/gc-compact-ruby-mem.png" /></p>
<p><img src="/assets/img/dark/gc-compact-ruby-mem.png" /></p>
<p>When you do something like</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span class="kw">=</span> <span class="dt">MyClass</span><span class="at">.new</span></span></code></pre></div>
<p>Ruby will allocate enough space to hold that value behind the scenes. When that object isn‚Äôt needed anymore, it‚Äôll get freed. Over the life cycle of an application that allocates and frees a lot (read: literally every Ruby program), memory can get pretty fragmented: even though there might be space available, it might not all be contiguous. That means:</p>
<ul>
<li>it‚Äôs not available for the operating system to give to someone else</li>
<li>there might not be space for a ‚Äúbig‚Äù allocation if all that‚Äôs left are ‚Äúsmall‚Äù holes</li>
</ul>
<p>That second one can be pretty annoying:</p>
<p><img src="/assets/img/light/gc-compact-oom.png" /></p>
<p><img src="/assets/img/dark/gc-compact-oom.png" /></p>
<p>A neat innovation in GC algorithms is what are called <strong>compacting garbage collection</strong> algorithms. These kinds of algorithms periodically (either automatically, on on request), shuffle all the allocated memory around so that it lines up nicely, with no gaps:</p>
<p><img src="/assets/img/light/gc-compact-compaction.png" /></p>
<p><img src="/assets/img/dark/gc-compact-compaction.png" /></p>
<p>That‚Äôs what was added in Ruby 2.7! Just call:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cn">GC</span><span class="at">.compact</span></span></code></pre></div>
<p>in a Ruby program to request that the VM runtime compact its heap. That‚Äôs great! It means our programs go out of memory less frequently, can run with more headroom (to handle spiky workloads), and can get better cache locality.</p>
<p>If we had called <code>GC.compact</code> before we asked the Ruby VM to do a bunch of allocations (maybe, in between every handful of API requests), then there‚Äôs a greater chance that Ruby will be able to give us the memory we ask for:</p>
<p><img src="/assets/img/light/gc-compact-no-oom.png" /></p>
<p><img src="/assets/img/dark/gc-compact-no-oom.png" /></p>
<p>‚Ä¶ phew! So compacting garbage collection seems great, right?</p>
<p>In theory yes. In practice, it‚Äôs a bit trickier, especially because many Ruby gems using Ruby‚Äôs C extension API.</p>
<p>In a Ruby C extension, the extension has its own memory, and some of the things it stores can be pointers into the Ruby VM‚Äôs heap. As long as those values don‚Äôt move around on the heap, the pointers will be valid as long as the object is still alive.</p>
<p>But in Ruby 2.7, <code>GC.compact</code> causes memory to shuffle around, which can have some really annoying consequences:</p>
<p><img src="/assets/img/light/gc-compact-mem-crash.png" /></p>
<p><img src="/assets/img/dark/gc-compact-mem-crash.png" /></p>
<p>In this example, we‚Äôve got a Ruby C extension with a pointer into the Ruby VM‚Äôs heap. After one round of GC compaction, that pointer has been completely invalidated: the pointer is pointing at unallocated data üò±</p>
<p>Scarier still, is that something could be allocated into that (now available) spot! In that case, it will appear to the C extension like its value just changed out of thin air to something else entirely. That can cause all sorts of wild problems. Some examples:</p>
<ul>
<li>A <code>TypeError</code> or similar exception, because the new value is a completely different type</li>
<li>Database corruption bugs, because maybe the new value is ‚Äúgood enough‚Äù that it doesn‚Äôt crash anything, and makes its way all the way to the database, even though it‚Äôs the wrong value.</li>
</ul>
<p>Probably the most annoying part: these bugs can be near impossible to reproduce. What gets allocated (or not allocated) into any given slot depends heavily on the arbitrary order in which objects are allocated and freed over the lifetime of a running service. This makes it hard (though not always impossible) to write test cases or reproduce the problems in a staging environment.</p>
<p>This caused more than a handful of problems at work as we upgraded from Ruby 2.6 to Ruby 2.7. Of course, there‚Äôs a solution: the Ruby C extension API includes functions that declare which values the C extension expects not to move:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>VALUE my_global_hash;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Init_my_c_extension() {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  my_global_hash = rb_hash_new();</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (*) This requests that the GC not move this object:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  rb_gc_mark(my_global_hash);</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>So far in the Ruby 2.7 upgrade, every problem we saw in production that wasn‚Äôt first caught by CI has been fixed by either patching a C extension to use <code>rb_gc_mark</code> in more places, or upgrading a gem that has already been fixed.</p>
<p>If you want to read more about this sort of stuff:</p>
<ul>
<li>Aaron ‚Äútenderlove‚Äù Patterson (author of the 2.7 GC compaction changes) gave a talk about it:<br />
‚Üí <a href="https://www.youtube.com/watch?v=1F3gXYhQsAY">Compacting Heaps in Ruby 2.7</a></li>
<li>Aaron‚Äôs ticket tracking the GC changes does a good job of explaining the intricacies<br />
‚Üí <a href="https://bugs.ruby-lang.org/issues/15626">Manual Compaction for MRI‚Äôs GC (<code>GC.compact</code>)</a></li>
<li>Alan Wu‚Äôs list of tips for debugging memory movement problems:<br />
‚Üí <a href="https://alanwu.space/post/check-compaction/">Checking Ruby C extensions for object movement crashes</a></li>
</ul>
<p>And if you have any questions, please let me know!</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#in-pictures">in-pictures</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

