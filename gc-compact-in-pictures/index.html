<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2020-12-18 15:03:58 -0500">
<meta name="description" content="Ruby's opt-in GC compaction is both really cool and also kind of scary, so we're going to chat about both, with pictures.">
<title>GC.compact in Pictures ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">GC.compact in Pictures</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2020-12-18 15:03:58 -0500">December 18, 2020</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">‚Üê Return home</a><br>
</nav>

<main>
<blockquote>
<p><strong>Editing note</strong>: This post first appeared in a
work-internal email. It was first cross-posted to this blog December 12,
2022.</p>
</blockquote>
<p>At a high level, Ruby‚Äôs garbage collection algorithm is a
mark-and-sweep collector. In Ruby 2.7, Ruby‚Äôs GC algorithm gets a little
more sophisticated: not only does it mark-and-sweep, but it can be asked
to compact memory!</p>
<p>This is both really cool and also kind of scary, so we‚Äôre going to
chat about both, with pictures.</p>
<p>The Ruby VM manages memory on behalf of the programmer. Internally,
it knows which parts of memory correspond to allocated and free
things:</p>
<p><img src="/assets/img/light/gc-compact-ruby-mem.png" /></p>
<p><img src="/assets/img/dark/gc-compact-ruby-mem.png" /></p>
<p>When you do something like</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>x <span class="kw">=</span> <span class="dt">MyClass</span><span class="at">.new</span></span></code></pre></div>
<p>Ruby will allocate enough space to hold that value behind the scenes.
When that object isn‚Äôt needed anymore, it‚Äôll get freed. Over the life
cycle of an application that allocates and frees a lot (read: literally
every Ruby program), memory can get pretty fragmented: even though there
might be space available, it might not all be contiguous. That
means:</p>
<ul>
<li>it‚Äôs not available for the operating system to give to someone
else</li>
<li>there might not be space for a ‚Äúbig‚Äù allocation if all that‚Äôs left
are ‚Äúsmall‚Äù holes</li>
</ul>
<p>That second one can be pretty annoying:</p>
<p><img src="/assets/img/light/gc-compact-oom.png" /></p>
<p><img src="/assets/img/dark/gc-compact-oom.png" /></p>
<p>A neat innovation in GC algorithms is what are called
<strong>compacting garbage collection</strong> algorithms. These kinds
of algorithms periodically (either automatically, on on request),
shuffle all the allocated memory around so that it lines up nicely, with
no gaps:</p>
<p><img src="/assets/img/light/gc-compact-compaction.png" /></p>
<p><img src="/assets/img/dark/gc-compact-compaction.png" /></p>
<p>That‚Äôs what was added in Ruby 2.7! Just call:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cn">GC</span><span class="at">.compact</span></span></code></pre></div>
<p>in a Ruby program to request that the VM runtime compact its heap.
That‚Äôs great! It means our programs go out of memory less frequently,
can run with more headroom (to handle spiky workloads), and can get
better cache locality.</p>
<p>If we had called <code>GC.compact</code> before we asked the Ruby VM
to do a bunch of allocations (maybe, in between every handful of API
requests), then there‚Äôs a greater chance that Ruby will be able to give
us the memory we ask for:</p>
<p><img src="/assets/img/light/gc-compact-no-oom.png" /></p>
<p><img src="/assets/img/dark/gc-compact-no-oom.png" /></p>
<p>‚Ä¶ phew! So compacting garbage collection seems great, right?</p>
<p>In theory yes. In practice, it‚Äôs a bit trickier, especially because
many Ruby gems using Ruby‚Äôs C extension API.</p>
<p>In a Ruby C extension, the extension has its own memory, and some of
the things it stores can be pointers into the Ruby VM‚Äôs heap. As long as
those values don‚Äôt move around on the heap, the pointers will be valid
as long as the object is still alive.</p>
<p>But in Ruby 2.7, <code>GC.compact</code> causes memory to shuffle
around, which can have some really annoying consequences:</p>
<p><img src="/assets/img/light/gc-compact-mem-crash.png" /></p>
<p><img src="/assets/img/dark/gc-compact-mem-crash.png" /></p>
<p>In this example, we‚Äôve got a Ruby C extension with a pointer into the
Ruby VM‚Äôs heap. After one round of GC compaction, that pointer has been
completely invalidated: the pointer is pointing at unallocated data
üò±</p>
<p>Scarier still, is that something could be allocated into that (now
available) spot! In that case, it will appear to the C extension like
its value just changed out of thin air to something else entirely. That
can cause all sorts of wild problems. Some examples:</p>
<ul>
<li>A <code>TypeError</code> or similar exception, because the new value
is a completely different type</li>
<li>Database corruption bugs, because maybe the new value is ‚Äúgood
enough‚Äù that it doesn‚Äôt crash anything, and makes its way all the way to
the database, even though it‚Äôs the wrong value.</li>
</ul>
<p>Probably the most annoying part: these bugs can be near impossible to
reproduce. What gets allocated (or not allocated) into any given slot
depends heavily on the arbitrary order in which objects are allocated
and freed over the lifetime of a running service. This makes it hard
(though not always impossible) to write test cases or reproduce the
problems in a staging environment.</p>
<p>This caused more than a handful of problems at work as we upgraded
from Ruby 2.6 to Ruby 2.7. Of course, there‚Äôs a solution: the Ruby C
extension API includes functions that declare which values the C
extension expects not to move:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>VALUE my_global_hash<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Init_my_c_extension<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  my_global_hash <span class="op">=</span> rb_hash_new<span class="op">();</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// (*) This requests that the GC not move this object:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  rb_gc_mark<span class="op">(</span>my_global_hash<span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>So far in the Ruby 2.7 upgrade, every problem we saw in production
that wasn‚Äôt first caught by CI has been fixed by either patching a C
extension to use <code>rb_gc_mark</code> in more places, or upgrading a
gem that has already been fixed.</p>
<p>If you want to read more about this sort of stuff:</p>
<ul>
<li>Aaron ‚Äútenderlove‚Äù Patterson (author of the 2.7 GC compaction
changes) gave a talk about it:<br />
‚Üí <a href="https://www.youtube.com/watch?v=1F3gXYhQsAY">Compacting Heaps
in Ruby 2.7</a></li>
<li>Aaron‚Äôs ticket tracking the GC changes does a good job of explaining
the intricacies<br />
‚Üí <a href="https://bugs.ruby-lang.org/issues/15626">Manual Compaction
for MRI‚Äôs GC (<code>GC.compact</code>)</a></li>
<li>Alan Wu‚Äôs list of tips for debugging memory movement problems:<br />
‚Üí <a href="https://alanwu.space/post/check-compaction/">Checking Ruby C
extensions for object movement crashes</a></li>
</ul>
<p>And if you have any questions, please let me know!</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

