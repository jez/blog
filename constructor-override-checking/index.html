<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2023-12-31 00:14:09 -0500">
<meta name="description" content="A discussion of how constructors in typical typed object-oriented languages get away with not having to solve a problem that plagues Sorbet.
">
<title>Why don't constructors have override checking? – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Why don't constructors have override checking?</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2023-12-31 00:14:09 -0500">December 31, 2023</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#ruby">Ruby</a></li>
  <li><a href="#java">Java</a></li>
  <li><a href="#ramifications-for-override-checking">Ramifications for override checking</a></li>
  <li><a href="#bonus-ramifications-for-generic-type-inference">Bonus: ramifications for generic type inference</a></li>
  </ul>
</nav>

<main>
<p>This year I spent a lot of time looking at how constructors work in object oriented languages.</p>
<h1 id="ruby">Ruby</h1>
<p>For example, Ruby constructors look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">Box</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> initialize(val)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">@val</span> <span class="kw">=</span> val</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>box <span class="kw">=</span> <span class="dt">Box</span><span class="at">.new</span>(<span class="vs">&#39;hello&#39;</span>)</span></code></pre></div>
<p>It’s interesting because you define <code>initialize</code> as an instance method, but then you call a <code>new</code> as a singleton class method. We can do some digging to figure out how that works:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>❯ irb <span class="kw">-</span>r<span class="st">&quot;./box&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>irb(main):<span class="dv">001</span>:<span class="dv">0</span><span class="kw">&gt;</span> <span class="dt">Box</span><span class="at">.method</span>(<span class="wa">:new</span>)<span class="at">.source_location</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">=&gt;</span> <span class="dv">nil</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>irb(main):<span class="dv">002</span>:<span class="dv">0</span><span class="kw">&gt;</span> <span class="dt">Box</span><span class="at">.method</span>(<span class="wa">:new</span>)<span class="at">.owner</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">=&gt;</span> <span class="dt">Class</span></span></code></pre></div>
<p>A nil <code>source_location</code> usually means it’s a method defined in the Ruby VM, so the easiest thing is to grep the Ruby VM source code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource plain wide numberLines hl-5"><code class="sourceCode"><span id="cb3-1"><a href="#cb3-1"></a>~/github/ruby/ruby ((HEAD detached at v3_3_0))</span>
<span id="cb3-2"><a href="#cb3-2"></a>❯ rg &#39;Class.*&quot;new&quot;&#39;</span>
<span id="cb3-3"><a href="#cb3-3"></a>object.c</span>
<span id="cb3-4"><a href="#cb3-4"></a>4417:    rb_undef_method(CLASS_OF(rb_cNilClass), &quot;new&quot;);</span>
<span id="cb3-5"><a href="#cb3-5"></a>4478:    rb_define_method(rb_cClass, &quot;new&quot;, rb_class_new_instance_pass_kw, -1);</span>
<span id="cb3-6"><a href="#cb3-6"></a>4498:    rb_undef_method(CLASS_OF(rb_cTrueClass), &quot;new&quot;);</span>
<span id="cb3-7"><a href="#cb3-7"></a>4510:    rb_undef_method(CLASS_OF(rb_cFalseClass), &quot;new&quot;);</span></code></pre></div>
<p>We can pull up the implementation of <code>Class#new</code>, which is split across a couple functions:</p>
<figure class="left-align-caption">
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource c wide numberLines hl-6 hl-7"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1"></a>VALUE</span>
<span id="cb4-2"><a href="#cb4-2"></a>rb_class_new_instance_pass_kw(<span class="dt">int</span> argc, <span class="dt">const</span> VALUE *argv, VALUE klass)</span>
<span id="cb4-3"><a href="#cb4-3"></a>{</span>
<span id="cb4-4"><a href="#cb4-4"></a>    VALUE obj;</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    obj = rb_class_alloc(klass);</span>
<span id="cb4-7"><a href="#cb4-7"></a>    rb_obj_call_init_kw(obj, argc, argv, RB_PASS_CALLED_KEYWORDS);</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="cf">return</span> obj;</span>
<span id="cb4-10"><a href="#cb4-10"></a>}</span></code></pre></div>
<figcaption>
<a href="https://github.com/ruby/ruby/blob/v3_3_0/object.c#L2125-L2134">object.c:2125-2134</a>
</figcaption>
</figure>
<figure class="left-align-caption">
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource c wide numberLines hl-5"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">void</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>rb_obj_call_init_kw(VALUE obj, <span class="dt">int</span> argc, <span class="dt">const</span> VALUE *argv, <span class="dt">int</span> kw_splat)</span>
<span id="cb5-3"><a href="#cb5-3"></a>{</span>
<span id="cb5-4"><a href="#cb5-4"></a>    PASS_PASSED_BLOCK_HANDLER();</span>
<span id="cb5-5"><a href="#cb5-5"></a>    rb_funcallv_kw(obj, idInitialize, argc, argv, kw_splat);</span>
<span id="cb5-6"><a href="#cb5-6"></a>}</span></code></pre></div>
<figcaption>
<a href="https://github.com/ruby/ruby/blob/v3_3_0/eval.c#L1705-L1710">eval.c:1705-1710</a>
</figcaption>
</figure>
<p>From this we gather that the implementation of <code>Class#new</code> is basically the same as this Ruby code:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">Class</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> new(<span class="kw">...</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    obj <span class="kw">=</span> <span class="dv">self</span><span class="at">.alloc</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    obj<span class="at">.initialize</span>(<span class="kw">...</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    obj</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>The <code>alloc</code> method asks the garbage collector to allocate memory for the new instance (but does not initialize it). Then with an instance in hand, Ruby can dispatch to the <code>initialize</code> instance method.</p>
<p>If the class doesn’t implement an <code>initialize</code> method, the dispatch goes all the way up to <code>BasicObject#initialize</code>, which takes no arguments and returns <code>nil</code>.</p>
<h1 id="java">Java</h1>
<p>There’s a lot of similarity to the way it works in Java, but there are also quite a few differences.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Box</span> {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">Object</span> val;</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">Box</span>(<span class="bu">Object</span> val) {</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span>.<span class="fu">val</span> = val;</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Main {</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    var box = <span class="kw">new</span> <span class="bu">Box</span>(<span class="st">&quot;hello&quot;</span>);</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(box.<span class="fu">val</span>);</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>To figure out how this works, we can take a look at the Java bytecode:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource plain wide extra-wide numberLines hl-1 hl-12 hl-13 hl-14 hl-15"><code class="sourceCode"><span id="cb8-1"><a href="#cb8-1"></a>❯ javac Box.java &amp;&amp; javap -c Main</span>
<span id="cb8-2"><a href="#cb8-2"></a>Compiled from &quot;Box.java&quot;</span>
<span id="cb8-3"><a href="#cb8-3"></a>class Main {</span>
<span id="cb8-4"><a href="#cb8-4"></a>  Main();</span>
<span id="cb8-5"><a href="#cb8-5"></a>    Code:</span>
<span id="cb8-6"><a href="#cb8-6"></a>       0: aload_0</span>
<span id="cb8-7"><a href="#cb8-7"></a>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>
<span id="cb8-8"><a href="#cb8-8"></a>       4: return</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a>  public static void main(java.lang.String[]);</span>
<span id="cb8-11"><a href="#cb8-11"></a>    Code:</span>
<span id="cb8-12"><a href="#cb8-12"></a>       0: new           #7                  // class Box</span>
<span id="cb8-13"><a href="#cb8-13"></a>       3: dup</span>
<span id="cb8-14"><a href="#cb8-14"></a>       4: ldc           #9                  // String hello</span>
<span id="cb8-15"><a href="#cb8-15"></a>       6: invokespecial #11                 // Method Box.&quot;&lt;init&gt;&quot;:(Ljava/lang/Object;)V</span>
<span id="cb8-16"><a href="#cb8-16"></a>       9: astore_1</span>
<span id="cb8-17"><a href="#cb8-17"></a>      10: getstatic     #14                 // Field java/lang/System.out:Ljava/io/PrintStream;</span>
<span id="cb8-18"><a href="#cb8-18"></a>      13: aload_1</span>
<span id="cb8-19"><a href="#cb8-19"></a>      14: getfield      #20                 // Field Box.val:Ljava/lang/Object;</span>
<span id="cb8-20"><a href="#cb8-20"></a>      17: invokevirtual #24                 // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span></code></pre></div>
<p>These numbers like <code>#7</code> and <code>#11</code> are references into the constant pool, which is basically like static data in a class file. You can see the whole pool with <code>javap -v</code> instead of <code>javap -c</code>, but it’s long and basically just shows what’s in the comment so I omitted it.</p>
<p>Some of my observations:</p>
<ul>
<li><p>The “allocate memory” step and the “initialize the instance” step are separate bytecode instructions (<a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html#jvms-6.5.new"><code>new</code></a> vs <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html#jvms-6.5.invokespecial"><code>invokespecial</code></a>). In Ruby, there’s only one bytecode instruction (the call to the <code>.new</code> method), and the logic is hidden behind that method call. But otherwise, they both have these two steps.</p>
<p>This smells a lot like inlining even if it’s technically not, and I’d bet that allows the JIT a better chance to optimize it (versus a Ruby JIT having to guess whether a call to <code>.new</code> is this very common “alloc + initialize” use case or something else).</p></li>
<li><p>Just like how Ruby has an <code>initialize</code> method, in Java there’s this special <code>&lt;init&gt;</code> method. Experience tells me that’s a clever trick compilers/VMs use when they want to be able to use normal methods for something internally, but don’t want that fact to leak to users.</p>
<p>For example, because <code>x.&lt;init&gt;()</code> is a syntax error, no one can ever call the constructor a second time. Meanwhile in Ruby, you can technically call <code>x.initialize</code> whenever you want.</p></li>
<li><p>It’s using <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html#jvms-6.5.invokespecial"><code>invokespecial</code></a>, which is basically a cross breed between static and dynamic dispatch. The dispatch target is resolved at compile time: it takes the method to call as a bytecode operand, like <code>#11</code>, which is a reference into the constant pool. In this way it’s just like <code>inovkestatic</code>. But unlike <code>invokestatic</code>, <code>invokespecial</code> expects a method receiver to be on the VM stack in addition to the call’s arguments, the same way that an instance method call would work. So despite essentially doing static dispatch, it’s still going to bind <code>this</code> to a value when the method runs.</p></li>
<li><p>There’s a default constructor, but it isn’t called via dynamic dispatch up to the top of the object hierarchy (like <code>BasicObject#initialize</code> in Ruby). Rather, if a class doesn’t have a user-defined constructor, the Java compiler emits an explicit <code>invokespecial</code> to the <code>Object."&lt;init&gt;"</code> method directly (or whatever the parent of the current class is).</p></li>
<li><p>If a child class does not have a constructor, and the parent class has a non-nullary constructor, that’s an error—the child class must declare some sort of constructor and explicitly call <code>super(...)</code> with whatever arguments the parent class’s constructor needs.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parent {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">Parent</span>(<span class="dt">int</span> x) {}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Child <span class="kw">extends</span> Parent {</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ❌must declare constructor and call `super(...)`</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
</ul>
<h1 id="ramifications-for-override-checking">Ramifications for override checking</h1>
<p>I was looking into these things because I was curious about how typed, object-oriented languages like Java and Scala and C++ handle <a href="https://sorbet.org/docs/override-checking#a-note-on-variance">override compatibility checking</a> (Liskov substitution checking) for constructors.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Parent {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">boolean</span> <span class="fu">foo</span>() { <span class="kw">return</span> <span class="kw">false</span>; }</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Child <span class="kw">extends</span> Parent {</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ❌ incompatible override</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> <span class="fu">foo</span>() { <span class="kw">return</span> <span class="dv">0</span>; }</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The answer is: they don’t, because they don’t function like other instance methods. In fact, they’re almost entirely like static methods, except for the fact that they have <code>this</code> bound, via the fancy <code>invokespecial</code> instruction.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">In fact they’re called “instance initialization methods,” and they’re <a href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-2.html#jvms-2.9">defined here</a>.<br />
<br />
</span></span> Just like static methods, these special <code>&lt;init&gt;</code> methods aren’t inherited, can’t be called via <code>super</code>, and don’t get override checking.</p>
<p>But this answer isn’t satisfying for Ruby and Sorbet. Ruby allows calling <code>new</code> polymorphically, since singleton class methods are dispatched dynamically, not statically. Sorbet can’t get away with the “skip all override checking on constructors” argument that Java and other typed, object-oriented languages can.</p>
<p>Ruby is not the only language that has first-class objects… How do other languages handle this, like Python, TypeScript, Flow, and Hack?</p>
<p>Python and Flow ignore the problem. Hack at least has an annotation that lets you opt into the checks. Sorbet also has such an annotation (either <code>abstract</code><span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">By the way, allowing <code>abstract</code> constructors already breaks with tradition: constructors are not normally allowed to be abstract. But that’s kind of a side-effect of how constructors act like static methods, and in Java/Scala/C++ static methods are not allowed to be abstract either. Since they’re not inherited nor called polymorphically, what would be the point of an abstract constructor in those languages? This is why the <a href="https://en.wikipedia.org/wiki/Abstract_factory_pattern">Abstract Factory pattern</a> is so notorious, because it’s the only way to get polymorphic constructors in those languages.<br />
<br />
</span></span> or <code>overridable</code>), but people aren’t required to annotate them so it doesn’t catch as many bugs as it should and I find that pretty unsatisfying.</p>
<p>The funny thing is that TypeScript just sidesteps the issue by way of <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a>. In TypeScript <code>typeof Parent</code> is not compatible with <code>typeof Child</code> if their constructors are different. (In a nominal type system, simply having <code>Child</code> descend from <code>Parent</code> should be the only factor in determining whether those types are compatible).</p>
<p>On the one hand there’s a certain elegance to this approach. But in the small amount of time I’ve spent writing code in structurally typed languages (TypeScript, Go), I’ve been super annoyed by the fact that I can’t just change a type of an interface method and see all the methods whose types I need to update. Instead, I get errors repeated at every call site where an object no longer satisfies some required interface, far away from where I’ll need to write code to fix the problem. But that’s a personal rant, and regardless: Sorbet is not a structural type system so it can’t steal this solution.</p>
<p>This problem is still unsolved in Sorbet (<a href="https://github.com/sorbet/sorbet/issues/7274">#7274</a>, <a href="https://github.com/sorbet/sorbet/issues/7309">#7309</a>, <a href="https://github.com/sorbet/sorbet/issues/7555">#7555</a>). At least it’s not alone in leaving it unsolved, but I <em>would</em> like to make it better one day, especially given <a href="/inheritance-in-ruby/">how frequently</a> people use <code>new</code> polymorphically in Ruby.</p>
<p><br />
</p>
<p><br />
</p>
<hr />
<h1 id="bonus-ramifications-for-generic-type-inference">Bonus: ramifications for generic type inference</h1>
<p>The other reason why I wanted to look at this was to see how languages deal with the overlap between constructors and type inference:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Box[Value](x: Value) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> value = x</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>@main <span class="kw">def</span> <span class="fu">main</span>() =</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">val</span> box = Box(<span class="dv">0</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">println</span>(box.<span class="fu">value</span>)</span></code></pre></div>
<p>This Scala program infers a type of <code>Box[int]</code> for the <code>box</code> variable. The corresponding program in Sorbet would look like</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">Box</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">extend</span> T<span class="kw">::</span><span class="dt">Generic</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Value</span> <span class="kw">=</span> type_member</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  sig <span class="kw">{</span> params(<span class="wa">x: </span><span class="dt">Value</span>)<span class="at">.void</span> <span class="kw">}</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> initialize(x)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">@value</span> <span class="kw">=</span> x</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>box <span class="kw">=</span> <span class="dt">Box</span><span class="at">.new</span>(<span class="dv">0</span>)</span></code></pre></div>
<p>Except that Sorbet doesn’t infer a type of <code>Box[Integer]</code>, it infers a type of <code>Box[T.untyped]</code>. The problem is that <code>initialize</code> isn’t a generic method, like</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>sig <span class="cf">do</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  type_parameters(<span class="wa">:U</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">.params</span>(<span class="wa">x: </span>T<span class="at">.type_parameter</span>(<span class="wa">:U</span>))</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">.void</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="cf">def</span> initialize(x); <span class="cf">end</span></span></code></pre></div>
<p>Sorbet only infers types for a method’s generic type parameters, not for the class’s generic type parameters used in a method. I was wondering if any other language addressed this by being clever and assuming that the “static part” of the constructor was actually a method in its own right, which had a signature mirroring the instance method part:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">Box</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ...</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Implicitly assume something like this method was defined:</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  sig <span class="cf">do</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    type_parameters(<span class="wa">:Value</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      <span class="at">.params</span>(<span class="wa">x: </span>T<span class="at">.type_parameter</span>(<span class="wa">:Value</span>))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">.returns</span>(T<span class="at">.all</span>(T<span class="at">.attached_class</span>), <span class="dt">Box</span><span class="kw">[</span>T<span class="at">.type_parameter</span>(<span class="wa">:Value</span>)<span class="kw">]</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> <span class="dv">self</span><span class="at">.new</span>(x)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="dv">super</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>So for example, Sorbet would pretend like the singleton class <code>new</code> method would:</p>
<ul>
<li>Have one type parameter for every type member in the class.</li>
<li>Replace every occurrence of a type member in the signature with the corresponding type parameter.</li>
<li>Use <a href="/generic-constructor-trick/">ths trick</a> for the return value, so it respects being called on a subclass of the current class.</li>
</ul>
<p>From looking into other languages, I mostly convinced myself that other languages’ type inference algorithms are different enough from Sorbet that they represent the inference constraints in such a different way that it isn’t worth asking whether they do this (Sorbet somewhat famously does a very <a href="https://blog.nelhage.com/post/why-sorbet-is-fast/#simple-type-inference">simple form of inference</a> that doesn’t generate constraints before solving them). Regardless, I think that something along these lines could work for Sorbet in the future.</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#types">types</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

