<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2018-07-17 21:23:23 -0700">
<meta name="description" content="I want to call attention to what I think is a race condition in one of the code listings in the book "Concurrent Programming in ML". The problem is that some of the data isn't protected by a lock, which can lead to a stale read and incorrect behavior. I trace the bad behavior, and propose a fix.
">
<title>Concurrent Programming in ML: A Race – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  




</head>
<body>
  




  <header>
    <h1 class="title">Concurrent Programming in ML: A Race</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2018-07-17 21:23:23 -0700">July 17, 2018</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#setup-snippets-from-the-book">Setup: Snippets from the Book</a></li>
  <li><a href="#a-trace-to-expose-the-problem">A trace to expose the problem</a></li>
  <li><a href="#fixing-the-stale-read">Fixing the stale read</a></li>
  </ul>
</nav>

<main>
<p>Lately I’ve been super interested in language models for concurrency, after hearing a fascinating talk from Adam Solove on <a href="https://medium.com/@asolove/synchronizable-abstractions-for-understandable-concurrency-64ae57cd61d1">synchronizable abstractions for UI</a>.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Unfortunately, the talk isn’t online (Adam presented it at work), so the blog post linked above is the next best thing!<br />
<br />
</span></span> I’ve been working my way through a handful of books, including <a href="https://simonmar.github.io/pages/pcph.html">PCPH</a>, the Concurrency section of <a href="http://www.cs.cmu.edu/~rwh/pfpl.html">PFPL</a>, and most recently <a href="http://www.cambridge.org/gb/academic/subjects/computer-science/distributed-networked-and-mobile-computing/concurrent-programming-ml?format=AR">Concurrent Programming in ML</a>, by John Reppy.</p>
<p>In particular, I think I’ve found a race condition in one of the code listings of Concurrent Programming in ML. After introducing the listing itself, we’ll walk through a trace that shows the errant behavior, then propose a small change that prevents it from happening.</p>
<h1 id="setup-snippets-from-the-book">Setup: Snippets from the Book</h1>
<p>Before we begin, here’s the listing in full. It’s a sample implementation of a 1-element concurrent buffer, using condition variables. It supports creation, insertion, and removal.</p>
<figure>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource sml numberLines"><code class="sourceCode sml"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">datatype</span> &#39;a buffer = BUF <span class="kw">of</span> {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  data      : &#39;a <span class="dt">option</span> <span class="dt">ref</span>,</span>
<span id="cb1-3"><a href="#cb1-3"></a>  mu        : mutex,</span>
<span id="cb1-4"><a href="#cb1-4"></a>  dataAvail : condition,</span>
<span id="cb1-5"><a href="#cb1-5"></a>  dataEmpty : condition</span>
<span id="cb1-6"><a href="#cb1-6"></a>}</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">fun</span> buffer () =</span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="kw">let</span> <span class="kw">val</span> mu = mutex() <span class="kw">in</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    BUF {</span>
<span id="cb1-11"><a href="#cb1-11"></a>      data      = <span class="dt">ref</span> NONE,</span>
<span id="cb1-12"><a href="#cb1-12"></a>      mu        = mu,</span>
<span id="cb1-13"><a href="#cb1-13"></a>      dataAvail = condition mu,</span>
<span id="cb1-14"><a href="#cb1-14"></a>      dataEmpty = condition mu</span>
<span id="cb1-15"><a href="#cb1-15"></a>    }</span>
<span id="cb1-16"><a href="#cb1-16"></a>  <span class="kw">end</span></span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="kw">fun</span> insert (BUF {data, mu, dataAvail, dataEmpty}, v) =</span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="kw">let</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="kw">fun</span> waitLp NONE = (data := SOME v; signal dataAvail)</span>
<span id="cb1-21"><a href="#cb1-21"></a>      | waitLp (SOME v) = (wait dataEmpty; waitLp (!data))</span>
<span id="cb1-22"><a href="#cb1-22"></a>  <span class="kw">in</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    withLock mu waitLp (!data)</span>
<span id="cb1-24"><a href="#cb1-24"></a>  <span class="kw">end</span></span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="kw">fun</span> remove (BUF {data, mu, dataAvail, dataEmpty}) =</span>
<span id="cb1-27"><a href="#cb1-27"></a>  <span class="kw">let</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>    <span class="kw">fun</span> waitLp NONE = (wait dataAvail; waitLp (!data))</span>
<span id="cb1-29"><a href="#cb1-29"></a>      | waitLp (SOME v) = (data := NONE; signal dataEmpty)</span>
<span id="cb1-30"><a href="#cb1-30"></a>  <span class="kw">in</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>    withLock mu waitLp (!data)</span>
<span id="cb1-32"><a href="#cb1-32"></a>  <span class="kw">end</span></span></code></pre></div>
<figcaption>
Concurrent Programming in ML, Listing 2.3
</figcaption>
</figure>
<p>You might also want to reference this exerpt which explains the semantics of the concurrency primitives at play in the snippet above: locks and condition variables. Study the listing above and exerpt below for a moment. See if you can spot a race, or are convinced the code is correct.</p>
<blockquote>
<p>The semantics of the expression</p>
<p><code>withLock mu f x</code></p>
<p>are that first the lock mu is acquired, then the function f is applied to x, and then the function’s result is returned after releasing the lock.</p>
<p>The basic operations on condition variables are</p>
<p><code>val wait : condition -&gt; unit</code></p>
<p>which causes a process to block on the condition variable, and</p>
<p><code>val signal : condition -&gt; unit</code></p>
<p>which wakes up one waiting process. A condition variable is associated with a specific mutex lock, which must be held when performing a wait operation on the variable. The semantics of the wait operation are that the mutex lock is released, and then the process is blocked; when the condition is signaled, the next process in the condition’s waiting queue is unblocked and it reacquires the mutex lock and proceeds. A signal operation on a condition variable that has an empty waiting queue has no effect; in this sense condition variables are memoryless.</p>
<p>— <em>Concurrent Programming in ML</em>, section 2.4.2</p>
</blockquote>
<h1 id="a-trace-to-expose-the-problem">A trace to expose the problem</h1>
<p>The problem I see has to do with SML’s eager evaluation: before calling a function <code>f e</code>, we evaluate <code>e</code> to a value <code>v</code>. Then substitution kicks in and we substitute <code>v</code> into the body of <code>f</code>. For us, that means that in the definition of <code>insert</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fun</span> insert <span class="co">(* ··· *)</span> =</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* ··· *)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    withLock mu waitLp (!data)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">(* ··· *)</span></span></code></pre></div>
<p>we evaluate <code>!data</code> to a value before we run the body of <code>withLock</code> to acquire the lock. When inserting into an empty queue, <code>!data</code> evaluates to <code>NONE</code>. And since this happens outside the <code>withLock</code> if two calls to insert attempt to acquire the lock at the same time, they’ll both think the queue is empty when they wake up! When this happens, the one to wake up second will unknowingly overwrite what the first one inserted.</p>
<p>Here’s a sample trace of a program allocating a buffer and then doing two concurrent insertions:</p>
<figure class="wide">
<div class="sourceCode" id="cb3"><pre class="sourceCode sml"><code class="sourceCode sml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* &#39;=&gt;&#39; marks steps where two threads evolve concurrently  *)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">(* &#39;-&gt;&#39; marks steps where just one thread evalautes        *)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>-&gt; <span class="kw">val</span> buf = buffer ()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">(* Fork two threads; both have access to &#39;buf&#39;.            *)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* thread 1 *)</span>                       <span class="co">(* thread 2 *)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>=&gt; insert buf <span class="dv">1</span>                         insert buf <span class="dv">2</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>=&gt; withLock mu waitLp (!data)           withLock mu waitLp (!data)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>=&gt; withLock mu waitLp NONE              withLock mu waitLp NONE</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* thread 1 acquires lock *)</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>-&gt; waitLp NONE</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>-&gt; (data := SOME v; signal dataAvail)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>-&gt; (data := SOME <span class="dv">1</span>; signal dataAvail)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* {data = ref (SOME 1), ...} *)</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>-&gt; ((); signal dataAvail)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>-&gt; signal dataAvail</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>-&gt; ()</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>   <span class="co">(* thread 1 releases lock *)</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">(* thread 2 acquires lock *)</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">(* NONE is now stale! *)</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>-&gt;                                      waitLp NONE</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">(* selects wrong case in function *)</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>-&gt;                                      (data := SOME v; signal dataAvail)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>-&gt;                                      (data := SOME <span class="dv">2</span>; signal dataAvail)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">(* ==&gt; data = ref (SOME 2) *)</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>-&gt;                                      ((); signal dataAvail)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>-&gt;                                      signal dataAvail</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>-&gt;                                      ()</span></code></pre></div>
<figcaption>
Sample trace, showing that first insert gets dropped
</figcaption>
</figure>
<p>Notice how the stale read allowed two consecutive inserts. What we wanted was for the second insert to wake up, see that the buffer is full, then wait for the <code>dataEmpty</code> condition variable to wake it up. So having the <code>!data</code> outside the lock is not good.</p>
<h1 id="fixing-the-stale-read">Fixing the stale read</h1>
<p>The solution to this is to delay evaluating <code>!data</code> until the body of the <code>waitLp</code> function, which only executes when we have the lock. This ensures that we don’t read a stale value for the content of the buffer.</p>
<figure>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource sml numberLines"><code class="sourceCode sml"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">datatype</span> &#39;a buffer = <span class="co">(* ··· *)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">fun</span> buffer () = <span class="co">(* ··· *)</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">fun</span> insert (BUF {data, mu, dataAvail, dataEmpty}, v) =</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="kw">let</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="co">(* !data is now within waitLp, so it&#39;s never stale. *)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">fun</span> waitLp () =</span>
<span id="cb4-8"><a href="#cb4-8"></a>      <span class="kw">case</span> !data</span>
<span id="cb4-9"><a href="#cb4-9"></a>        <span class="kw">of</span> NONE =&gt; (data := SOME v; signal dataAvail)</span>
<span id="cb4-10"><a href="#cb4-10"></a>         | SOME v =&gt; (wait dataEmpty; waitLp ())</span>
<span id="cb4-11"><a href="#cb4-11"></a>  <span class="kw">in</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    withLock mu waitLp ()</span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="kw">end</span></span>
<span id="cb4-14"><a href="#cb4-14"></a></span>
<span id="cb4-15"><a href="#cb4-15"></a><span class="kw">fun</span> remove (BUF {data, mu, dataAvail, dataEmpty}) =</span>
<span id="cb4-16"><a href="#cb4-16"></a>  <span class="kw">let</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="kw">fun</span> waitLp () =</span>
<span id="cb4-18"><a href="#cb4-18"></a>      <span class="kw">case</span> !data</span>
<span id="cb4-19"><a href="#cb4-19"></a>        <span class="kw">of</span> NONE =&gt; (wait dataAvail; waitLp ())</span>
<span id="cb4-20"><a href="#cb4-20"></a>         | SOME v =&gt; (data := NONE; signal dataEmpty)</span>
<span id="cb4-21"><a href="#cb4-21"></a>  <span class="kw">in</span></span>
<span id="cb4-22"><a href="#cb4-22"></a>    withLock mu waitLp ()</span>
<span id="cb4-23"><a href="#cb4-23"></a>  <span class="kw">end</span></span></code></pre></div>
<figcaption>
Listing 2.3, updated to avoid race
</figcaption>
</figure>
<p>Pretty small bug, and it doesn’t detract from the main point of the listing, which is to show how to use condition variables in a sort of “mutually recursive” style where <code>dataEmpty</code> wakes up <code>insert</code> which signals on <code>dataAvail</code> which wakes up <code>remove</code>.</p>
<p>This also underscores how difficult it really is to ensure correctness in the presence of concurrency! That’s exactly why I’ve been reading about all these language models for concurrency, to better understand how we can leverage our programming language to ensure our programs are correct by construction.</p>
<!-- vim:tw=72
-->
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sml">sml</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#concurrency">concurrency</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

