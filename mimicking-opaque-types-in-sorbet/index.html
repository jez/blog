<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2020-12-12 20:45:47 -0500">
<meta name="description" content="I saw a neat trick the other day for how to combine a handful of Sorbet's existing features to mimic opaque types.">
<title>Mimicking Opaque Types in Sorbet ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Mimicking Opaque Types in Sorbet</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2020-12-12 20:45:47 -0500">December 12, 2020</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">‚äï</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#is-this-really-useful" id="toc-is-this-really-useful">Is this really useful?</a></li>
  <li><a href="#isnt-this-really-verbose" id="toc-isnt-this-really-verbose">Isn‚Äôt this really verbose?</a></li>
  <li><a href="#doesnt-sorbet-already-have-abstract-classes-and-methods-why-prefer-opaque-types" id="toc-doesnt-sorbet-already-have-abstract-classes-and-methods-why-prefer-opaque-types">Doesn‚Äôt Sorbet already have abstract classes and methods? Why prefer opaque types?</a></li>
  </ul>
</nav>

<main>
<blockquote>
<p><strong>Editing note</strong>: This post first appeared in a Stripe-internal email. It was first
cross-posted to this blog December 12, 2022.</p>
</blockquote>
<p>I saw a neat trick the other day in Stripe‚Äôs Ruby codebase. It combines different features
of Sorbet in a cute way to mimic a feature called <a href="https://en.wikipedia.org/wiki/Opaque_data_type">opaque
types</a> present in other typed languages
(<a href="https://wiki.haskell.org/Newtype">Haskell</a>,
<a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">Rust</a>,
<a href="https://flow.org/en/docs/types/opaque-types/">Flow</a>). Opaque types allow making an
abstract type, where the implementation of a type is hidden. In pseudocode, we might
define an abstract type for emails like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Some abstract (opaque) type</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Email</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- All the ways to create that type</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>parse <span class="op">:</span> <span class="dt">String</span> <span class="ot">-&gt;</span> T.nilable(<span class="dt">Email</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- All the ways to use that type</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>extract_user <span class="op">:</span> <span class="dt">Email</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>extract_hostname <span class="op">:</span> <span class="dt">Email</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>This says, ‚ÄúThere‚Äôs some type called <code>Email</code>, but I won‚Äôt tell you the concrete structure
of the type. Instead, I‚Äôm going to provide you with functions for creating that type, and
for using that type.‚Äù Since the concrete structure isn‚Äôt known, the public interface is
the only way to interact with the type.</p>
<p>Here‚Äôs the interesting parts of the implementation. In classic Sorbet fashion, it‚Äôs kind
of verbose üòÖ</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="cf">module</span> <span class="dt">TypeIsOpaque</span>; <span class="fu">extend</span> <span class="cn">T</span><span class="op">:</span><span class="wa">:Helpers</span>; final!; <span class="cf">end</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>private_constant <span class="wa">:TypeIsOpaque</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Underlying</span> <span class="op">=</span> <span class="cn">T</span><span class="at">.type_alias</span> <span class="op">{</span><span class="dt">String</span><span class="op">}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>private_constant <span class="wa">:Underlying</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Type</span> <span class="op">=</span> <span class="cn">T</span><span class="at">.type_alias</span> <span class="op">{</span><span class="cn">T</span><span class="at">.any</span>(<span class="dt">TypeIsOpaque</span>, <span class="dt">Underlying</span>)<span class="op">}</span></span></code></pre></div>
<p>[‚Üí View complete example on sorbet.run](https://sorbet.run/#%23%20typed%3A%20strict%0A%0Amodule%20Email%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%0A%20%20%23%20Make%20this%20a%20%22true%22%20namespace%3A%20only%20way%20to%20access%20the%0A%20%20%23%20private%20constants%20below%20is%20to%20reopen%20this%20module.%0A%20%20final!%0A%0A%20%20module%20TypeIsOpaque%3B%20extend%20T%3A%3AHelpers%3B%20final!%3B%20end%0A%20%20private_constant%20%3ATypeIsOpaque%0A%0A%20%20Underlying%20%3D%20T.type_alias%20%7BString%7D%0A%20%20private_constant%20%3AUnderlying%0A%0A%20%20Type%20%3D%20T.type_alias%20%7BT.any%28TypeIsOpaque%2C%20Underlying%29%7D%0A%0A%0A%20%20%23%20This%20private%20method%20allows%20converting%20freely%20between%20the%0A%20%20%23%20opaque%20type%20and%20the%20underlying%20type%20ONLY%20within%20%60Email%60.%0A%20%20sig%28%3Afinal%29%20%7Bparams%28opaque%3A%20Type%29.returns%28Underlying%29%7D%0A%20%20private_class_method%20def%20self.unwrap_opaque%28opaque%29%0A%20%20%20%20%23%20This%20is%20actually%20safe%2C%20because%20there%20can%20be%20no%20instances%20of%0A%20%20%20%20%23%20TypeIsOpqaue%2C%20so%20it%20can%20only%20be%20of%20type%20Underlying.%0A%20%20%20%20T.unsafe%28opaque%29%0A%20%20end%0A%0A%20%20sig%28%3Afinal%29%20%7Bparams%28raw_input%3A%20String%29.returns%28T.nilable%28Type%29%29%7D%0A%20%20def%20self.parse%28raw_input%29%0A%20%20%20%20%23%20This%20is%20a%20terrible%20way%20to%20actually%20parse%20emails.%0A%20%20%20%20%23%20All%20I‚Äôm%20trying%20to%20show%20is%20the%20type-level%20stuff.%0A%20%20%20%20if%20%2F%5B%5E%40%5D%2B%40%5B%5E%40%5D%2B%2F%20%3D~%20raw_input%0A%20%20%20%20%20%20raw_input%0A%20%20%20%20else%0A%20%20%20%20%20%20nil%0A%20%20%20%20end%0A%20%20end%0A%20%20sig%28%3Afinal%29%20%7Bparams%28email%3A%20Type%29.returns%28String%29%7D%0A%20%20def%20self.extract_user%28email%29%0A%20%20%20%20user%2C%20_hostname%20%3D%20unwrap_opaque%28email%29.split%28%2F%40%2F%29%0A%20%20%20%20%23%20this%20must%20is%20ok%20because%20of%20Email%3A%3AType‚Äôs%20invariant%0A%20%20%20%20T.must%28user%29%0A%20%20end%0A%20%20sig%28%3Afinal%29%20%7Bparams%28email%3A%20Type%29.returns%28String%29%7D%0A%20%20def%20self.extract_hostname%28email%29%0A%20%20%20%20_user%2C%20hostname%20%3D%20unwrap_opaque%28email%29.split%28%2F%40%2F%29%0A%20%20%20%20T.must%28hostname%29%0A%20%20end%0Aend%0A%0Aemail%20%3D%20T.must%28Email.parse%28‚Äôjez%40example.com‚Äô%29%29%0A%23%20not%20great%20error%3A%20would%20like%20to%20show%20%60T.nilable%28Email%3A%3AType%29%60%2C%0A%23%20but%20the%20type%20alias%20expands%20itself%0AT.reveal_type%28email%29%0A%0A%23%20Error%20when%20trying%20to%20use%20an%20email%20as%20a%20String%0A%23%20%28slightly%20weird%20message%2C%20but%20still%20an%20error%29%0Aemail.length%0A%0A%23%20Can%20only%20use%20allowed%20operations%3A%0AEmail.extract_hostname%28email%29%20%23%20ok%0AEmail.unwrap_opaque%28email%29%20%20%20%20%23%20not%20ok%0A%0AEmail.extract_hostname%28‚Äônot%20an%20email‚Äô%29%20%23%20ok%20%28sadly%29%0A%0A%23%20Can%20only%20mention%20the%20opaque%20type%2C%20not%20the%20underlying%20type%0AT.let%28email%2C%20Email%3A%3AType%29%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20ok%0AT.let%28‚Äôjez%40example.com‚Äô%2C%20Email%3A%3AUnderlying%29%20%23%20not%20ok%20%28private%20constant%29%0Acase%20email%0Awhen%20String%20then%20%0Awhen%20Email%3A%3ATypeIsOpaque%20then%20%23%20not%20ok%20%28private%20constant%29%0Aelse%20T.absurd%28email%29%0Aend)</p>
<p>Let‚Äôs break down what‚Äôs going on here:</p>
<ul>
<li><p><code>TypeIsOpaque</code> is a private, final module. A <a href="https://sorbet.org/docs/final">final
module</a> can never be included in a class, so this type is
<strong>uninhabited</strong>: there are no values of type <code>TypeIsOpaque</code>. Being private powers the
opacity, as we‚Äôll see. The name is crafted to give people a semblance of a hint as to
what‚Äôs going on if they see it in error messages.</p></li>
<li><p><code>Underlying</code> is a (transparent) type alias to <code>String</code>. It says that our abstract email
type is really a <code>String</code> at runtime, even if it isn‚Äôt a <code>String</code> for the purposes of
type checking.</p></li>
<li><p><code>Type</code> (fully qualified: <code>Email::Type</code>) is the public interface to our abstract type.
It‚Äôs a union of the two (private) types above. Since they‚Äôre both private, users can
only mention <code>Email::Type</code> and not <code>Email::Underlying</code> nor <code>Email::TypeIsOpaque</code>.</p></li>
</ul>
<p>That‚Äôs it! We have an abstract type that‚Äôs always a <code>String</code> at runtime but (mostly) can‚Äôt
be used like a <code>String</code> statically. Let‚Äôs see it in action:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>email <span class="op">=</span> <span class="cn">T</span><span class="at">.must</span>(<span class="dt">Email</span><span class="at">.parse</span>(<span class="vs">&#39;jez@example.com&#39;</span>))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># statically, it&#39;s an `Email::Type` (even though the error expands the type alias)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="cn">T</span><span class="at">.reveal_type</span>(email) <span class="co"># Revealed type: `T.any(Email::TypeIsOpaque, String)`</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># at runtime, it&#39;s a `String` (not some wrapper class)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="cn">T</span><span class="at">.unsafe</span>(email)<span class="at">.class</span> <span class="co"># =&gt; String</span></span></code></pre></div>
<p>Note that the type is so opaque, we can‚Äôt even <em>ask for the runtime class</em> without using
<code>T.unsafe</code>!</p>
<p>Some more things that can and can‚Äôt be done:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We CAN&#39;T call `String` methods:</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>email<span class="at">.length</span> <span class="co"># error: Method `length` does not exist</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We CAN call the public interface methods with a parsed email:</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Email</span><span class="at">.extract_user</span>(email)     <span class="co"># ok</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Email</span><span class="at">.extract_hostname</span>(email) <span class="co"># ok</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># [bug] We CAN call the public interface methods with raw strings:</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Email</span><span class="at">.extract_user</span>(<span class="vs">&#39;not an email&#39;</span>) <span class="co"># ok (sadly)</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co"># We CAN&#39;T (safely) unwrap the union to the underlying type:</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> email</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">when</span> <span class="dt">Email</span><span class="op">:</span><span class="wa">:TypeIsOpaque</span> <span class="cf">then</span> <span class="co"># error: Non-private reference to private constant</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="cf">when</span> <span class="dt">String</span> <span class="cf">then</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cn">T</span><span class="at">.absurd</span>(email)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="co"># We CAN ONLY mention `Email::Type` in signatures:</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>sig <span class="op">{</span>returns(<span class="dt">Email</span><span class="op">::</span><span class="dt">Type</span>)<span class="op">}</span>         <span class="co"># ok</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>sig <span class="op">{</span>returns(<span class="dt">Email</span><span class="op">::</span><span class="dt">Underlying</span>)<span class="op">}</span>   <span class="co"># error: Non-private reference to private const</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>sig <span class="op">{</span>returns(<span class="dt">Email</span><span class="op">::</span><span class="dt">TypeIsOpaque</span>)<span class="op">}</span> <span class="co"># error: Non-private reference to private const</span></span></code></pre></div>
<p>Users could of course still call <code>T.unsafe</code> to use <code>Email::Type</code> and <code>String</code>
interchangeably, but that‚Äôs something to discourage in code review (and is a perennial
problem in Sorbet anyways, not unique to opaque types).</p>
<p>Again, you should probably take a look at the complete, interactive example; it‚Äôll teach a
lot more:</p>
<p>[‚Üí View complete example on sorbet.run](https://sorbet.run/#%23%20typed%3A%20strict%0A%0Amodule%20Email%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%0A%20%20%23%20Make%20this%20a%20%22true%22%20namespace%3A%20only%20way%20to%20access%20the%0A%20%20%23%20private%20constants%20below%20is%20to%20reopen%20this%20module.%0A%20%20final!%0A%0A%20%20module%20TypeIsOpaque%3B%20extend%20T%3A%3AHelpers%3B%20final!%3B%20end%0A%20%20private_constant%20%3ATypeIsOpaque%0A%0A%20%20Underlying%20%3D%20T.type_alias%20%7BString%7D%0A%20%20private_constant%20%3AUnderlying%0A%0A%20%20Type%20%3D%20T.type_alias%20%7BT.any%28TypeIsOpaque%2C%20Underlying%29%7D%0A%0A%0A%20%20%23%20This%20private%20method%20allows%20converting%20freely%20between%20the%0A%20%20%23%20opaque%20type%20and%20the%20underlying%20type%20ONLY%20within%20%60Email%60.%0A%20%20sig%28%3Afinal%29%20%7Bparams%28opaque%3A%20Type%29.returns%28Underlying%29%7D%0A%20%20private_class_method%20def%20self.unwrap_opaque%28opaque%29%0A%20%20%20%20%23%20This%20is%20actually%20safe%2C%20because%20there%20can%20be%20no%20instances%20of%0A%20%20%20%20%23%20TypeIsOpqaue%2C%20so%20it%20can%20only%20be%20of%20type%20Underlying.%0A%20%20%20%20T.unsafe%28opaque%29%0A%20%20end%0A%0A%20%20sig%28%3Afinal%29%20%7Bparams%28raw_input%3A%20String%29.returns%28T.nilable%28Type%29%29%7D%0A%20%20def%20self.parse%28raw_input%29%0A%20%20%20%20%23%20This%20is%20a%20terrible%20way%20to%20actually%20parse%20emails.%0A%20%20%20%20%23%20All%20I‚Äôm%20trying%20to%20show%20is%20the%20type-level%20stuff.%0A%20%20%20%20if%20%2F%5B%5E%40%5D%2B%40%5B%5E%40%5D%2B%2F%20%3D~%20raw_input%0A%20%20%20%20%20%20raw_input%0A%20%20%20%20else%0A%20%20%20%20%20%20nil%0A%20%20%20%20end%0A%20%20end%0A%20%20sig%28%3Afinal%29%20%7Bparams%28email%3A%20Type%29.returns%28String%29%7D%0A%20%20def%20self.extract_user%28email%29%0A%20%20%20%20user%2C%20_hostname%20%3D%20unwrap_opaque%28email%29.split%28%2F%40%2F%29%0A%20%20%20%20%23%20this%20must%20is%20ok%20because%20of%20Email%3A%3AType‚Äôs%20invariant%0A%20%20%20%20T.must%28user%29%0A%20%20end%0A%20%20sig%28%3Afinal%29%20%7Bparams%28email%3A%20Type%29.returns%28String%29%7D%0A%20%20def%20self.extract_hostname%28email%29%0A%20%20%20%20_user%2C%20hostname%20%3D%20unwrap_opaque%28email%29.split%28%2F%40%2F%29%0A%20%20%20%20T.must%28hostname%29%0A%20%20end%0Aend%0A%0Aemail%20%3D%20T.must%28Email.parse%28‚Äôjez%40example.com‚Äô%29%29%0A%23%20not%20great%20error%3A%20would%20like%20to%20show%20%60T.nilable%28Email%3A%3AType%29%60%2C%0A%23%20but%20the%20type%20alias%20expands%20itself%0AT.reveal_type%28email%29%0A%0A%23%20Error%20when%20trying%20to%20use%20an%20email%20as%20a%20String%0A%23%20%28slightly%20weird%20message%2C%20but%20still%20an%20error%29%0Aemail.length%0A%0A%23%20Can%20only%20use%20allowed%20operations%3A%0AEmail.extract_hostname%28email%29%20%23%20ok%0AEmail.unwrap_opaque%28email%29%20%20%20%20%23%20not%20ok%0A%0AEmail.extract_hostname%28‚Äônot%20an%20email‚Äô%29%20%23%20ok%20%28sadly%29%0A%0A%23%20Can%20only%20mention%20the%20opaque%20type%2C%20not%20the%20underlying%20type%0AT.let%28email%2C%20Email%3A%3AType%29%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20ok%0AT.let%28‚Äôjez%40example.com‚Äô%2C%20Email%3A%3AUnderlying%29%20%23%20not%20ok%20%28private%20constant%29%0Acase%20email%0Awhen%20String%20then%20%0Awhen%20Email%3A%3ATypeIsOpaque%20then%20%23%20not%20ok%20%28private%20constant%29%0Aelse%20T.absurd%28email%29%0Aend)</p>
<p>But now, I‚Äôd like to answer some common questions I imagine people will have.</p>
<h3 id="is-this-really-useful">Is this really useful?</h3>
<p>Maybe the email example isn‚Äôt so motivating, but hopefully the idea of ‚Äúzero overhead
abstract types‚Äù are. Some more examples to spark your imagination:</p>
<ul>
<li><p>Database foreign key IDs. Make one opaque type for each kind of database object. Then
you can say ‚Äúthis method accepts only user IDs, or only charge IDs.‚Äù The type system
guarantees that different object types‚Äô IDs aren‚Äôt interchangeable. It could even
guarantee that if you have an ID, it represents an actual record in the database (or at
least, a record that existed in the database). (Stripe‚Äôs in-house ORM actually does this
for certain tokens.)</p></li>
<li><p>HTML-sanitized strings. Draw a type-level distinction between ‚Äúa String that came from
the user and might have unescaped-HTML characters‚Äù and ‚Äúa String that has had all it‚Äôs
characters escaped.‚Äù Avoid defensively HTML-escaping because the type system tracks it.</p></li>
</ul>
<h3 id="isnt-this-really-verbose">Isn‚Äôt this really verbose?</h3>
<p>Yep! But it‚Äôs easy to tack on concise syntax later. We‚Äôve punted around some ideas for
this over the years, but there are still a few unanswered questions which is the main
reason why we haven‚Äôt built something yet:</p>
<ul>
<li>Should opaque types be file-private (like sealed classes), module-private (like
<code>private</code> and <code>private_constant</code>), or package private?</li>
<li>Should converting between the opaque and underlying type be explicit or implicit?</li>
<li>Should the implementation be built on top of existing features (like the workaround
above, but with syntactic sugar), or should Sorbet have a separate concept of ‚Äúopaque
type alias‚Äù?</li>
</ul>
<p>None of these are insurmountable, but we prefer to let real-world usage and needs guide
the features we build (‚ÄúWould this have prevented an incident?‚Äù vs ‚ÄúWouldn‚Äôt this be
nice?‚Äù)</p>
<p>Also, building custom syntax for this into Sorbet would give us a chance to fix the bug
mentioned above, where the opaque type isn‚Äôt quite opaque enough.</p>
<h3 id="doesnt-sorbet-already-have-abstract-classes-and-methods-why-prefer-opaque-types">Doesn‚Äôt Sorbet already have abstract classes and methods? Why prefer opaque types?</h3>
<p>A good point! For some kinds of abstract types, <a href="https://sorbet.org/docs/abstract">abstract classes or
interfaces</a> work totally fine.</p>
<p>But interfaces need classes to implement them. If I invent some application-specific
interface, I probably shouldn‚Äôt monkey patch it into a standard library class like
<code>String</code>. The alternative would be to make some sort of wrapper class which implements the
interface:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">StringWrapper</span> <span class="op">&lt;</span> <span class="cn">T</span><span class="op">:</span><span class="wa">:Struct</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (1) Wrap a String</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  const <span class="wa">:underlying</span>, <span class="dt">String</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (2) Implement the interface</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">include</span> <span class="dt">Email</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ... override to implement the methods ...</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>But that means twice as many allocations (one allocation for the <code>StringWrapper</code>, one for
the <code>String</code>) and worse memory locality (the <code>String</code> isn‚Äôt always in memory near the
<code>StringWrapper</code>). For frequently-allocated objects like database IDs, that can make
already slow operations even slower.</p>
<p><br />
</p>
<p>This trick isn‚Äôt a complete substitute for opaque types, and I still would love to
implement them some day. But I love discovering clever tricks like this that people use to
make Sorbet do what they wish it could do.</p>
<p><em>Thanks to David Judd for implementing this trick at Stripe, so that I could stumble on it.</em></p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#types">types</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

