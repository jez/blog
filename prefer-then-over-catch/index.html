
<!DOCTYPE html>

<head>


<meta charset="utf-8">
<meta http-equiv="cleartype" content="on">

<title>Prefer .then() over .catch() - Bits, Bytes, and Words</title>
<meta name="author" content="Jake Zimmerman">




<meta name="description" content="When designing asynchronous APIs that could error in Flow, prefer using `.then` for both successful and failure cases. Flow exposes a relatively &hellip;">

<meta name="keywords" content="flow fragment javascript ">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Twitter Cards -->


<!-- Open Graph -->
<meta property="og:local" content="en_US">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.jez.io/prefer-then-over-catch">
<meta property="og:title" content="Prefer .then() over .catch()">
<meta property="og:description" content="When designing asynchronous APIs that could error in Flow, prefer using `.then` for both successful and failure cases. Flow exposes a relatively &hellip;">
<meta property="og:image" content="">
<meta property="og:site_name" content="Bits, Bytes, and Words">

<link rel="canonical" href="https://blog.jez.io/prefer-then-over-catch">
<link href="/favicon.png" rel="icon">
<link href="/fonts/concourse.css" rel="stylesheet">
<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
<link href="/atom.xml" rel="alternate" title="Bits, Bytes, and Words" type="application/atom+xml">




</head>

<body id="post" class="">

<nav class="Navigation">
  <ul class="Tags">
    
      <li class="Tag">
        
          <a href="/">Home</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="/categories/">Categories</a>
        
      </li>
    
      <li class="Tag">
        
          <a href="https://jez.io">About</a>
        
      </li>
    
  </ul>
</nav>





<div class="EntryHeader">
  <h1 class="EntryHeader-title">Prefer .then() over .catch()</h1>
  <h2 class="EntryHeader-subtitle">May 31, 2018</h2>

  <ul class="Tags">
    
      <li class="Tag">
        <a href="/categories/#fragment" title="This post is shorter and less thought-out than other posts." class="tag">fragment</a>
      </li>
    
  </ul>
</div>



<div id="main" role="main">
  <article class="Post-content">
    <p>When designing asynchronous APIs that could error in Flow, prefer using
<code>.then</code> for both successful and failure cases. Flow exposes a relatively
unsafe library definition for the <code>.catch</code> method, so it&rsquo;s best to avoid
it if you can.</p>

<!-- more -->


<h2>Problem</h2>

<p>What does this look like in practice? Say you&rsquo;re thinking about writing
code that looks similar to this:</p>

<figure class='code'><figcaption><span>Bad code; don&#8217;t do this</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// "Success" and "failure" types (definitions omitted)</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">OkResult</span><span class="p">,</span> <span class="nx">ErrResult</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/types'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">OkResult</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// call resolve(...) when it worked, but</span>
</span><span class='line'>    <span class="c1">// cal reject(...) when it failed.</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doSomething</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...)</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...)</span></span></code></pre></td></tr></table></div></figure>


<p>This is okay code, but not great. Why? Because Flow won&rsquo;t prevent us
from calling <code>reject(...)</code> with something that&rsquo;s <strong>not</strong> of type
<code>ErrResult</code>, and it won&rsquo;t warn us when we try to use <code>err</code> incorrectly.
Concretely, if we had this type definition:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">type</span> <span class="nx">ErrResult</span> <span class="o">=</span> <span class="nx">string</span><span class="p">;</span></span></code></pre></td></tr></table></div></figure>


<p>Flow wouldn&rsquo;t prevent us from doing this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// number, not a string!</span>
</span><span class='line'><span class="nx">reject</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span></span></code></pre></td></tr></table></div></figure>


<p>nor from doing this:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// boolean, not a string!</span>
</span><span class='line'><span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">:</span> <span class="kr">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">...);</span></span></code></pre></td></tr></table></div></figure>


<h2>Solution</h2>

<p>As mentioned, we can work around this by only using <code>resolve</code> and
<code>.then</code>. For example, we can replace our code above with this:</p>

<figure class='code'><figcaption><span>Better code than before</span></figcaption><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Helper function for exhaustiveness.</span>
</span><span class='line'><span class="c1">// See here: https://blog.jez.io/flow-exhaustiveness/</span>
</span><span class='line'><span class="kr">import</span> <span class="p">{</span><span class="nx">absurd</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/absurd'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">OkResult</span><span class="p">,</span> <span class="nx">ErrResult</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">'src/types'</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Use a union type to mean "success OR failure"</span>
</span><span class='line'><span class="nx">type</span> <span class="nx">Result</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">{</span><span class="o">|</span><span class="na">tag</span><span class="p">:</span> <span class="s1">'ok'</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">OkResult</span><span class="o">|</span><span class="p">}</span>
</span><span class='line'>  <span class="o">|</span> <span class="p">{</span><span class="o">|</span><span class="na">tag</span><span class="p">:</span> <span class="s1">'err'</span><span class="p">,</span> <span class="na">val</span><span class="p">:</span> <span class="nx">ErrResult</span><span class="o">|</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//     Use our new union type ──┐</span>
</span><span class='line'><span class="kr">const</span> <span class="nx">doSomething</span> <span class="o">=</span> <span class="p">():</span> <span class="nx">Promise</span><span class="o">&lt;</span><span class="nx">Result</span><span class="o">&gt;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="k">new</span> <span class="nx">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// call resolve({tag: 'ok',  val: ...}) when it worked, and</span>
</span><span class='line'>    <span class="c1">// call resolve({tag: 'err', val: ...}) when it failed</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">doSomething</span>
</span><span class='line'>  <span class="c1">// Use a switch statement in the result:</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">tag</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'ok'</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="k">case</span> <span class="s1">'err'</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>      <span class="nl">default</span><span class="p">:</span>
</span><span class='line'>        <span class="c1">// Guarantees we covered all cases.</span>
</span><span class='line'>        <span class="nx">absurd</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">})</span></span></code></pre></td></tr></table></div></figure>


<p>There&rsquo;s a lot of benefits in this newer code:</p>

<ul>
<li><p>Using <code>resolve</code> is much safer than <code>reject</code>. Flow will always warn us
if we call <code>resolve</code> with an improperly-typed input.</p></li>
<li><p>Using <code>.then</code> is the same. Flow will warn for improper usage, <strong>and</strong>
even correctly infer the type of <code>res</code> in our handler.</p></li>
<li><p>We got exhaustiveness as a bonus. We now handle all errors, whereas
before it was easy to forget to include a <code>.catch</code>.</p></li>
</ul>


<h2>Caveats</h2>

<p>Of course, there are some times when the you&rsquo;re interfacing with code
not under your control that exposes critical functionality over
<code>.catch</code>. In these cases, it&rsquo;s not an option to just &ldquo;not use <code>.catch</code>&rdquo;.
Instead, you have two options.</p>

<p>If you trust that the library you&rsquo;re using will never &ldquo;misbehave&rdquo;,
you can ascribe a narrow type to the <code>.catch</code> callback function:</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// If I know that throwNumber will always call `reject` with a</span>
</span><span class='line'><span class="c1">// number, I can stop the loose types from propagating further</span>
</span><span class='line'><span class="c1">// with an explicit annotation:</span>
</span><span class='line'><span class="nx">throwNumber</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Didn't throw!"</span><span class="p">))</span>
</span><span class='line'>  <span class="c1">//         ┌── explicit annotation</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">n</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">handleWhenRejected</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span></span></code></pre></td></tr></table></div></figure>


<p>If you aren&rsquo;t comfortable putting this much trust in the API, you
should instead ascribe <code>mixed</code> to the result of the callback.</p>

<figure class='code'><div class="highlight"><table><tr></pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">throwNumber</span>
</span><span class='line'>  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Didn't throw!"</span><span class="p">))</span>
</span><span class='line'>  <span class="c1">//         ┌── defensive annotation</span>
</span><span class='line'>  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">n</span><span class="p">:</span> <span class="nx">mixed</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="s1">'number'</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nx">handleWhenRejected</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Reports misbehavior to an imaginary observability service</span>
</span><span class='line'>      <span class="nx">tracker</span><span class="p">.</span><span class="nx">increment</span><span class="p">(</span><span class="s1">'throwNumber.unexpected_input'</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span></span></code></pre></td></tr></table></div></figure>




<!-- vim:tw=72
-->


    <footer class="entry-meta">
      <span class="entry-tags">
        <ul class="Tags">
          
            <li class="Tag">
              <a href="/categories/#flow" title="Pages tagged flow">flow</a>
            </li>
          
            <li class="Tag">
              <a href="/categories/#fragment" title="Pages tagged fragment">fragment</a>
            </li>
          
            <li class="Tag">
              <a href="/categories/#javascript" title="Pages tagged javascript">javascript</a>
            </li>
          
        </ul>
      </span>
      <span class="entry-date date published updated"><time datetime="2018-05-31T18:58:52-04:00">May 31, 2018</time></span>
      
    </footer>
  </div>
  
  <div class="read-more">
    
      <div class="read-more-header">
        <a href="/union-types-flow-reason/" class="Button">Read More</a>
      </div><!-- /.read-more-header -->
      <div class="read-more-content">
        <h3><a href="/union-types-flow-reason/" title="Union Types in Flow & Reason">Union Types in Flow & Reason</a></h3>
      <p>Union types are powerful yet often overlooked. At work, I&#8217;ve been using Flow which thankfully supports union types. But as I&#8217;ve refactored more of our code to use union types, I&#8217;ve noticed that our bundle size has been steadily increasing!
 <a href="/union-types-flow-reason/"> Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="/flow-exhaustiveness/" title="Case Exhaustiveness in Flow">Case Exhaustiveness in Flow</a></h4>
            <span>Published on April 15, 2018</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="/lens-composition/" title="Lenses & Composition">Lenses & Composition</a></h4>
            <span>Published on February 06, 2018</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
  </div><!-- /.read-more -->


</div>

<div class="footer-wrapper">
  Blog source on <a href="https://github.com/jez/blog">GitHub</a>.

</div>

</body>
</html>
