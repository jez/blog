<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2019-06-16 12:25:06 -0400">
<meta name="description" content="I implemented a debugger for Bash in six lines of Bash.">
<title>A Debugger for Bash in Six Lines of Bash – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  




</head>
<body>
  




  <header>
    <h1 class="title">A Debugger for Bash in Six Lines of Bash</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2019-06-16 12:25:06 -0400">June 16, 2019</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#stopping-on-failures">Stopping on failures</a></li>
  <li><a href="#future-work">Future work</a></li>
  </ul>
</nav>

<main>
<p>I implemented a “debugger” for Bash in six lines of Bash. It kind of behaves like JavaScript’s <code>debugger</code> keyword. Here’s how it works:</p>
<!-- more -->
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">debugger()</span> <span class="kw">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span> <span class="st">&quot;Stopped in REPL. Press ^D to resume, or ^C to abort.&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">local</span> <span class="va">line</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">while</span> <span class="bu">read</span> -r -p <span class="st">&quot;&gt; &quot;</span> <span class="va">line</span>; <span class="kw">do</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">eval</span> <span class="st">&quot;</span><span class="va">$line</span><span class="st">&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">done</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">echo</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div>
<p>And there it is. Add this to a script, insert a call to <code>debugger</code> somewhere, and run the script. It’ll pause right execution right there. Once paused, we can do things like:</p>
<ul>
<li>print the contents of variables with <code>echo</code></li>
<li>run commands that are on our <code>PATH</code> (e.g., <code>pwd</code>, <code>ls</code>, …)</li>
<li>call functions defined in the script</li>
</ul>
<p>… and pretty much everything that we could have done if we were editing the script directly. Here’s a short session demonstrating how it can be used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">debugger()</span> <span class="kw">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ... implemented above ...</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="va">foo=</span>1</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ex">debugger</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;foo: </span><span class="va">$foo</span><span class="st">&quot;</span></span></code></pre></div>
<pre><code>❯ foo.sh
Stopped in REPL. Press ^D to resume, or ^C to abort.
&gt; pwd
/Users/jez
&gt; echo $foo
1
&gt; foo=42
&gt; ^D
foo: 42</code></pre>
<h1 id="stopping-on-failures">Stopping on failures</h1>
<p>I find that most of the time this is useful when a script is failing for some reason. Rather than put a <code>debugger</code> call right before the failing command, I can just add this at the top of the file:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">trap</span> <span class="st">&#39;debugger&#39;</span> ERR</span></code></pre></div>
<p>When any command has a non-zero exit code, Bash will run <code>debugger</code> and pause the program.</p>
<p>I’ve been keeping this function and <code>trap</code> call commented out at the top of my scripts and uncommenting them when needed (It uses <code>eval</code>, which is not the best from a security perspective, which is why it’s commented by default).</p>
<h1 id="future-work">Future work</h1>
<p>Of course, I said “debugger” in quotes earlier because it’s not <strong>really</strong> a debugger:</p>
<ul>
<li><p>Using it requires editing the script we want to debug to include these lines, and then calling <code>debugger</code> somewhere. It doesn’t launch an inferior process and control it, like <code>gdb</code> or <code>lldb</code> would.</p></li>
<li><p>There’s no <code>break</code> command to edit breakpoints while stopped. All breakpoints must have been written into the program up front.</p></li>
<li><p>There’s also no <code>step</code> or <code>next</code> commands for stepping into or over the next function or command.</p></li>
<li><p>When it stops, it doesn’t show the text content of the last line that executed, or even the line number.</p></li>
</ul>
<p>But I have some thoughts on how to implement these, too… Bash’s <code>trap</code> builtin has a way to trap <code>DEBUG</code>, which runs after every command. I think I could make clever use of <code>trap</code>s to implementat least one of <code>step</code> or <code>next</code>, and definitely something that says “stopped on line X” and maybe even use that to print the source text of that line. Implementing <code>break</code> seems to be the hardest—I don’t have any ideas for that one right now.</p>
<p>I’m releasing this code into the public domain. If you want to change it to implement any of these features, I’d be more than interested to hear about it!</p>
<!-- vim:tw=72
-->
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#bash">bash</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

