<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: reasonml | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/reasonml/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2018-04-20T01:16:22-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript, Union Types, and Optimizing Compilers]]></title>
    <link href="https://blog.jez.io/js-union-types-opt/"/>
    <updated>2018-04-19T01:43:26-04:00</updated>
    <id>https://blog.jez.io/js-union-types-opt</id>
    <content type="html"><![CDATA[<p>Union types are a powerful tool and often overlooked. At work we use
Flow, which thankfully supports union types. But as I refactor certain
code paths to use more of them I&rsquo;ve noticed that our bundle size has
been steadily increasing!</p>

<p>In this post, we&rsquo;re going to explore why that&rsquo;s the case. We&rsquo;ll start
with a problem, flesh it out some more to motivate why we definitely
want union types for this, and then examine the resulting cost of
introducing union types. In the end, we&rsquo;ll compare Flow to other
compile-to-JS languages. I&rsquo;m especially excited about <a href="https://reasonml.github.io/">Reason</a>, so
that&rsquo;s the one we&rsquo;ll spend the most time talking about.</p>

<h2>Setup: Union Types in a React Component</h2>

<p>Let&rsquo;s consider we&rsquo;re writing a simple React two-factor auth modal.
We&rsquo;ll be using Flow, but you can pretend it&rsquo;s TypeScript if you want.
The mockup we were given looks like this:</p>

<p><a href="/images/2fa-mockup.jpeg"><img src="/images/2fa-mockup.jpeg" alt="A sample mockup for a two-factor authenticaion modal" /></a></p>

<p>Some things we notice from this mockup:</p>

<ul>
<li>There&rsquo;s a loading state while we send the text message.</li>
<li>We&rsquo;ll show an input to get the code after it&rsquo;s been sent.</li>
<li>There&rsquo;s no failure screen (it hasn&rsquo;t been drawn up yet).</li>
</ul>


<p>We&rsquo;ll need some way for our component to know which of the three screens
is visible. Let&rsquo;s use a <a href="https://flow.org/en/docs/types/unions/">union type</a> in Flow:</p>

<pre><code class="js">type Screen =
  | 'LoadingScreen'
  | 'CodeEntryScreen'
  | 'SuccessScreen';
</code></pre>

<p>Union types are a perfect fit! ðŸŽ‰  Union types document intent and can
help guard against mistakes. Fellow developers and your compiler can
know &ldquo;these are all the cases.&rdquo; In particular, Flow can warn you when
you&rsquo;ve <a href="/flow-exhaustiveness/">forotten a case</a>.</p>

<p>Our initial implementation is working great. After sharing it with the
team, someone suggests adding a &ldquo;cancel&rdquo; button in the top corner. It
doesn&rsquo;t make sense to cancel when the flow has already succeeded, so
we&rsquo;ll exclude it from the last screen (i.e., <code>'SuccessScreen'</code>):</p>

<p><a href="/images/2fa-close-btn.jpeg"><img src="/images/2fa-close-btn.jpeg" alt="Adding a close button to our modal" /></a></p>

<p>No problem: let&rsquo;s write a function called <code>needsCancelButton</code> to
determine if a we need to put a cancel button in the header for a
particular screen:</p>

<pre><code class="js">const needsCancelButton = (screen: Screen): boolean =&gt; {
  // Recall: 'SuccessScreen' final, so it doesn't
  // make sense to have a cancel button
  return screen !== 'SuccessScreen';
};
</code></pre>

<p>Short and sweet. ðŸ‘Œ Everything seems to be working great, until&hellip;</p>

<h2><code>switch</code>: Optimizing for Exhaustiveness</h2>

<p>The next day, we get some updated mocks from the design team. This time,
they&rsquo;ve also drawn up a &ldquo;failure&rdquo; screen for when the customer has
entered the wrong code too many times:</p>

<p><a href="/images/2fa-failure-screen.jpeg"><img src="/images/2fa-failure-screen.jpeg" alt="The failure screen for our modal" /></a></p>

<p>We can handle this&mdash;we&rsquo;ll just add a case to our <code>Screen</code> type:</p>

<pre><code class="js">type Screen =
  | 'LoadingScreen'
  | 'CodeEntryScreen'
  | 'SuccessScreen'
  // New case to handle when an incorrect code was added:
  | 'FailureScreen';
</code></pre>

<p>But now there&rsquo;s a bug in our <code>needsCancelButton</code> function. ðŸ˜§
According to the current implementation, there&rsquo;s a cancel button on the
<code>'FailureScreen'</code> too! It would have been really nice if Flow told us
right away that our <code>needsCancelButton</code> function was out of date:</p>

<blockquote><p>Hey, you forgot to add a case to <code>needsCancelButton</code> for the new
screen you added. <em>ðŸ™‚</em></p>

<p>&mdash; your friendly, neighborhood type checker</p></blockquote>

<p>Let&rsquo;s go back and rewrite <code>needsCancelButton</code> so that it <strong>will</strong> tell
us this when adding new cases. We&rsquo;ll use a <code>switch</code> statement with
<a href="/flow-exhaustiveness/">something special in the <code>default</code> case</a>:</p>

<pre><code class="js">// I named this function 'absurd' in my previous blog post,
// but they both do the same thing.
// See: https://blog.jez.io/flow-exhaustivness/
const impossible = &lt;T&gt;(x: empty): T =&gt; {
  throw new Error('This case is impossible.');
}

const needsCancelButton = (screen: Screen): boolean =&gt; {
  switch (screen) {
    case 'LoadingScreen':
      return true;
    case 'CodeEntryScreen':
      return true;
    case 'SuccessScreen':
      return false;
    // Uncomment to fix the Flow error
    // case 'FailureScreen':
    //   return false;
    default:
      // [flow]: Error: Cannot call `impossible` with `screen` bound to `x` because string literal `FailureScreen` [1] is incompatible with empty [2].
      return impossible(screen);
  }
}
</code></pre>

<p><a href="https://flow.org/try/#0PTAEAEDMBsHsHcBQiAuBPADgU1AZQMYBOWWAdqALyKigA+oA5ADKwCGAJgJakDmBxZBtTqMAwrHZYAoqRSE0-EqSE16DXAFd8+LAGddiwcLUAxVp2gbih5QG5k+WKV0pQnALYZY+zgCNoOBSgADwAKgB8ABQAHgBcoFie6ACU8aGU4aAA3sIoABaECKCkWPCgUoSFhJEMoXmcuqD4rLo4DW6e3rp+AQB0DMn2AL4OTi7FJOy6oqykOtAAQhooKE6UoJG6RErxNqmgvrCwAbMZ2cK68Jwo+HkbWwKkyec0NM2tjCwc3HzbgrHCV6gYgoKzkOQaLD2IHvHAMcSSGRyBR-ZQAoE0EFg0AQqGApotOGabR6AyohjojFYwjkSCsaCtaGvECgACqc1g7ncZFcq1AkE40RxeRwJjgZSwlVghHxLNhjDMFisWBsFNlYGBWFBNP59MZ+MkdI00BQlKB1PIHi8Pn8WE2qMGwhGQyAA"><strong>(Play with it on Try Flow â†’)</strong></a></p>

<p>Now Flow is smart enough to give us an error! Making our code safer, one
<code>switch</code> statement at a time. ðŸ˜… Union types in Flow are a powerful way
to use types to guarantee correctness. But to get the most out of union
types, <strong>only<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> ever access them</strong> through a <code>switch</code> statement.</p>

<h2>Correctness, but at what cost?</h2>

<p>You might not have noticed, but we paid a subtle cost in rewriting
our <code>needsCancelButton</code> function. Let&rsquo;s compare our two functions:</p>

<pre><code class="js">
// ----- before: 62 bytes (minified) -----

const needsCancelButton = (screen) =&gt; {
  return screen !== 'SuccessScreen';
};

// ----- after: 240 bytes (minified) -----

const impossible = (x) =&gt; {
  throw new Error('This case is impossible.');
};

const needsCancelButton = (screen) =&gt; {
  switch (screen) {
    case 'LoadingScreen':
      return true;
    case 'CodeEntryScreen':
      return true;
    case 'SuccessScreen':
      return false;
    default:
      return impossible(screen);
  }
};
</code></pre>

<p>With just an <code>if</code> statement, our function was quite small: 62 bytes
minified. But when we refactored to use a <code>switch</code> statement, it size
shot up to 240 bytes! That&rsquo;s a 4x increase, just to get exhaustiveness.
Admittedly, <code>needsCancelButton</code> is a bit of a pathological case. But in
general: as we make our code bases <strong>more safe</strong> using Flow&rsquo;s union
types of string literals, our <strong>bundle size bloats</strong>!</p>

<h2>Types and Optimizing Compilers</h2>

<p>One of the many overlooked promises of types is the claim that by
writing our code with <strong>higher-level abstractions</strong>, we give more
information to the compiler. The compiler can then generate code that
captures our original intent, but as efficiently as possible.</p>

<p>Flow is decidedly <strong>not</strong> a compiler: it&rsquo;s only a type checker. To run
JavaScript annotated with Flow types, we first strip the types (with
something like Babel). All information about the types is lost
when we run the code.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> What can we achieve if we were to
<strong>keep the types around</strong> all the way through compilation?</p>

<p><a href="https://reasonml.github.io/">Reason</a> (i.e., ReasonML) is an exciting effort to bring all the
benefits of the OCaml tool chain to the masses. In particular, Reason
works using OCaml&rsquo;s very mature optimizing compiler alongside
BuckleScript (which turns OCaml to JavaScript) to emit great code.</p>

<p>To see what I mean, let&rsquo;s re-implement our <code>Screen</code> type and
<code>needsCancelButton</code> function, this time in Reason:</p>

<pre><code class="js">type screen =
  | LoadingScreen
  | CodeEntryScreen
  | SuccessScreen;

let needsCancelButton = (screen: screen): bool =&gt; {
  switch (screen) {
  | LoadingScreen =&gt; true;
  | CodeEntryScreen =&gt; true;
  | SuccessScreen =&gt; false;
  }
};
</code></pre>

<p>Looks pretty close to JavaScript with Flow types, doesn&rsquo;t it? The
biggest difference is that we the <code>case</code> keyword was replaced with the
<code>|</code> character. (This directly mirrors the definition of the <code>screen</code>
type&mdash;it&rsquo;s a nice reminder<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup> to always use <code>switch</code>
statements when using union types). Another difference: Reason does
exhaustiveness checking out of the box!</p>

<p>What code does Reason output (via BuckleScript) for our function?</p>

<pre><code class="js">// Generated by BUCKLESCRIPT VERSION 3.0.1, PLEASE EDIT WITH CARE
'use strict';

function needsCancelButton(status) {
  if (status !== 0) {
    return false;
  } else {
    return true;
  }
}
</code></pre>

<p><a href="https://reasonml.github.io/en/try.html?rrjsx=true&amp;reason=C4TwDgpgBAzgxgJwhAdlAvAKClAPlAGQHsBDAEwEsUBzAZUWRWzygGEiyIBRFYBEeklTN8tAK5w4EGDEGMA3JkwAbCMCgpkZGKxIopygEJjgwImnRQAFPCEoAXLAaoAlI4BGRIsowA+KADezDAA7hTAcAAW1raMLoEihKSUNHKoflB8YhCKOPjsnDx8As4W-lk5ieKS0rKlGQBmJMowlTgAvpjtikA"><strong>(Play with it on Try Reason â†’)</strong></a></p>

<p>Not bad! Telling Reason that our function was exhaustive let it optimize
the entire <code>switch</code> statement back down to a single <code>if</code> statement, like
we started with. In fact, it gets even better: when we run this through
<code>uglifyjs</code>:</p>

<pre><code class="js">"use strict";function needsCancelButton(n){return!(n&gt;=2)}
</code></pre>

<p>Wow! This is actually <strong>better</strong> than our initial, hand-written <code>if</code>
statement. Reason compiled what used to be a string literal
<code>'SuccessScreen'</code> to just the number <code>2</code>. Reason can do this safely
because custom-defined types in Reason <strong>can&rsquo;t</strong> be treated like
strings, so it doesn&rsquo;t matter if you mangle the names.</p>

<p>Taking a step back, Reason&rsquo;s type system delivered on the promise of
types in a way Flow couldn&rsquo;t:</p>

<ul>
<li>We wrote high-level, expressive code.</li>
<li>The type checker gave us strong guarantees about the correctness
(exhaustiveness) of our code.</li>
<li>And the compiler translated that all to tiny, performant code.</li>
</ul>


<p>I&rsquo;m really excited about Reason. ðŸ˜„ It has a delightful type system and
is backed by a decades-old optimizing compiler tool chain. I&rsquo;d love to
see more people take advantage of improvements in type systems to write
better code!</p>

<hr />

<h2>Appendix: Other Compile-to-JS Runtimes</h2>

<p>The above analysis only considered Flow + Babel and Reason. But then I
got curious about how other typed languages that compile to JavaScript
compare on the optimizations front:</p>

<h3>TypeScript</h3>

<p>Despite being a language and compiler all-in-one, TypeScript maintains a
goal of compiling to JavaScript that closely resembles the source
TypesScript code. TypeScript also has two language constructs for
working with exhaustiveness:</p>

<ul>
<li>union types, analogous to what Flow has</li>
<li><code>enum</code>s, which are basically like Java&rsquo;s <code>enum</code>s.</li>
</ul>


<p>With union types, TypeScript behaved comparably to Flow. But what was
surprising: <code>enum</code>s compressed <strong>even worse</strong>:</p>

<pre><code class="js">var Screen_;
(function (Screen_) {
    Screen_[Screen_["LoadingScreen"] = 0] = "LoadingScreen";
    Screen_[Screen_["CodeEntryScreen"] = 1] = "CodeEntryScreen";
    Screen_[Screen_["SuccessScreen"] = 2] = "SuccessScreen";
})(Screen_ || (Screen_ = {}));
var impossible = function (x) {
    throw new Error('This case is impossible.');
};
var needsCancelButton = function (screen) {
    switch (screen) {
        case Screen_.LoadingScreen:
            return true;
        case Screen_.CodeEntryScreen:
            return true;
        case Screen_.SuccessScreen:
            return false;
        default:
            return impossible(screen);
    }
};
</code></pre>

<p><a href="https://www.typescriptlang.org/play/#src=enum%20Screen_%20%7B%0D%0A%20%20%20%20LoadingScreen%2C%0D%0A%20%20%20%20CodeEntryScreen%2C%0D%0A%20%20%20%20SuccessScreen%2C%0D%0A%7D%0D%0A%0D%0Aconst%20impossible%20%3D%20%3CT%3E(x%3A%20never)%3A%20T%20%3D%3E%20%7B%0D%0A%20%20throw%20new%20Error('This%20case%20is%20impossible.')%3B%0D%0A%7D%0D%0A%0D%0Aconst%20needsCancelButton%20%3D%20(screen%3A%20Screen_)%3A%20boolean%20%3D%3E%20%7B%0D%0A%20%20switch%20(screen)%20%7B%0D%0A%20%20%20%20case%20Screen_.LoadingScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.CodeEntryScreen%3A%0D%0A%20%20%20%20%20%20return%20true%3B%0D%0A%20%20%20%20case%20Screen_.SuccessScreen%3A%0D%0A%20%20%20%20%20%20return%20false%3B%0D%0A%20%20%20%20default%3A%0D%0A%20%20%20%20%20%20return%20impossible(screen)%3B%0D%0A%20%20%7D%0D%0A%7D"><strong>TypeScript Playground â†’</strong></a></p>

<ul>
<li>It&rsquo;s not smart enough to optimize away the <code>impossible</code> call.</li>
<li>It keeps around a JavaScript object representing the collection of
enum values at run time, in a format that doesn&rsquo;t minify well.</li>
</ul>


<h2>PureScript</h2>

<p>PureScript is another high-level language like Reason. They both have
data types where you can define unions with custom constructor names.
Despite that, PureScript&rsquo;s generated code is significantly worse than
Reason&rsquo;s.</p>

<pre><code class="js">"use strict";
var LoadingScreen = (function () {
    function LoadingScreen() {};
    LoadingScreen.value = new LoadingScreen();
    return LoadingScreen;
})();
var CodeEntryScreen = (function () {
    function CodeEntryScreen() {};
    CodeEntryScreen.value = new CodeEntryScreen();
    return CodeEntryScreen;
})();
var SuccessScreen = (function () {
    function SuccessScreen() {};
    SuccessScreen.value = new SuccessScreen();
    return SuccessScreen;
})();
var needsCancelButton = function (v) {
    if (v instanceof LoadingScreen) {
        return true;
    };
    if (v instanceof CodeEntryScreen) {
        return true;
    };
    if (v instanceof SuccessScreen) {
        return false;
    };
    throw new Error("Failed pattern match at Main line 10, column 1 - line 10, column 39: " + [ v.constructor.name ]);
};
</code></pre>

<ul>
<li>It&rsquo;s generating ES5 classes for each data constructor.</li>
<li>It compiles pattern matching to a series of <code>instanceof</code> checks.</li>
<li>Even though it <strong>knows</strong> the is exhaustive, it still emits a <code>throw</code>
statement in case the pattern match fails!</li>
</ul>


<p>Admittedly, I didn&rsquo;t try that hard to turn on optimizations in the
compiler. Maybe there&rsquo;s a flag I can pass to get this <code>Error</code> to go
away. But that&rsquo;s pretty disappointing, compared to how small Reason&rsquo;s
generated code was!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>&ldquo;Only ever&rdquo; is a very strong statement. Please use your best judgement. But know that if you&rsquo;re not using a <code>switch</code>, you&rsquo;re trading off the burden of exhaustiveness &amp; correctness from the type checker to the programmer!<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Even though TypeScript defines both a language <strong>and</strong> a compiler for that language, in practice it&rsquo;s not much different from Flow here. A goal of the TypeScript compiler is to generate JavaScript that closely resembles the original TypeScript, so it doesn&rsquo;t do compile-time optimizations based on the types.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>More than being a nice reminder, it makes it easy to copy / paste our type definition as boilerplate to start writing a new function!<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
