<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/ruby/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2019-12-31T14:52:31-05:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What makes type checking Ruby hard?]]></title>
    <link href="https://blog.jez.io/ruby-mutation/"/>
    <updated>2019-12-29T01:29:52-06:00</updated>
    <id>https://blog.jez.io/ruby-mutation</id>
    <content type="html"><![CDATA[<p></p>




<!-- more -->


<p>Mutation makes typechecking Ruby harder than many other programming
languages. Most people will immediately think I mean mutation in the
sense of <code>x += 1</code> or somethingâ€”that&rsquo;s not what I&rsquo;m referring to. In
fact, that&rsquo;s the easy kind of mutation to model in a type system.</p>

<p>What I mean is that nearly everything worth knowing statically about a
Ruby program involves mutation. Defining a class?</p>

<pre><code class="ruby">class A
end
</code></pre>

<p>That mutates the global namespace of constants. After those lines run,
all code in the project can reference the class <code>A</code>.</p>

<p>Defining a method?</p>

<pre><code class="ruby">class A
  def foo
    puts 'hello'
  end
end
</code></pre>

<p>The method <code>foo</code> is undefined just before the <code>def</code> block (at runtime!),
but defined afterâ€”mutation again.</p>

<p>Ruby provides things like <code>attr_reader</code> and <code>attr_accessor</code> to define
getter and setter methods:</p>

<pre><code class="ruby">class B
  attr_reader :foo
end
</code></pre>

<p><code>attr_reader</code> is not a Ruby keyword, contrary to popular belief: it&rsquo;s a
method on the singleton class which takes an argument. It defines an
instance method called <code>foo</code> as a side effect by mutating the class <code>B</code>.</p>

<p>It&rsquo;s the same for mixing modules into classes:</p>

<pre><code class="ruby">module M; end
class C
  include M
end
</code></pre>

<p><code>include</code> is another method disguised like a keyword which mutates the
class&rsquo;s list of ancestors.</p>

<p>One of my least favorite Ruby features: you can <strong>redefine</strong> (not
override) a method:</p>

<pre><code class="ruby">class D
  attr_reader :foo
  alias_method :old_foo, :foo
  def foo
    puts 'Calling D#foo'
    old_foo
  end
end
</code></pre>

<p>Because <code>D#foo</code> is defined by the <code>attr_reader</code> line, the subsequent
<code>def</code> overwrites it (akin to mutating a local variable, like <code>x += 1</code>).
Oh and that <code>alias_method</code>? Another method looking like a keyword which
mutates the class.</p>

<p>Even the way libraries work in Ruby is powered by mutation:</p>

<pre><code class="ruby">require 'some_gem'
</code></pre>

<p><code>require</code> is a method (again, not a keyword) that looks up and runs
arbitrary Ruby code, whose result we discard. It&rsquo;s only convention that
the primary side effect of the <code>require</code>&rsquo;d code is to mutate the global
namespace, defining more classes and methods.</p>

<h2>DSLs and metaprogramming</h2>

<p>It would be one thing if Ruby constrained the places where this mutation
could occur. But instead, it provides first-class support for these
features anywhere Ruby code runs. Everything we&rsquo;ve seen so far can be
hidden behind arbitrary computation at runtime:</p>

<ul>
<li>With <code>Module#const_set</code>, a Ruby program can compute an arbitrary name
and use it to create new constant at runtime.</li>
<li><code>Module#define_method</code> does the same for methods.</li>
<li>Again <code>require</code> is a method, so it can occur wherever other methods
are called.</li>
</ul>


<p>It&rsquo;s not uncommon to see Ruby libraries embrace this rather than avoid
it (Rails definitely does). Ruby programs frequently build up large
abstractions and do tons of computation which at the end of the day
result in a <code>define_method</code> or a <code>const_set</code>.</p>

<p>Rubyists call this &ldquo;metaprogramming&rdquo; or &ldquo;building DSLs&rdquo; but I call it
like I see it: mutation.</p>

<h2>Modeling mutation</h2>

<p>Type systems are notoriously bad at modelling this kind of mutation.
Look at other typed, object-oriented languages: Java, Scala, C++, &hellip;
Each of these languages <strong>forbids</strong> this kind of mutation. (Whether
because it&rsquo;s hard to implement support for it or because they&rsquo;re making
a value judgement is beyond me.)</p>

<p>So how can Sorbet can model this? Mostly, it just cheats. Err,
&ldquo;approximates.&rdquo; From my experience working on the Sorbet team, I can
think of three main ways it cheats.</p>

<p>First, Sorbet assumes that if a class or method might exist, it does
exist, and universally throughout a project.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> It pretends
that all <code>include</code>, <code>extend</code>, and <code>alias_method</code> statements in a class
run first, before all other code at the top-level of that class. It
restricts method redefinitionsâ€”the old and new methods must take the
same number and kinds of arguments. And it restricts <code>alias_method</code>: you
can only alias to a method on your class, not to a parent class. Sorbet
makes no attempt to model <code>undef_method</code> at all (another
method-not-keyword!).</p>

<p>Second, Sorbet cheats by implementing heuristics for the most common
DSLs. To support <code>attr_reader</code>, Sorbet says, &ldquo;Hey, this method call
happens to be to some method named <code>attr_reader</code>. I&rsquo;m not sure if it&rsquo;s
to <code>Module#attr_reader</code> or to some other <code>attr_reader</code> definition or to
any definition at all, but it&rsquo;s provided with a single Symbol argument,
the result is discarded, and it&rsquo;s called at the syntactic top-level of a
class, so I bet that it is a call to <code>Module#attr_reader</code>.&rdquo; It&rsquo;s similar
for many other popular DSLs: it makes decent educated guesses.</p>

<p>But after all that, it sort of gives up. Sorbet makes no attempts to
work backwards from a call to <code>define_method</code> or <code>const_set</code> inside a
method body to learn that a class or method might have been defined
somewhere. Instead, it cheats one last time and uses runtime information.</p>

<p>As a part of initializing a Sorbet project, Sorbet <code>require</code>s (read:
executes) as much code in a project as it can: all the gems listed in
the Gemfile and all the Ruby files in the current folder. Afterwards, it
can see the result of all that&rsquo;s been mutated thus far (via reflection)
and serialize what it sees into <a href="https://sorbet.org/docs/rbi">RBI files</a> to convey what it saw to the
static checker. This is still imperfect (it completely misses things
that are defined after <code>require</code> time), but empirically it finds most of
the remaining undiscovered definitions.</p>

<h2>Beyond mutation</h2>

<p>Don&rsquo;t get me wrong, those approximations are really useful and
effective. But really, the way Sorbet handles mutation in a codebase is
by incentivicing people to get rid of it.</p>

<ul>
<li><p>Sorbet can type check a project in seconds, but it takes minutes to
re-generate all RBIs files. When Sorbet can see things statically,
there&rsquo;s also a canonical place to write a type annotation for it.</p></li>
<li><p>It&rsquo;s a much better experience to click &ldquo;Go to Definition&rdquo; and jump to
the actual source definition rather than to an auto-generated RBI
file.</p></li>
<li><p>And arguably, if it&rsquo;s easy for Sorbet to understand what&rsquo;s defined and
where, it&rsquo;s easier for a programmer to understand. Understandable code
lets people iterate faster, is less brittle, and harder to break by
accident.</p></li>
</ul>


<p>Programming languages are tools to change and structure the way we
think. In the long run, all code can be changed. We adopt type systems
specifically to help guide these changes, which <a href="https://blog.jez.io/on-language-choice/">I&rsquo;ve touched on
before</a>. When it comes to mutation in Ruby, Sorbet makes a solid effort
to model the helpful parts, while providing guide rails and suggestions
to deal with the rest.</p>

<hr />

<h2>Appendix A: By comparison with typed JavaScript</h2>

<p>You might say, &ldquo;the things that you&rsquo;re talking about aren&rsquo;t unique to
Ruby! It&rsquo;s the same for all dynamic programming languages!&rdquo; But is that
true in practice?</p>

<p>Let&rsquo;s compare our Ruby snippets from before with JavaScript.</p>

<p>Ruby:</p>

<pre><code class="ruby">class A
  def self.my_dsl(name)
    define_method(name) do; end
  end
end
</code></pre>

<p>JavaScript:</p>

<pre><code class="js">class A {
  static myDsl(name) {
    this.prototype[name] = function() {}
  }
}
</code></pre>

<p>First I&rsquo;ll point out: the mutation becomes way more obvious in the
JavaScript program! But second: both TypeScript and Flow report static
errors on this program. They both complain that there&rsquo;s no type
annotation declaring that it&rsquo;s ok to treat <code>this.prototype</code> as if it
were a key-value mapping.</p>

<p>The fact that both Flow and TypeScript report an error here speak to how
common this idiom is in practice. It&rsquo;s not common, and they&rsquo;d rather not
encourage programs like this, so they forbid it.</p>

<p>Here&rsquo;s another example, first in Ruby:</p>

<pre><code class="ruby">require 'some_gem'

SomeNamespace::SomeClass.new
</code></pre>

<p>And then in JavaScript:</p>

<pre><code class="js">import someNamespace from 'some_package';

new someNamespace.SomeClass();
</code></pre>

<p>With no RBI files declaring whether <code>SomeNamespace::SomeClass</code> exists
or not, Sorbet will report an error that the class doesn&rsquo;t exist. But in
TypeScript and Flow, the code is just fine, even if there&rsquo;s no type
declaration file. Both can still see that whatever vale is imported will
be bound to the <code>someNamespace</code> variable (even if it&rsquo;s treated as
<code>any</code>).</p>

<p>Sorbet is thus forced to come up with ways to generate RBI files for all
new projects, because without them Sorbet would be crippled: it would
have no way to distinguish between a class name that has actually been
typoed vs one that is typed correctly but for which there&rsquo;s no visible
definition. Meanwhile, TypeScript and Flow work completely fine in new
codebases out of the box.</p>

<p>So my claim is that: no, these problems <strong>are</strong> unique to Ruby, because
the design of the language and the culture of its use so pervasively
promote or require mutation.</p>

<h2>Appendix B: More things that are actually mutation</h2>

<ul>
<li><p><code>freeze</code> (ironic: to prevent mutation on a class or object&hellip; we
mutate it!)</p></li>
<li><p><code>private</code> / <code>private_class_method</code> (not keywords! These are methods
that take a <strong>Symbol</strong>; it just so happens that <code>def foo; end</code> is an
expression that evaluates to the symbol <code>:foo</code>. Which is why there&rsquo;s
both <code>private</code> and <code>private_class_method</code>, because <code>def self.foo; end</code>
also evaluates to <code>:foo</code>, so <code>private def self.foo; end</code> would attempt
to mark an <strong>instance</strong> method named <code>:foo</code> private, even it didn&rsquo;t
exist!)</p></li>
</ul>


<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Frequently this assumption is backed up by an autoloader. For example, Rails includes an autoloader that loads constants lazily on demand, so that the programmer doesn&rsquo;t have to sprinkle require statements throughout the code. But how do autoloads work? Mutation again ðŸ™‚.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Virtualenvs]]></title>
    <link href="https://blog.jez.io/ruby-virtualenvs/"/>
    <updated>2014-12-22T12:52:40-06:00</updated>
    <id>https://blog.jez.io/ruby-virtualenvs</id>
    <content type="html"><![CDATA[<p>A while back I found a command that removes all Ruby gems installed on a system
when you&rsquo;re using rbenv. It worked great, so I decided to build on top of it.
After a bit of research, I found a much better solution to the root of my
problems: sandboxing Ruby gems.</p>

<!-- more -->


<h2>Ugh, Ruby&hellip;</h2>

<p>If you&rsquo;re anything like me, you can never do anything right on the first try
using Ruby. At one point, I found myself needing a script to just nuke
everything and start over&hellip; That&rsquo;s when I found Ian Vaughan&rsquo;s <a href="https://gist.github.com/IanVaughan/2902499">script</a> that
magically removes all gems. I was delighted to see that it worked perfectly on
the first try, and went about the rest of my business.</p>

<h2>Modifications</h2>

<p>There were two ways though in which this script&rsquo;s functionality differed from
what I wanted it to do: it always removed <strong>all</strong> gems, and it left behind a
<code>.ruby_version</code> file after it was used, clobbering any file that might have been
there before.</p>

<p>In my updated script, you can specify a list of ruby versions as arguments, and
it will only gems from those versions instead of all of them.  Also, it saves
and restores the value of the old <code>.ruby_version</code> file once it&rsquo;s done.</p>

<p>The new script is available <a href="https://gist.github.com/jez/cc2ba08062c6183a489c">as a fork of the original Gist</a> and also as
a part of of <a href="https://github.com/jez/bin/blob/master/uninstall_gems">my personal bin folder</a>.</p>

<h2>The Underlying Problem: Virtualenv&rsquo;s in Ruby</h2>

<p>After a bit of reflection, I realized I should be trying to solve the underlying
problem: different projects had different dependencies, and gems from one
project were bleeding into gems from another. If you&rsquo;re a Python developer, you
don&rsquo;t have this issue: <a href="http://virtualenvwrapper.readthedocs.org/en/latest/">virtualenvwrapper</a>, <code>pip</code>, and <code>requirements.txt</code>
files make this a non-issue.</p>

<p>After looking into if there existed a similar Ruby solution, I came up with
<a href="http://honza.ca/2011/06/install-ruby-gems-into-virtualenv">this blog post</a> outlining how you can do the exact same thing using
virtualenvs but with Ruby gems! Once again, it needed a little bit of
modification so that everything works again as you&rsquo;d expect when you
<code>deactivate</code>. Add these lines to your virtualenv&rsquo;s <code>postactivate</code> script:</p>

<pre><code class="python $VIRTUAL_ENV/bin/postactivate">export OLD_GEMHOME="$GEM_HOME"
export GEM_HOME="$VIRTUAL_ENV/gems"

export OLD_GEM_PATH="$GEM_PATH"
export GEM_PATH=""

export OLD_PATH="$PATH"
export PATH="$GEM_HOME/bin:$PATH"
</code></pre>

<p>And then add this complementary section to your <code>predeactivate</code> script:</p>

<pre><code class="python $VIRTUAL_ENV/bin/predeactivate">export GEM_HOME="$OLD_GEM_HOME"
unset OLD_GEM_HOME

export GEM_PATH="$OLD_GEM_PATH"
unset OLD_GEM_PATH

export PATH="$OLD_PATH"
unset OLD_PATH
</code></pre>

<p>Now, whenever you install gems, they&rsquo;ll install to the folder
<code>$VIRTUAL_ENV/gems/</code> instead of the system&rsquo;s location, so no gems bleed into
another project!</p>

<h2>One Step Further</h2>

<p>Bringing up this web page, copying those snippets, and pasting them in the two
necessary files every time is a bit tedious. To automate this process, we can
tap into virtualenvwrapper&rsquo;s configurability using hooks. Instead of dropping
those snippets into <code>$VIRTUAL_ENV/bin/{post,prede}activate,</code>, place them in
<code>$VIRTUALENVWRAPPER_HOOK_DIR/{post,prede}activate</code>.</p>

<p>Now every time you <code>workon</code> a virtualenv, the appropriate configuration will
be set up. Note that this means every normal Python project you use will have
this Ruby configuration added (not just the Ruby projects), but that shouldn&rsquo;t
matter because they interoperate nicely. If it&rsquo;s really an issue, you can stick
with the per-virtualenv solution above.</p>

<p>Note: a side effect of this nice sandboxing is that you can normally run
commands without prefixing them with <code>bundle exec ...</code>, which is actually really
handy.</p>
]]></content>
  </entry>
  
</feed>
