<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sml | Bits, Bytes, and Words]]></title>
  <link href="https://blog.jez.io/categories/sml/atom.xml" rel="self"/>
  <link href="https://blog.jez.io/"/>
  <updated>2017-09-25T05:26:58-04:00</updated>
  <id>https://blog.jez.io/</id>
  <author>
    <name><![CDATA[Jake Zimmerman]]></name>
    <email><![CDATA[jake@zimmerman.io]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[System Fω and Parameterization]]></title>
    <link href="https://blog.jez.io/system-f-param/"/>
    <updated>2017-09-27T22:14:45-04:00</updated>
    <id>https://blog.jez.io/system-f-param</id>
    <content type="html"><![CDATA[<p>My understanding of System F<sub>ω</sub> used to be really shaky. In
particular, I&rsquo;d been confused about the difference between <code>∀(t.τ)</code>
(forall types) and <code>λ(u.c)</code> (type abstractions) for a long time. Both of
these constructs have to do with parameterization (factoring out a
variable so that it&rsquo;s bound), but each has a drastically different
meaning.</p>

<!-- more -->


<h2>Questions</h2>

<p>We&rsquo;ll start off with some questions to keep in mind throughout these
notes. Our goals by the end are to understand what the questions are
asking, and have at least a partial&mdash;if not complete&mdash;answer to each.</p>

<p>First, consider this code.</p>

<pre><code class="sml">datatype 'a list = Nil | Cons of 'a * 'a list
</code></pre>

<ul>
<li>What really is &ldquo;<code>list</code>&rdquo; in this code?</li>
<li>Or put another way, how would we define <code>list</code> in System
F<sub>ω</sub>?</li>
</ul>


<p>Thinking more broadly,</p>

<ul>
<li>What separates <code>∀(t.τ)</code> and <code>λ(u.c)</code>?</li>
<li>What is parameterization, and how does it relate to these things?</li>
</ul>


<h2>System F<sub>ω</sub></h2>

<p>The answers to most of these questions rely on a solid definition of
System F<sub>ω</sub>. We&rsquo;ll be using this setup.</p>

<pre><code>Kind κ ::= * | κ → κ | ···

           abstract       concrete      arity/valence
Con c  ::= ···
         | arr(c₁; c₂)    c₁ → c₂       (Con, Con)Con
         | all{κ}(u.c)    ∀(u ∷ κ). c   (Kind, Con.Con)Con
         | lam{κ}(u.c)    λ(u ∷ κ). c   (Kind, Con.Con)Con
         | app(c₁; c₂)    c₁(c₂)        (Con, Con)Con
</code></pre>

<p>Some points to note:</p>

<ul>
<li><code>∀(u ∷ κ). c</code> and <code>λ(u ∷ κ). c</code> have the same arity.</li>
<li><code>∀(u ∷ κ). c</code> and <code>λ(u ∷ κ). c</code> both <em>bind</em> a constructor variable.
This makes these two operators <em>parametric</em>.</li>
<li>Only <code>λ(u ∷ κ). c</code> has a matching elim form: <code>c₁(c₂)</code>.
(There are no elim forms for <code>c₁ → c₂</code> and <code>∀(u ∷ κ). c</code>, because they
construct types of kind <code>*</code>. This will be important later.)</li>
</ul>


<p>It&rsquo;ll also be important to have these two inference rules for kinding:</p>

<p>$$
\frac{
  \Delta, u :: \kappa \vdash c :: *
}{
  \Delta \vdash \forall(u :: \kappa). \, c :: *
}\;(\texttt{forall-kind})
$$
$$
\frac{
  \Delta, u :: \kappa \vdash c :: \kappa&#8217;
}{
  \Delta \vdash \lambda(u :: \kappa). \, c :: \kappa \to \kappa&#8217;
}\;(\texttt{lambda-kind})
$$</p>

<h2>Defining the <code>list</code> Constructor</h2>

<p>Let&rsquo;s take another look at this datatype definition from above:</p>

<pre><code class="sml">datatype 'a list = Nil | Cons of 'a * 'a list
</code></pre>

<p>We&rsquo;ve <a href="http://www.cs.cmu.edu/~rwh/courses/ppl/recitations/variables-in-types-jezimmer.pdf">already seen</a> how to encode the type of lists
of integers using inductive types:</p>

<pre><code>intlist = μ(t. 1 + (int × t))
</code></pre>

<p>Knowing what we know about System F (the &ldquo;<strong>polymorphic</strong> lambda
calculus&rdquo;), our next question should be &ldquo;how do we encode
<strong>polymorphic</strong> lists?&rdquo; Or more specifically, which of these two
operators (<code>λ</code> or <code>∀</code>) should we pick, and why?</p>

<p>First, we should be more specific, because there&rsquo;s a difference between
<code>list</code> and <code>'a list</code>. Let&rsquo;s start off with defining <code>list</code> in
particular. From what we know of programming in Standard ML, we can do
things like:</p>

<pre><code class="sml">type grades = int list

type key = string
type val = real
type updates = (key, val) list
</code></pre>

<p>If we look really closely, what&rsquo;s actually happening here is that <code>list</code>
is a type-level <em>function</em> that returns a type (and we use the <code>type foo
= ...</code> syntax to store that returned type in a variable).<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>Since <code>list</code> is actually a function from types to types, it must have
an arrow kind: <code>* → *</code>. Looking back at our two inference rules for
kinding, we see only one rule that lets us introduce an arrow kind: <code>λ(u
∷ κ). c</code>. On the other hand, <code>∀(u ∷ κ). c</code> must have kind <code>*</code>; it
<em>can&rsquo;t</em> be used to define type constructors.</p>

<p>Step 1: define list constructor? Check:</p>

<pre><code>list = λ(α ∷ *). μ(t. 1 + (α × t)))
</code></pre>

<h2>Defining Polymorphic Lists</h2>

<p>It doesn&rsquo;t stop with the above definition, because it&rsquo;s still not
<em>polymorphic</em>. In particular, we can&rsquo;t just go write functions on
polymorphic lists with code like this:</p>

<pre><code class="sml">fun foo (x : list) = (* ··· *)
</code></pre>

<p>We can&rsquo;t say <code>x : list</code> because all intermediate terms in a given
program have to type check as a type of kind <code>*</code>, whereas <code>list ∷ * →
*</code>. Another way of saying this: there isn&rsquo;t any way to introduce a value
of type <code>list</code> because there&rsquo;s no way to introduce values with arrow
kinds.</p>

<p>Meanwhile, we <em>can</em> write this:</p>

<pre><code class="sml">fun foo (x : 'a list) = (* ··· *)
</code></pre>

<p>When you get down to it, this is actually kind of weird. Why is it okay
to use <code>'a list</code>? I never defined <code>'a</code> anywhere, so wouldn&rsquo;t that make
it an unbound variable?</p>

<p>It turns out that when we use type variables like this, SML
automatically binds them for us by inserting <code>∀</code>s into our code. In
particular, it implicitly infers a type like this:</p>

<pre><code class="sml">val foo : forall 'a. 'a list -&gt; ()
</code></pre>

<p>SML inserts this <code>forall</code> automatically because its type system is a bit
less polymorphic than System F<sub>ω</sub>&rsquo;s, which can be thought of as
a drawback. But on the other hand, it does at least save us from typing
these <code>forall</code> annotations. For most of the other &ldquo;drawbacks&rdquo; we get
from not being able to write the <code>forall</code> ourself, SML makes up the
difference with modules.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>Step 2: make polymorphic list for use in annotation? Check:</p>

<pre><code>α list = ∀(α ∷ *). list(α)
</code></pre>

<h2>Variables &amp; Parameterization</h2>

<p>Tada! We&rsquo;ve figured out how to take a list datatype from SML and encode
it in System F<sub>ω</sub>, using these two definitions:</p>

<pre><code>  list = λ(α ∷ *). μ(t. 1 + (α × t)))
α list = ∀(α ∷ *). list(α)
</code></pre>

<p>We could end here, but there&rsquo;s one more interesting point. If we look
back, we started out with the <code>∀</code> and <code>λ</code> operators having the same
arity, but somewhere along the way their behaviors differed. <code>λ</code> was
used to create type constructors, while <code>∀</code> was used to introduce
polymorphism.</p>

<p>Where did this split come from? What distinguishes <code>∀</code> as being the
go-to type for polymorphism, while <code>λ</code> makes type constructors
(type-to-type functions)? Recall one of the earliest ideas we teach in
<a href="http://www.cs.cmu.edu/~rwh/courses/ppl/">15-312</a>:</p>

<blockquote><p>&hellip; the core idea carries over from school mathematics, namely
that <strong>a variable is an unknown, or a place-holder, whose meaning is
given by substitution.</strong></p>

<p>&ndash; Harper, <em>Practical Foundations for Programming Languages</em></p></blockquote>

<p>Variables are given meaning by substitution, so we can look to the
appropriate substitutions to uncover the meaning and the differences
between <code>λ</code> and <code>∀</code>. Let&rsquo;s first look at the substitution for <code>λ</code>:</p>

<p>$$
\frac{
  \Delta, u :: \kappa_1 \vdash c_2 :: \kappa_2 \qquad \Delta \vdash c_1
  :: \kappa_1
}{
  \Delta \vdash (\lambda(u :: \kappa_1). \, c_2)(c_1) \equiv  [c_1/u]c_2 :: \kappa_2
}
$$</p>

<p>We can think of this as saying &ldquo;when you apply one type to another, the
second type gets full access to the first type to construct a new type.&rdquo;
We notice that the substitution here is completely <strong>internal to the
type system</strong>.<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></p>

<p>On the other hand, the substitution for <code>∀</code> <strong>bridges the gap</strong> from
types to terms:</p>

<p>$$
\frac{
  \Delta \, \Gamma, e : \forall (u :: \kappa). \tau \qquad \Delta \vdash c :: \kappa
}{
  \Delta \, \Gamma \vdash e[c] : [c/u]\tau
}
$$
$$
\frac{
  \mbox{}
}{
  (\Lambda u. \, e)[\tau] \mapsto [\tau / u]e
}
$$</p>

<p>When we&rsquo;re type checking a polymorphic type application, we don&rsquo;t get to
know anything about the type parameter <code>u</code> other than its kind. But when
we&rsquo;re running a program and get to the evaluation of a polymorphic type
application, we substitute the concrete <code>τ</code> directly in for <code>u</code> in <code>e</code>,
which bridges the gap from the type-level to the term-level.</p>

<p>At the end of the day, all the interesting stuff came from using
functions (aka, something parameterized by a value) in cool ways. Isn&rsquo;t
that baffling? Functions are so powerful that they seem to always pop up
at the heart of the most interesting constructs. I think it&rsquo;s
straight-up amazing that something so simple can at the same time be
that powerful. Functions!</p>

<!-- vim:tw=72
-->

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Noticing that these are functions is a bit weird because in Standard ML, the type applications are backwards. Instead of <code>f(x)</code>, it&rsquo;s <code>x f</code>. But this is more similar to how we actually think; in some sense, the parameters of a function are like adjectives modifying a noun&mdash;and adjectives come before the noun they describe.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Other languages (like Haskell or PureScript) have a language feature called &ldquo;Rank-N Types&rdquo; which is really just a fancy way of saying &ldquo;you can put the <code>forall a.</code> anywhere you want.&rdquo; Oftentimes, this makes it harder for the compiler to infer where the variable bindings are, so you sometimes have to use more annotations than you might if you weren&rsquo;t using Rank-N types.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>It&rsquo;s not super relevant to this discussion, but this inference rule is for the judgement defining equality of type constructors. This comes up all over the place when you&rsquo;re writing a compiler for SML. If this sounds interesting, definitely take 15-417 HOT Compilation!<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SML Dev Setup]]></title>
    <link href="https://blog.jez.io/sml-dev-setup/"/>
    <updated>2016-03-09T21:06:15-05:00</updated>
    <id>https://blog.jez.io/sml-dev-setup</id>
    <content type="html"><![CDATA[<p>When it comes right down to it, SML is a pretty great language. It&rsquo;s clear that
extensive thought has gone into its design and implementation. I quite enjoy
programming in SML, due in no small part to my collection of workflow hacks that
make editing and developing with SML responsive and interactive.</p>

<!-- more -->


<p>We&rsquo;re going to be walking through a couple easy steps you can take to make
developing SML feel more fluid, both in and out of your editor. I have a slight
preference for Vim on OS X, but many of these steps are platform agnostic.</p>

<h2>Installing SML Locally</h2>

<p>While developing SML in a remote environment like the shared Andrew Unix
machines makes it easy to dive right in, working with SML for prolonged periods
of time is best done locally.</p>

<p>On OS X and Ubuntu, the two most popular SML implementations are already
packaged. Take the time to install a version of SML right now. At CMU, we use
<a href="http://smlnj.org/">SML/NJ</a>, which is convenient because it has a REPL that lets you play
around with SML interactively. If you&rsquo;d like to play around with compiling and
distributing programs written in SML, you might want to install <a href="http://www.mlton.org/">MLton</a>.</p>

<pre><code class="bash Install SML from your package manager"># SML/NJ on OS X
brew install smlnj
# -- or --
# MLton on OS X
brew install mlton

# SML/NJ on Ubuntu
sudo apt-get install smlnj
# -- or --
# MLton on Ubuntu
sudo apt-get install mlton
</code></pre>

<p>Feel free to install both if you&rsquo;d like; they&rsquo;ll play nicely with each other and
each offers advantages over the other.</p>

<p>Note for OS X users: if you&rsquo;ve never used <a href="http://brew.sh">Homebrew</a> before, you&rsquo;ll need
to <a href="http://brew.sh">install it first</a>.</p>

<h2>Getting Comfortable with SML/NJ</h2>

<p>The rest of these steps should apply regardless of whether you&rsquo;re working on SML
locally or remotely.</p>

<p>One thing that I&rsquo;ve seen far too many times from course documentation is that
they tell students to run their code like this:</p>

<ol>
<li>Run <code>sml</code></li>
<li>Type <code>use "foo.sml";</code> or <code>CM.make "sources.cm";</code> at the REPL</li>
</ol>


<p>Don&rsquo;t get me wrong; this works, but there&rsquo;s a better way. Being responsible
CLI-citizens, we should always be looking for ways to tab-complete. Let&rsquo;s do
this by changing our workflow:</p>

<ol>
<li>Run <code>sml foo.sml</code> or <code>sml -m sources.cm</code></li>
</ol>


<p>Look at that! We&rsquo;ve,</p>

<ul>
<li>dropped a step (having to launch the REPL first), and</li>
<li>introduced tab completion into our workflow (because the shell has filename
completion)</li>
</ul>


<p>It&rsquo;s the little things, but they add up.</p>

<h2>Enhancing the REPL</h2>

<p>Speaking of the little things, when using the SML REPL, you don&rsquo;t have access to
all the usual command line niceties like command history and access to arrow
keys for editing, let alone Vi-like keybindings. To get started, you&rsquo;ll have to
change how you launch the SML/NJ REPL. In particular, we&rsquo;re going to preface our
commands with <code>rlwrap</code>:</p>

<pre><code class="bash"># instead of this...
$ sml

# use this:
$ rlwrap sml
</code></pre>

<p><code>rlwrap</code> stands for &ldquo;readline wrap.&rdquo; Readline is a library that simply adds to a
REPL program all the features mentioned above:</p>

<ul>
<li>Command history tracking</li>
<li>Line editing with arrow keys</li>
<li>Configurability through the <code>~/.inputrc</code> file

<ul>
<li>We can use this to get fancy features like Vi keybindings</li>
</ul>
</li>
</ul>


<p>For more information, see <a href="https://github.com/jez/dotfiles/blob/ed8e531eebe43a8aef05fc4cb768157d03408cea/inputrc#L12-L14">these lines</a> of my inputrc, a small part of
my <a href="https://github.com/jez/dotfiles">dotfiles repo</a> on GitHub.</p>

<h2>Setting Up Vim</h2>

<p>Programming is so much more enjoyable when you&rsquo;re not fighting your editor. For
me, this means striving to get the most out of Vim. In this section, I&rsquo;ll
outline all the cool tips and tricks I have for developing SML in Vim.</p>

<p>But first, if you&rsquo;ve never taken a look into how to configure Vim, I suggest you
start out by walking through this quick workshop called <a href="https://github.com/jez/vim-as-an-ide">Vim as an
IDE</a>. It&rsquo;ll teach you where to start when configuring Vim and get
you set up with a bunch of standard plugins that improve on the standard Vim
experience tenfold.</p>

<p>No actually, take a second and <a href="https://github.com/jez/vim-as-an-ide">walk through it</a>. We&rsquo;ll still be
here when you&rsquo;re done, and you&rsquo;ll appreciate Vim more when you&rsquo;re done.</p>

<h3>Syntastic</h3>

<p>From the Syntastic documentation:</p>

<blockquote><p>Syntastic is a syntax checking plugin for Vim that runs files through
external syntax checkers and displays any resulting errors to the user. This
can be done on demand, or automatically as files are saved. If syntax errors
are detected, the user is notified and is happy because they didn&rsquo;t have to
compile their code or execute their script to find them.</p></blockquote>

<p>And the best part? Syntastic ships with a checker for SML by default if you
have SML/NJ installed.</p>

<p>If you didn&rsquo;t just install <a href="https://github.com/scrooloose/syntastic">Syntastic</a> from the Vim as an IDE
walkthrough, you can <a href="https://github.com/scrooloose/syntastic">visit their homepage</a> for installation
instructions. Go ahead and do this now, then try writing this in a file called
<code>test.sml</code>:</p>

<pre><code class="sml test.sml">val foo : string = 42
</code></pre>

<p>You should see an &lsquo;x&rsquo; next to the line and a description of the error from the
type checker. You can imagine how handy this is.</p>

<h3>Extra Syntastic Setup</h3>

<p>Syntastic has their own set of <a href="https://github.com/scrooloose/syntastic#settings">recommended settings</a> that
you can add at your discretion. At the very least, I&rsquo;d suggest adding these
lines to your vimrc:</p>

<pre><code class="vim .vimrc">...

augroup mySyntastic
  " tell syntastic to always stick any detected errors into the location-list
  au FileType sml let g:syntastic_always_populate_loc_list = 1

  " automatically open and/or close the location-list
  au FileType sml let g:syntastic_auto_loc_list = 1
augroup END

" press &lt;Leader&gt;S (i.e., \S) to not automatically check for errors
nnoremap &lt;Leader&gt;S :SyntasticToggleMode&lt;CR&gt;

...
</code></pre>

<p>By default, whenever you save your file, Syntastic will place symbols in Vim&rsquo;s
<em>sign column</em> next to lines with errors. The first two settings above tell
Syntastic to also show a summarized list of errors at the bottom of the screen.
The final setting lets you press <code>&lt;Leader&gt;S</code> (which is usually just <code>\S</code>) to
disable all that. This is useful when you&rsquo;re still unfinished and you know your
SML isn&rsquo;t going to type check. Press it again to re-enable it.</p>

<p>Also, a tip for those who&rsquo;ve never used Vim&rsquo;s location list feature before: you
can close the list with <code>:lclose</code>.</p>

<h3><code>vim-better-sml</code></h3>

<p>The curious at this point might be wondering if Syntastic is smart enough to
figure out when the file you&rsquo;re using requires a CM file to compile and uses it
to show you where the errors are instead. As it turns out: no, <a href="https://github.com/scrooloose/syntastic/pull/1719">that&rsquo;s not a
feature Syntastic wants to include</a> by default. However, the
functionality isn&rsquo;t hard to implement, and there&rsquo;s already a plugin for it!</p>

<p><a href="https://github.com/jez/vim-better-sml">vim-better-sml</a> is one of my Vim plugins. Here&rsquo;s a quick
rundown of its features:</p>

<ul>
<li>As already mentioned, it will detect when your file requires a CM file to
build, and will pass along the information to Syntastic</li>
<li><code>let</code> expressions are indented one level under <code>fun</code> declarations</li>
<li><code>*.sig</code> files are properly detected as SML signature files</li>
<li>Apostrophe characters are treated as keywords characters</li>
<li>The comment string is properly registered for SML files</li>
</ul>


<p>For more information, including how to install it, check out the homepage:
<a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>.</p>

<h2>General Vim Settings</h2>

<p>As a quick addendum, one common complaint people have when editing SML is that
it forces the line to wrap if it extends to 80 characters. Some people don&rsquo;t
like that it does this, and others don&rsquo;t like that it doesn&rsquo;t do it frequently
enough (namely, it only wraps the line if your cursor extends past 80
characters, not the end of the line).</p>

<p>If you don&rsquo;t want Vim to do any of this wrapping, run this:</p>

<pre><code class="vim Disable hard line wrapping">setlocal textwidth=0
</code></pre>

<p>If you&rsquo;d like this change to persist between Vim sessions, add it to
<code>~/.vim/after/ftplugin/sml.vim</code>. These folders and file likely don&rsquo;t exist
yet; you&rsquo;ll have to create them. The <code>after</code> folder in Vim is used to override
settings loaded from plugins. As you might have guessed, files in here are run
after plugin code is.</p>

<p>Conversely, if you&rsquo;d like a little better idea when Vim&rsquo;s going to hard wrap
your line, you can add this line to your vimrc:</p>

<pre><code class="vim Show a color column">set colorcolumn+=0
</code></pre>

<p>Note: this will only work if you&rsquo;re using Vim 7.4 or above. This setting tells
Vim to draw a solid column at the same width as the value of the <code>textwidth</code>
setting.</p>

<h2>TL;DR</h2>

<p>We covered a lot, so here&rsquo;s a quick recap:</p>

<ul>
<li>Install SML locally. It&rsquo;s super easy to do on OS X and Linux (use your package
manager), and means you don&rsquo;t have have a Wi-Fi connection to develop SML.</li>
<li>Invest time into learning Vim. Here&rsquo;s a reference: <a href="https://github.com/jez/vim-as-an-ide">Vim as an
IDE</a>.</li>
<li>Install <a href="https://github.com/scrooloose/syntastic">Syntastic</a>. It tells you what lines your errors are on.</li>
<li>Install <a href="https://github.com/jez/vim-better-sml">vim-better-sml</a>. It includes some features Syntastic
doesn&rsquo;t by default, and includes a couple extras.</li>
<li>Consider using <code>setlocal textwidth=0</code> or <code>set colorcolumn+=0</code> to deal with the
80-character restriction when writing SML files.</li>
</ul>


<p>And as always, you can see even more Vim settings in my <a href="https://github.com/jez/dotfiles">dotfiles
repo</a> on GitHub.</p>
]]></content>
  </entry>
  
</feed>
