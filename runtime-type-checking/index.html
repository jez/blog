<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2023-01-03 13:15:03 -0500">
<meta name="description" content="Checking type annotations at runtime—in to statically—is a net win in a gradual type system. In many cases runtime checking only _seems_ like it comes with more costs, when in fact they're the same costs, paid earlier. When there are net-new costs, there are ways to minimize them, and runtime-checked type annotations come with some key benefits that makes working in a gradually-typed codebase easier.">
<title>Runtime type checking is great – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Runtime type checking is great</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2023-01-03 13:15:03 -0500">January 3, 2023</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#quick-background" id="toc-quick-background">Quick
  background</a></li>
  <li><a href="#complaints-about-checking-types-at-runtime"
  id="toc-complaints-about-checking-types-at-runtime">Complaints about
  checking types at runtime</a>
  <ul>
  <li><a
  href="#its-riskier-because-a-types-only-change-might-break-the-code"
  id="toc-its-riskier-because-a-types-only-change-might-break-the-code">“It’s
  riskier, because a types-only change might break the code”</a></li>
  <li><a href="#its-more-work" id="toc-its-more-work">“It’s more
  work”</a></li>
  <li><a href="#runtime-checks-slow-the-code-down"
  id="toc-runtime-checks-slow-the-code-down">“Runtime checks slow the
  code down”</a></li>
  <li><a href="#runtime-checks-are-strange"
  id="toc-runtime-checks-are-strange">“Runtime checks are
  strange”</a></li>
  </ul></li>
  <li><a href="#unique-benefits-from-runtime-typing"
  id="toc-unique-benefits-from-runtime-typing">Unique benefits from
  runtime typing</a>
  <ul>
  <li><a href="#it-enables-dead-code-checking"
  id="toc-it-enables-dead-code-checking">It enables dead code
  checking</a></li>
  <li><a href="#the-implementation-matches-the-api"
  id="toc-the-implementation-matches-the-api">The implementation matches
  the API</a></li>
  </ul></li>
  <li><a href="#testimonials-and-wrapping-up"
  id="toc-testimonials-and-wrapping-up">Testimonials and wrapping
  up</a></li>
  <li><a href="#appendix" id="toc-appendix">Appendix</a></li>
  </ul>
</nav>

<main>
<p>Checking type annotations at runtime—in to statically—is a net win in
a <a href="https://sorbet.org/docs/gradual">gradual type system</a>. In
many cases runtime checking only <em>seems</em> like it comes with more
costs, when in fact they’re the same costs, paid earlier. When there are
net-new costs, there are ways to minimize them, and runtime-checked type
annotations come with some key benefits that makes working in a
gradually-typed codebase easier.</p>
<!-- more -->
<h1 id="quick-background">Quick background</h1>
<p>I’ve written this post mostly agnostic of language, but obviously
most of my experience comes from working on <a
href="https://sorbet.org">Sorbet</a> for Ruby. For context, adding a
type annotation to a method in Sorbet not only instructs the type system
to assume the method has that type, but also wraps the method at runtime
in a shim method that asserts arguments and return values have the
stated values on each call:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ruby numberLines hl-2 hl-10 hl-12"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># Given a `sig` like this:</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>sig <span class="kw">{</span>params(<span class="wa">x: </span><span class="dt">Integer</span>)<span class="at">.returns</span>(<span class="dt">String</span>)<span class="kw">}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="cf">def</span> integer_to_string(x)</span>
<span id="cb1-4"><a href="#cb1-4"></a>  x<span class="at">.to_s</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="cf">end</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co"># At runtime, `sig` acts like a decorator,</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co"># making the method behave like this:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="cf">def</span> integer_to_string(x)</span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="fu">raise</span> <span class="dt">TypeError</span><span class="at">.new</span>(<span class="st">&quot;Wrong type&quot;</span>) <span class="cf">unless</span> x<span class="at">.is_a?</span>(<span class="dt">Integer</span>)</span>
<span id="cb1-11"><a href="#cb1-11"></a>  result <span class="kw">=</span> x<span class="at">.to_s</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>  <span class="fu">raise</span> <span class="dt">TypeError</span><span class="at">.new</span>(<span class="st">&quot;Wrong type&quot;</span>) <span class="cf">unless</span> result<span class="at">.is_a?</span>(<span class="dt">String</span>)</span>
<span id="cb1-13"><a href="#cb1-13"></a>  result</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="cf">end</span></span></code></pre></div>
<p>If this is new to you, feel free to read any of these Sorbet
docs:</p>
<ul>
<li><a href="https://sorbet.org/docs/runtime">Enabling Runtime Checks
→</a></li>
<li><a href="https://sorbet.org/docs/tconfiguration">Runtime
Configuration →</a></li>
<li><a href="https://sorbet.org/docs/gradual">Gradual Type Checking
→</a></li>
</ul>
<p>With that out of the way, here’s how I respond to the most common
complaints I hear about this choice.</p>
<h1 id="complaints-about-checking-types-at-runtime">Complaints about
checking types at runtime</h1>
<p>…and why I think they miss the mark.</p>
<h2
id="its-riskier-because-a-types-only-change-might-break-the-code">“It’s
riskier, because a types-only change might break the code”</h2>
<blockquote>
<p>Absent runtime-checked types, the code would have worked—why should
adding a type annotation make the code break?</p>
</blockquote>
<p>My claim: it’s just as risky to program against types that are subtly
wrong.<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="marginnote">Remember: in a <a
href="https://sorbet.org/docs/gradual">gradual type system</a>, the
existence of types like <a
href="https://sorbet.org/docs/untyped"><code>T.untyped</code></a> mean
that the static types can lie at any point in the program.<br />
<br />
</span></span> Runtime-checked type annotations incur the risk early and
sharply, sure. But when the types are subtly wrong, every change is
risky, even small ones like adding this <code>if</code> condition and
print statement:</p>
<figure class="left-align-caption">
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource ruby numberLines hl-3 hl-4 hl-5"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1"></a>sig <span class="kw">{</span>params(<span class="wa">params: </span><span class="dt">Params</span>, <span class="wa">merchant: </span><span class="dt">Merchant</span>)<span class="at">.void</span><span class="kw">}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">def</span> handle_request(params, merchant)</span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="cf">if</span> params<span class="at">.something_unlikely?</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="fu">puts</span>(<span class="st">&quot;Processing unlikely request for merchant=</span><span class="sc">#{</span>merchant<span class="at">.id</span><span class="sc">}</span><span class="st">&quot;</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="cf">end</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>  handle_request_impl(params, merchant)</span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="cf">end</span></span></code></pre></div>
<figcaption>
<a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams%28params%3A%20Params%2C%20merchant%3A%20Merchant%29.void%7D%0Adef%20handle_request%28params%2C%20merchant%29%0A%20%20if%20params.something_unlikely%3F%0A%20%20%20%20puts%28%22Processing%20unlikely%20request%20for%20merchant%3D%23%7Bmerchant.id%7D%22%29%0A%20%20end%0A%0A%20%20handle_request_impl%28params%2C%20merchant%29%0Aend%0A%0A%0A%23%20---%20support%20code%20---%0A%0Asig%20%7Bparams%28params%3A%20Params%2C%20merchant%3A%20Merchant%29.void%7D%0Adef%20handle_request_impl%28params%2C%20merchant%29%0A%20%20%23%20...%0Aend%0A%0Aclass%20Params%0A%20%20extend%20T%3A%3ASig%0A%20%20%23%20...%0A%0A%20%20sig%20%7Breturns%28T%3A%3ABoolean%29%7D%0A%20%20def%20something_unlikely%3F%3B%20%5Btrue%2C%20false%5D.sample%3B%20end%0Aend%0A%0Aclass%20Merchant%20%3C%20T%3A%3AStruct%0A%20%20const%20%3Aid%2C%20String%0A%20%20%23%20...%0Aend">View
on sorbet.run →</a>
</figcaption>
</figure>
<p>It’s all too easy for some <code>handle_request</code> call site to
accidentally pass <code>nil</code> for <code>merchant</code> by way of
some untyped piece of code. Absent runtime type checking, adding this
<code>if</code> statement might not immediately cause a problem! But the
bug will be there, and the first time <code>something_unlikely?</code>
happens the code will crash on the call to <code>merchant.id</code>.</p>
<p>Runtime type checking makes broken assumptions fail early and
loudly—this is not the same thing as more risky. In fact, most systems
are <strong>better</strong> at absorbing early, loud breakages!
Automated alerting quickly climbs above some threshold, stack traces
immediately point to which assumption was violated, and rolling back is
easy because hundreds of changes haven’t arrived in the mean time.</p>
<h2 id="its-more-work">“It’s more work”</h2>
<blockquote>
<p>In addition to fixing the static type errors, I have to fix the test
failures and roll out the change.</p>
</blockquote>
<p>I think this is fair: it can be tricky to get tests to pass,
especially if the code is making heavy use of mocks. But again I’ll say:
I think the effort mostly the same, just front-loaded.</p>
<p>In my experience, overuse of mocks make tests brittle and tends to
cause problems when refactoring code, <strong>regardless</strong> of
whether types are checked at runtime. Checking types at runtime is a bit
of a forcing function to move away from mocks and other hard-to-type
constructs, which is a force multiplier on future productivity. In my
head it looks something like this:</p>
<div class="left-align-caption">
<figure>
<img src="/assets/img/light/runtime-types-effort-reward.png"
alt="How much effort it takes to change a piece of code, over time" />
<figcaption aria-hidden="true">How much effort it takes to change a
piece of code, over time</figcaption>
</figure>
<figure>
<img src="/assets/img/dark/runtime-types-effort-reward.png"
alt="How much effort it takes to change a piece of code, over time" />
<figcaption aria-hidden="true">How much effort it takes to change a
piece of code, over time</figcaption>
</figure>
</div>
<p>Getting the runtime type checks to pass for the first time adds a
lot<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="marginnote">It’s not <em>always</em> a lot—sometimes it’s only
marginally more work, and sometimes the runtime checks pay for
themselves in the change they’re added if they happen to help as a
debugging aide to get the tests passing.<br />
<br />
</span></span> of extra effort, but that extra effort makes the next
change and the change after that a lot easier. Even well into the
future, legacy code with runtime-checked types remains easier and less
scary to change. Locking in the runtime-checked annotations early means
that when going back to change 3-year-old code, these types are almost
<em>guaranteed</em> to be trustworthy, making for far less work hunting
down the <em>truly correct</em> types when modifying legacy code.</p>
<h2 id="runtime-checks-slow-the-code-down">“Runtime checks slow the code
down”</h2>
<blockquote>
<p>I can’t spare any performance to pay for the cost of runtime
checking.</p>
</blockquote>
<p>Slowing down the code is an unavoidable cost of runtime-checked
annotations, no matter how you do the accounting. In cases where every
millisecond matters, sure, you probably don’t want runtime checking. But
I want to qualify this with a couple of points.</p>
<ol type="1">
<li><p>Not every use case needs to shave off every millisecond. Some
applications can absorb a small slowdown in exchange for the benefits
that runtime-checked annotations bring.</p></li>
<li><p>It really is milliseconds. At work, we have runtime type checking
turned on even for our most performance-sensitive request paths, and the
slowdown from runtime type checking amounts to about 5%. To put that in
perspective, that’s the difference between a request taking 1,000 ms vs
952 ms.</p></li>
<li><p>If it happens to be <em>more</em> than milliseconds for your
workload, the overhead usually blames to a handful of hot methods. In
Ruby, at least, there are powerful, low-overhead profilers which can to
expose the slowest methods, at which point it’s easy to opt those hot
methods out of runtime type checking. This strikes a nice balance
between performance where it matters and correctness where performance
matters less.</p></li>
<li><p>Runtime-checked annotations actually allow the Sorbet Compiler to
<em>speed up</em> code.<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="marginnote">This point is Sorbet-specific, but it’s worth noting
that all VMs for dynamically typed languages have to do runtime type
checks constantly, so there’s no reason why it has to be.<br />
<br />
</span></span> I wrote about this effect before: <a
href="/types-make-array-access-faster/">Types Make Array Access
Faster</a></p>
<p>The Sorbet Compiler is an ahead-of-time compiler, which makes it easy
to leverage type annotations in the compiled code. None of the Ruby JIT
compilers currently take advantage of type annotations, but also I don’t
think that’s a hard constraint—just something no one has looked into
yet.</p></li>
</ol>
<p>So while runtime-checked annotations are a (minor) cost today, in the
future they could actually be a benefit. Of course, this is no
consolation for people who have to make their code as fast as possible
right now, which is again why I think it’s one of the few fair
complaints.</p>
<h2 id="runtime-checks-are-strange">“Runtime checks are strange”</h2>
<blockquote>
<p>Why can’t Sorbet just be more like TypeScript?</p>
</blockquote>
<p>I get this one a lot, probably because of how popular TypeScript and
Flow are for JavaScript. But in fact TypeScript and Flow are in the
minority: Hack, PHP, MyPy, Typed Racket, Typed Clojure, Raku, and of
course Sorbet are all gradual type systems all have some form of runtime
type checking available.</p>
<p>Even among TypeScript programmers, some are envious of runtime-backed
types (<a
href="https://effectivetypescript.com/2022/12/25/christmas/#A-canonical-types-%E2%86%92-runtime-path">example
1</a>, <a href="https://jew.ski/article/runtime-type-checking/">example
2</a>).</p>
<p>(I think there are other circumstances explaining why JavaScript type
systems specifically chose to elide runtime checks, but that’s probably
best left to another post.)</p>
<p>Over time, the initial strangeness simply wears off.</p>
<h1 id="unique-benefits-from-runtime-typing">Unique benefits from
runtime typing</h1>
<p>In addition to the benefits mentioned above (like how changing legacy
code is less risky and less work), runtime-checked type annotations come
with some unique benefits.</p>
<h2 id="it-enables-dead-code-checking">It enables dead code
checking</h2>
<p>Sorbet flags dead code statically. For example:</p>
<figure class="left-align-caption">
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource ruby numberLines hl-4 hl-5"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1"></a>sig <span class="kw">{</span>params(<span class="wa">x: </span><span class="dt">Integer</span>)<span class="at">.void</span><span class="kw">}</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="cf">def</span> example(x)</span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="cf">if</span><span class="kw"> !</span>x<span class="at">.is_a?</span>(<span class="dt">Integer</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="fu">puts</span>(x)</span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="co"># ^^^^^^^ error: This code is unreachable</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>  <span class="cf">end</span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="cf">end</span></span></code></pre></div>
<figcaption>
<a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams%28x%3A%20Integer%29.void%7D%0Adef%20example%28x%29%0A%20%20if%20!x.is_a%3F%28Integer%29%0A%20%20%20%20puts%28x%29%0A%20%20end%0Aend">→
View on sorbet.run</a>
</figcaption>
</figure>
<p>Sorbet flags that the highlighted line is unreachable, but it’s only
safe for Sorbet to report an error here (not just a warning) by
depending on the runtime checks. Absent runtime checks, any untyped code
could circumvent the type system and trip this line. Static-only type
systems like TypeScript opt to <a
href="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAKYCcCmA7ALtA3gXwFCkhgGEALASxABNokAPNVSmeZdLPXAMwFcVg0yAexQ1aYALYAHEEgAUtAFzRSFSgEosuaNuhlO0WQEJ5ulBDRg+SQfpao0ajZi07XwYREEyAdCEEBzeTUAbhdXbRkMAE8lFCQANyQEaABeaFpQ1zxsIA">not
report dead code errors</a> on similar snippets for this reason.</p>
<p>Runtime-checked type annotations enable promoting dead code problems
from warnings to errors, which means that problems like these actually
get caught and addressed.</p>
<h2 id="the-implementation-matches-the-api">The implementation matches
the API</h2>
<p>Refactoring in a large codebase is a constant struggle with <a
href="https://www.hyrumslaw.com/">Hyrum’s Law</a>—someone, somewhere is
depending on your implementation, not your API. Runtime checking ensures
that the types are not only a part of the API but also the
implementation, so there aren’t as many subtle gaps for people to depend
on.</p>
<p>For example, runtime checking means that a method’s callers don’t
rely on the method silently accepting a wider type than declared (like
our <code>handle_request</code> example from earlier). It also means
that people building an abstraction can use <a
href="https://sorbet.org/docs/sealed">sealed classes</a>, <a
href="https://sorbet.org/docs/final#final-methods">final classes</a>,
and <a
href="https://sorbet.org/docs/final#final-classes-and-modules">final
methods</a> to limit how their abstractions are used, ensuring that
people aren’t secretly violating those contracts at runtime.</p>
<h1 id="testimonials-and-wrapping-up">Testimonials and wrapping up</h1>
<p>Some of the most prolific Sorbet users I know share my views. To
share some quotes:</p>
<blockquote>
<p>In a codebase that is 100% typed, I don’t think runtime checks are
necessary. But because we are not in that ideal world (and partial
typing is a great selling point for Sorbet) I actually love the runtime
checks.</p>
<p>— <a href="https://marianosimone.com/">Mariano Simone</a></p>
</blockquote>
<blockquote>
<p>As much as I like TypeScript, Sorbet has the better trade-offs to me:
When I read Sorbet code, I know it says something about production
behavior. With Typescript code, I know it says basically nothing.</p>
<p>— <a href="https://jew.ski/">Chris Andrejewski</a>, in <a
href="https://jew.ski/article/runtime-type-checking/">Runtime type
checking</a></p>
</blockquote>
<blockquote>
<p>I love runtime-checked types. When they fail, they almost always
indicate a bug I’d like to know about. They add a layer of safety to my
changes and enable me to improve the structure of the code rather than
just type it, since the types lead to improvements to method boundaries,
etc.</p>
<p>— <a href="https://jvilk.com/">John Vilk</a></p>
</blockquote>
<p>Overall, while runtime checking comes with costs, I think these costs
are usually either overstated or misunderstood. The benefits that come
with runtime checking are unique and powerful, and in almost every case
make up for the costs. With time, the initial strangeness of
runtime-checked type annotations turns into a powerful programming
aide.</p>
<hr />
<h1 id="appendix">Appendix</h1>
<p>One disclaimer: I think that the tradeoffs change slightly for
applications versus libraries. I’ve written this post from the
standpoint of applications, because it’s the one I’m the most familiar
with. I would love to say more about libraries too, but I need more time
to gather thoughts there. (As always, if you want to share your takes
I’m happy to hear them.)</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#types">types</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

