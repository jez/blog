<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2020-09-11 19:36:14 -0400">
<meta name="description" content="I take another look at how the Sorbet Compiler handles optimizing certain kinds of typed code patterns.">
<title>Another Look at Typed Array Access – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Another Look at Typed Array Access</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2020-09-11 19:36:14 -0400">September 11, 2020</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">← Return home</a><br>
</nav>

<main>
<blockquote>
<p><strong>Disclaimer</strong>: this post was first drafted as a
Stripe-internal email. On December 10, 2022 I republished it here,
largely unchanged from the original. See <a
href="/old-compiler-notes/">Some Old Sorbet Compiler Notes</a> for more.
The Sorbet Compiler is still largely an experimental project: this post
is available purely for curiosity’s sake.</p>
<p>Any benchmark numbers included in this post are intended to be
educational about how the Sorbet Compiler approaches speeding up code.
They should not be taken as representative or predictive of any
real-world workload, and are likely out-of-date with respect to
improvements that have been made since this post originally
appeared.</p>
</blockquote>
<p>Last week in <a href="/types-make-array-access-faster">Types Make
Array Access Faster</a> we compared the Ruby VM’s performance on array
accesses with the Sorbet Compiler’s performance on array accesses, as an
example of how making types available to the Sorbet Compiler let it
speed up code. The snippet under scrutiny was basically this
operation:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>xs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span></code></pre></div>
<p>but repeated many (10M) times to make the performance difference
obvious.</p>
<p>The data we collected looked like this:</p>
<div class="wide extra-wide">
<table style="width:98%;">
<colgroup>
<col style="width: 25%" />
<col style="width: 13%" />
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 14%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">benchmark</th>
<th style="text-align: right;">interpreted</th>
<th style="text-align: right;">compiled</th>
<th style="text-align: right;">interpreted,<br />
minus while</th>
<th style="text-align: right;">compiled,<br />
minus while</th>
<th style="text-align: right;">compiler speedup,<br />
w/o while</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/while_10_000_000.rb">while_10_000_000.rb</a></td>
<td style="text-align: right;">0.205s</td>
<td style="text-align: right;">0.048s</td>
<td style="text-align: right;">—</td>
<td style="text-align: right;">—</td>
<td style="text-align: right;">—</td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/untyped_array_aref.rb">untyped_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.174s</td>
<td style="text-align: right;">0.077s</td>
<td style="text-align: right;">0.126s</td>
<td style="text-align: right;">0.61x</td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/typed_array_aref.rb">typed_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.061s</td>
<td style="text-align: right;">0.077s</td>
<td style="text-align: right;">0.013s</td>
<td style="text-align: right;">5.92x</td>
</tr>
</tbody>
</table>
</div>
<p>And our ultimate conclusion was:</p>
<blockquote>
<p>With type information, Sorbet-compiled code is even faster than both
the interpreted code and the compiled but untyped code.</p>
</blockquote>
<p>But there was an interesting caveat along the way:</p>
<blockquote>
<p>The array access operation is actually slower than the Ruby VM if
Sorbet doesn’t have type information (0.61x speedup is less than 1, so
it’s a slowdown).</p>
</blockquote>
<p>The idea was that for our plain <code>xs[0]</code> program, the
compiler was actually <strong>slower</strong> than the interpreter.</p>
<p>Why was the compiler slower?</p>
<p>It turns out that array access is one of the operations the Ruby VM
is already pretty good at, because it’s special cased. We can check this
looking at the <a href="https://en.wikipedia.org/wiki/Bytecode">bytecode
instructions</a> that the Ruby VM uses to evaluate an array access:</p>
<pre class="plain"><code>❯ ruby --dump=insns -e &#39;xs = []; xs[0]&#39;
== disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,14)&gt; (catch: FALSE)
local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
[ 1] xs@0
0000 newarray                     0                                   (   1)[Li]
0002 setlocal_WC_0                xs@0
0004 getlocal_WC_0                xs@0
0006 putobject_INT2FIX_0_
0007 opt_aref                     &lt;callinfo!mid:[], argc:1, ARGS_SIMPLE&gt;, &lt;callcache&gt;
0010 leave</code></pre>
<p>Here’s how to read this output:</p>
<ul>
<li><p>We used the special <code>--dump=insns</code> flag to the
<code>ruby</code> command line. You can try this at home!</p></li>
<li><p>Theres some stuff we don’t need on the first few lines, and then
the bytecode instructions start with the line reading
<code>0000</code>.</p></li>
<li><p>The actual instruction that corresponds to the <code>xs[0]</code>
instruction happens at index <code>0007</code>. The name of the
instruction is <code>opt_aref</code>.</p></li>
</ul>
<p>That’s interesting! Instead of treating array access like any other
method call,<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">Did you know that square brackets are <a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20MyClass%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20sig%20%7Bparams%28arg0%3A%20Integer%29.returns%28String%29%7D%0A%20%20def%20%5B%5D%28arg0%29%0A%20%20%20%20arg0.to_s%0A%20%20end%0Aend%0A%0Ax%20%3D%20MyClass.new%0AT.reveal_type%28x%5B0%5D%29%20%23%20!!">just
a method call</a> in Ruby?<br />
<br />
</span></span> it treats it as a special, optimized instruction called
<code>opt_aref</code>. Checking <a
href="https://github.com/ruby/ruby/blob/a0c7c23c9cec0d0ffcba012279cd652d28ad5bf3/vm_insnhelper.c#L4523-L4549">the
implementation of that instruction</a>, we find that the optimization
only works if the method receiver (<code>xs</code> in this case) is
<strong>exactly</strong> an instance of the <code>Array</code> or
<code>Hash</code> class.</p>
<p>In other words, it’s easy to defeat this optimization by subclassing
<code>Array</code>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">MyArray</span> <span class="kw">&lt;</span> <span class="dt">Array</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>xs <span class="kw">=</span> <span class="dt">MyArray</span><span class="at">.new</span>(<span class="kw">[</span><span class="dv">2</span><span class="kw">]</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>xs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span></code></pre></div>
<p>In this case, since <code>xs</code> is not exactly <code>Array</code>
or <code>Hash</code> anymore, the optimization won’t apply, and <a
href="https://github.com/ruby/ruby/blob/a0c7c23c9cec0d0ffcba012279cd652d28ad5bf3/insns.def#L1305-L1309">the
Ruby VM falls back</a> to calling a method named <code>[]</code> on
<code>xs</code> with argument <code>0</code>.</p>
<p>We can see the effect of this by writing another Sorbet compiler
benchmark, and adding it to our table:</p>
<div class="wide extra-wide">
<table style="width:98%;">
<colgroup>
<col style="width: 31%" />
<col style="width: 11%" />
<col style="width: 10%" />
<col style="width: 13%" />
<col style="width: 12%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">benchmark</th>
<th style="text-align: right;">interpreted</th>
<th style="text-align: right;">compiled</th>
<th style="text-align: right;">interpreted,<br />
minus while</th>
<th style="text-align: right;">compiled,<br />
minus while</th>
<th style="text-align: right;">compiler speedup,<br />
w/o while</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/while_10_000_000.rb">while_10_000_000.rb</a></td>
<td style="text-align: right;">0.205s</td>
<td style="text-align: right;">0.048s</td>
<td style="text-align: right;">—</td>
<td style="text-align: right;">—</td>
<td style="text-align: right;">—</td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/untyped_array_aref.rb">untyped_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.174s</td>
<td style="text-align: right;">0.077s</td>
<td style="text-align: right;">0.126s</td>
<td style="text-align: right;">0.61x</td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/typed_array_aref.rb">typed_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.061s</td>
<td style="text-align: right;">0.077s</td>
<td style="text-align: right;">0.013s</td>
<td style="text-align: right;">5.92x</td>
</tr>
<tr>
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/untyped_array_subclass_aref.rb">untyped_array_subclass_aref.rb</a></td>
<td style="text-align: right;">0.388s</td>
<td style="text-align: right;">0.172s</td>
<td style="text-align: right;">0.183s</td>
<td style="text-align: right;">0.124s</td>
<td style="text-align: right;">1.48x</td>
</tr>
</tbody>
</table>
</div>
<p>By changing the untyped <code>Array</code> to an untyped subclass of
<code>Array</code>, the interpreter slows down<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote"><strong>Editing note</strong>: These numbers are
unchanged from when I first measured in September 2020. They do not
necessarily reflect the Sorbet Compiler’s current performance.<br />
<br />
</span></span> an extra 0.106ms, but our compiled version doesn’t care
whether it was the <code>Array</code> case or <code>MyArray</code> case,
because they’re both untyped.</p>
<p>Now that the Ruby VM hasn’t effectively special cased our benchmark,
the compiler starts to shine! This is another reason why we’re really
optimistic about the impact of the compiler. Our initial plans were to
speed up typed code, and count on other teams adding types everywhere.
While adding types <strong>definitely</strong> helps (look at that 5.92x
speedup!), the compiler can still speed up certain kinds of untyped
code, too.</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet-compiler">sorbet-compiler</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

