<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2020-08-28 21:21:30 -0400">
<meta name="description" content="A short discussion of how the Sorbet Compiler is able to use type information to perform certain operations faster than the Ruby VM can on its own.">
<title>Types Make Array Access Faster – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Types Make Array Access Faster</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2020-08-28 21:21:30 -0400">August 28, 2020</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">← Return home</a><br>
</nav>

<main>
<blockquote>
<p><strong>Disclaimer</strong>: this post was first drafted as a
Stripe-internal email. On December 10, 2022 I republished it here,
largely unchanged from the original. See <a
href="/old-compiler-notes/">Some Old Sorbet Compiler Notes</a> for more.
The Sorbet Compiler is still largely an experimental project: this post
is available purely for curiosity’s sake.</p>
<p>Any benchmark numbers included in this post are intended to be
educational about how the Sorbet Compiler approaches speeding up code.
They should not be taken as representative or predictive of any
real-world workload, and are likely out-of-date with respect to
improvements that have been made since this post originally
appeared.</p>
</blockquote>
<p>I was looking at improving the performance of the Sorbet Compiler’s
generated code on Stripe’s feature flag library this week. I was trying
to diagnose which parts of the compiled code are faster and slower.
Specifically, there were some profiler results that that seemed to
suggest the <code>x[y]</code> operation for hashes and arrays (the Ruby
VM calls this operation <code>aref</code>) might be a problem:</p>
<!-- more -->
<div class="sourceCode" id="cb1"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>xs <span class="kw">=</span> <span class="kw">[</span><span class="dv">123</span><span class="kw">]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">puts</span> xs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span></code></pre></div>
<p>To isolate for sure whether this was a problem or not, we wrote a
benchmark. It turns out that we misinterpreted the <code>perf</code>
profile! Array access is much faster in Sorbet:</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">benchmark</th>
<th style="text-align: right;">interpreted</th>
<th style="text-align: right;">compiled</th>
<th style="text-align: right;">speedup vs interpreted</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/typed_array_aref.rb">typed_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.061s</td>
<td style="text-align: right;">4.62x</td>
</tr>
</tbody>
</table>
<p>Here’s the full benchmark:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>xs <span class="kw">=</span> T<span class="at">.let</span>(<span class="kw">[</span><span class="dv">123</span><span class="kw">]</span>, T<span class="kw">::</span><span class="dt">Array</span><span class="kw">[</span><span class="dt">Integer</span><span class="kw">]</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>i <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="kw">&lt;</span> <span class="dv">10_000_000</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  xs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  i <span class="kw">+=</span> <span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="fu">puts</span> xs<span class="kw">[</span><span class="dv">0</span><span class="kw">]</span></span></code></pre></div>
<p>But it turns out that the story doesn’t end there. I re-ran the
benchmark with some slight modifications:</p>
<ul>
<li>the same test, but with an empty <code>while</code> loop body</li>
<li>the same test, but marking the initial assignment to <code>xs</code>
as untyped</li>
</ul>
<p>With these benchmarks, we tease apart how much of the speedup is
explained by various parts of the compiled code. Namely, how much is
explained by “the Sorbet Compiler just does loops faster” and how much
is explained by knowing a type statically:</p>
<div class="wide extra-wide">
<table style="width:98%;">
<colgroup>
<col style="width: 25%" />
<col style="width: 13%" />
<col style="width: 11%" />
<col style="width: 15%" />
<col style="width: 14%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">benchmark</th>
<th style="text-align: right;">interpreted</th>
<th style="text-align: right;">compiled</th>
<th style="text-align: right;">interpreted,<br />
minus while</th>
<th style="text-align: right;">compiled,<br />
minus while</th>
<th style="text-align: right;">compiler speedup,<br />
w/o while</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/while_10_000_000.rb">while_10_000_000.rb</a></td>
<td style="text-align: right;">0.205s</td>
<td style="text-align: right;">0.048s</td>
<td style="text-align: right;">—</td>
<td style="text-align: right;">—</td>
<td style="text-align: right;">—</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/untyped_array_aref.rb">untyped_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.174s</td>
<td style="text-align: right;">0.077s</td>
<td style="text-align: right;">0.126s</td>
<td style="text-align: right;">0.61x</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/typed_array_aref.rb">typed_array_aref.rb</a></td>
<td style="text-align: right;">0.282s</td>
<td style="text-align: right;">0.061s</td>
<td style="text-align: right;">0.077s</td>
<td style="text-align: right;">0.013s</td>
<td style="text-align: right;">5.92x</td>
</tr>
</tbody>
</table>
</div>
<p>(I’ve linked to the specific benchmarks in the Sorbet compiler
codebase if you want to see them.)</p>
<p>What we see in this table is that Sorbet-compiled Ruby is still
“faster” in absolute terms when the type of <code>xs</code> isn’t known
(untyped_array_aref.rb, 0.282s vs 0.174s). But in fact, most of this
absolute difference is because the compiled <code>while</code> loop was
faster!</p>
<p>If we subtract the compiled <code>while</code> loop timings from the
compiled times, and the interpreted <code>while</code> loop timings from
the interpreted timings, what’s left is how much time was actually spent
in each benchmark doing the array access operation.</p>
<p>After doing those subtractions and computing the speedups, we see two
things:<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote"><strong>Editing note</strong>: These numbers are
unchanged from when I first measured in August 2020. They do not
necessarily reflect the Sorbet Compiler’s current performance.<br />
<br />
</span></span></p>
<ul>
<li><p>The array access operation is actually slower than the Ruby VM if
Sorbet doesn’t have type information (0.61x speedup is less than 1, so
it’s a slowdown). As it turns out, the Ruby VM has special optimizations
for <code>xs[0]</code> when <code>xs</code> is an
<code>Array</code>.</p></li>
<li><p>With type information, Sorbet-compiled code is even faster than
both the interpreted code and the compiled but untyped code.
Specifically, the compiler only spent <code>0.013s</code> computing the
array access given type information, vs the interpreter spent
<code>0.077s</code>, and the compiled but untyped version took even more
at <code>0.126s</code>.</p></li>
</ul>
<p>This means that with types, the <code>Array</code> index operation
compiled by Sorbet is (currently) 5.92x faster than the interpreter! I
say currently because: the Sorbet compiler is very much not finished. It
could get faster or slower at any time.</p>
<p>Hopefully this gives a glimpse of why we’re confident the compiler
will have an impact. Certain Ruby features are type-agnostic, and can be
sped up even if code is untyped (like <code>while</code> loops). Adding
types (which are exceedingly common in Stripe’s codebase at this point)
has the potential to make code even faster.</p>
<p>The examples in this post are obviously contrived (no one is writing
<code>while</code> loops like this in Stripe’s codebase) but the idea is
that if Sorbet can showcase speedups on any individual part of a typed
Ruby program, than all you have to do to do to get fast code is add a
<code># compiled: true</code> comment to the top of a file and Sorbet
will make every individual part faster, and the effects will compound.
Performance for free!</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet-compiler">sorbet-compiler</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

