<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2024-01-01 19:25:23 -0500">
<meta name="description" content="Abstract singleton class methods do not belong in a well-behaved type system. Sorbet allows them anyways, which causes problems. Here's why they're bad and what to do instead.
">
<title>Abstract singleton class methods are an abomination ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Abstract singleton class methods are an abomination</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2024-01-01 19:25:23 -0500">January 1, 2024</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">‚äï</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#what-should-i-use-instead"
  id="toc-what-should-i-use-instead">What should I use instead?</a></li>
  <li><a href="#what-do-other-languages-do"
  id="toc-what-do-other-languages-do">What do other languages
  do?</a></li>
  <li><a href="#why-have-abstract-singleton-class-methods-at-all"
  id="toc-why-have-abstract-singleton-class-methods-at-all">Why have
  abstract singleton class methods at all?</a></li>
  <li><a href="#further-reading" id="toc-further-reading">Further
  reading</a></li>
  </ul>
</nav>

<main>
<p>Sometimes I get a Sorbet question like this, and it brings me nothing
but shame:</p>
<blockquote>
<p>Is there a way to specify that a method accepts a
<code>T.class_of(Foo)</code> where <code>Foo</code> is an abstract
class, but all callers to this function must pass non-abstract
classes?</p>
</blockquote>
<p>It‚Äôs one of Sorbet‚Äôs original sins rearing its head: choosing to
allow abstract singleton class methods. The choice is an
<strong>unsound</strong> compromise, made to allow easier adoption in
existing Ruby codebases.</p>
<p>If you haven‚Äôt come across it before, the problem with abstract
singleton class methods boils down to this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ruby numberLines hl-3 hl-14 hl-18"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1"></a><span class="cf">class</span> <span class="dt">AbstractParent</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  abstract!</span>
<span id="cb1-3"><a href="#cb1-3"></a>  sig <span class="kw">{</span> abstract<span class="at">.void</span> <span class="kw">}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="cf">def</span> <span class="dv">self</span><span class="at">.foo</span>; <span class="cf">end</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="cf">end</span></span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="cf">class</span> <span class="dt">ConcreteChild</span> <span class="kw">&lt;</span> <span class="dt">AbstractParent</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  sig <span class="kw">{</span> override<span class="at">.void</span> <span class="kw">}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="cf">def</span> <span class="dv">self</span><span class="at">.foo</span> <span class="kw">=</span> <span class="fu">puts</span>(<span class="st">&quot;hello!&quot;</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="cf">end</span></span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>sig <span class="kw">{</span> params(<span class="wa">klass: </span>T<span class="at">.class_of</span>(<span class="dt">AbstractParent</span>))<span class="at">.void</span> <span class="kw">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="cf">def</span> example(klass)</span>
<span id="cb1-14"><a href="#cb1-14"></a>  klass<span class="at">.foo</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">end</span></span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>example(<span class="dt">ConcreteChild</span>)  <span class="co"># ‚úÖ</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>example(<span class="dt">AbstractParent</span>) <span class="co"># üí• call to abstract method foo</span></span></code></pre></div>
<p>The call to <code>foo</code> on line 14 expects <code>klass</code> to
be an instance of a concrete class, so all its methods (including
<code>foo</code>) have implementations. But at runtime, the object
<code>AbstractParent</code> is <strong>not</strong> an instance of a
concrete class.<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="marginnote">Specifically: it‚Äôs the singleton instance of a
singleton class which Sorbet allowed defining abstract methods on.<br />
<br />
</span></span> The method <code>foo</code> is not implemented on the
<code>AbstractParent</code> object, so the call raises unexpectedly at
runtime despite Sorbet reporting no static error.</p>
<p>In every sane language, making a type abstract is
<strong>supposed</strong> to prevent this problem! That is, if
<code>A</code> is abstract, then having <code>x</code> with type
<code>A</code> should necessarily imply that whatever <code>x</code> is
bound to at runtime is an instance of a concrete subclass of
<code>A</code>. Abstract classes should not be instantiable!</p>
<p>For non-singleton classes, Sorbet enforces this guarantee: marking a
class <code>abstract!</code> hijacks the <code>self.new</code> method at
runtime to make it raise an exception, which prevents instantiating
abstract classes.<span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="marginnote">‚Ä¶ ignoring Ruby trickery which well-behaved programs
won‚Äôt use.<br />
<br />
</span></span></p>
<p>But for <em>singleton classes</em>, there‚Äôs no way to prevent a
class‚Äôs singleton class from being created‚Äîthe act of declaring a class
automatically creates the singleton class. Knowing this, Sorbet should
never consider a singleton class to be abstract, preventing the
declaration of abstract singleton class methods. <strong>It does
anyway</strong>, which is how we ended up with this mess.</p>
<p><strong>Strive to avoid designs that depend on abstract singleton
class methods.</strong><br />
Sorbet won‚Äôt stop you, so you‚Äôll have to stop yourself.</p>
<h1 id="what-should-i-use-instead">What should I use instead?</h1>
<p>There are some alternatives to abstract singleton class methods. They
all involve a certain amount of refactoring, and there isn‚Äôt always a
best one. The options:</p>
<ol type="1">
<li><p>Define an interface or <a
href="https://sorbet.org/docs/abstract">abstract module</a>, declare the
abstract method on it, and <code>extend</code> the interface into the
concrete classes. Ideally: replace the abstract parent class with this
interface entirely.</p>
<figure class="left-align-caption">
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource ruby numberLines hl-8 hl-13 hl-19"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1"></a><span class="cf">module</span> <span class="dt">HasFoo</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  abstract!</span>
<span id="cb2-3"><a href="#cb2-3"></a>  sig <span class="kw">{</span> abstract<span class="at">.void</span> <span class="kw">}</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="cf">def</span> foo; <span class="cf">end</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="cf">end</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="cf">class</span> <span class="dt">ConcreteChild</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  <span class="fu">extend</span> <span class="dt">HasFoo</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  sig <span class="kw">{</span> override<span class="at">.void</span> <span class="kw">}</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>  <span class="cf">def</span> <span class="dv">self</span><span class="at">.foo</span> <span class="kw">=</span> <span class="fu">puts</span>(<span class="st">&quot;hello!&quot;</span>)</span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="cf">end</span></span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a>sig <span class="kw">{</span> params(<span class="wa">klass: </span><span class="dt">HasFoo</span>) <span class="kw">}</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="cf">def</span> example(klass)</span>
<span id="cb2-15"><a href="#cb2-15"></a>  klass<span class="at">.foo</span></span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="cf">end</span></span>
<span id="cb2-17"><a href="#cb2-17"></a></span>
<span id="cb2-18"><a href="#cb2-18"></a>example(<span class="dt">ConcreteChild</span>)  <span class="co"># ‚úÖ</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>example(<span class="dt">HasFoo</span>)         <span class="co"># ‚ùå static type error prevents this</span></span></code></pre></div>
<figcaption>
<p><a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20Module%0A%20%20include%20T%3A%3ASig%0A%20%20include%20T%3A%3AHelpers%0Aend%0A%0Amodule%20HasFoo%0A%20%20abstract!%0A%20%20sig%20%7B%20abstract.void%20%7D%0A%20%20def%20foo%3B%20end%0Aend%0A%0Aclass%20ConcreteChild%0A%20%20extend%20HasFoo%0A%20%20sig%20%7B%20override.void%20%7D%0A%20%20def%20self.foo%20%3D%20puts%28%22hello!%22%29%0Aend%0A%0Asig%20%7B%20params%28klass%3A%20HasFoo%29.void%20%7D%0Adef%20example%28klass%29%0A%20%20klass.foo%0Aend%0A%0Aexample%28ConcreteChild%29%20%20%23%20%E2%9C%85%0Aexample%28HasFoo%29%20%20%20%20%20%20%20%20%20%23%20%E2%9D%8C%20type%20error%20prevents%20calling%20this%0A">View
on sorbet.run ‚Üí</a></p>
</figcaption>
</figure>
<p>Note how <code>example</code> uses <code>HasFoo</code> instead of
<code>T.class_of(AbstractParent)</code>, and how the <code>extend</code>
is in the child class‚Äîthere isn‚Äôt even an abstract parent class
anymore.</p>
<p>This is the best option when a class‚Äôs only abstract methods are
singleton class methods. If you want to look at a <strong>more realistic
example</strong>, there‚Äôs an involved one in <a
href="https://sorbet.org/docs/generics#a-type_template-example">the
Sorbet docs</a>.</p></li>
<li><p>Define the abstract module inside a module that is mixed into
another module using <a
href="https://sorbet.org/docs/abstract#interfaces-and-the-included-hook">mixes_in_class_methods</a>.</p>
<p>This is the best option if a class has <em>both</em> abstract
instance and singleton class methods. It has the same downside as above,
in that it involves refactoring some types.</p>
<p><a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20Module%0A%20%20include%20T%3A%3ASig%0A%20%20include%20T%3A%3AHelpers%0Aend%0A%0Amodule%20AbstractParent%0A%20%20abstract!%0A%20%20sig%20%7B%20abstract.void%20%7D%0A%20%20def%20bar%3B%20end%0A%0A%20%20module%20ClassMethods%0A%20%20%20%20abstract!%0A%20%20%20%20sig%20%7B%20abstract.void%20%7D%0A%20%20%20%20def%20foo%3B%20end%0A%20%20end%0A%20%20mixes_in_class_methods%28ClassMethods%29%0Aend%0A%0AAbstractParentClass%20%3D%20T.type_alias%20do%0A%20%20T.all%28AbstractParent%3A%3AClassMethods%2C%20T%3A%3AClass%5BAbstractParent%5D%29%0Aend%0A%0Aclass%20ConcreteChild%0A%20%20include%20AbstractParent%0A%20%20sig%20%7B%20override.void%20%7D%0A%20%20def%20bar%20%3D%20puts%28%22hello!%22%29%0A%0A%20%20sig%20%7B%20override.void%20%7D%0A%20%20def%20self.foo%20%3D%20puts%28%22hello!%22%29%0Aend%0A%0Asig%20%7B%20params%28klass%3A%20AbstractParentClass%29.void%20%7D%0Adef%20example%28klass%29%0A%20%20klass.foo%0A%20%20obj%20%3D%20klass.new%0A%20%20obj.bar%0Aend%0A">mixes_in_class_methods
example ‚Üí</a></p></li>
<li><p>Make the method <code>overridable</code> instead of
<code>abstract</code>, effectively giving the method a default
implementation.</p>
<p>This option does not need as big of a refactor, because it does not
introduce any new types or interfaces. But there isn‚Äôt always a sensible
default implementation, so sometimes this option doesn‚Äôt it can‚Äôt
.</p></li>
</ol>
<h1 id="what-do-other-languages-do">What do other languages do?</h1>
<p>Basically every other typed language correctly avoids this pitfall.
For example:</p>
<ul>
<li><p>Scala <code>object</code> definitions (analogous to Ruby‚Äôs
singleton classes) cannot have abstract methods, because the object
<em>is</em> instantiated (just like Ruby singleton classes).</p>
<p><a href="https://godbolt.org/z/x4eMrrb7M">Scala example
‚Üí</a></p></li>
<li><p>In Java and C++, the analogue to singleton class methods are
<code>static</code> methods. As the name implies, these methods use <a
href="https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/">static
dispatch instead of dynamic dispatch</a>. Abstract methods are only
useful in combination with dynamic dispatch, so these languages simply
ban <code>abstract static</code> methods.</p>
<p><a href="https://godbolt.org/z/1rr8qxhW7">Java example ‚Üí</a><br />
<a href="https://godbolt.org/z/x114TEs3n">C++ example ‚Üí</a></p></li>
<li><p>Despite also using the <code>static</code> keyword, TypeScript
<code>static</code> methods use <a
href="https://lukasatkinson.de/2016/dynamic-vs-static-dispatch/">dynamic
dispatch</a>. But TypeScript recognizes that the object representing a
class <em>always exists</em> at runtime, so it also bans
<code>static abstract</code> methods.</p>
<p><a
href="https://www.typescriptlang.org/play?#code/IYIwzgLgTsDGEAJYBthjAgguacIAVgoBTAO0QG8AoBBUSGeBSYCAS1gQDMB7HgCgCUALgQA3HmwAmAbioBfIA">TypeScript
example ‚Üí</a></p></li>
</ul>
<p>Of course, in these languages there isn‚Äôt the same <a
href="/inheritance-in-ruby/#wait-why-do-we-care-about-inheriting-both">rich
link</a> between a class and its singleton class, so the comparison to
other languages is a bit shallow.</p>
<h1 id="why-have-abstract-singleton-class-methods-at-all">Why have
abstract singleton class methods at all?</h1>
<p>We noticed a ton of code that looked like this when rolling out
Sorbet in Stripe‚Äôs codebase many years ago:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">class</span> <span class="dt">AbstractParent</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">def</span> <span class="dv">self</span><span class="at">.foo</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">raise</span> <span class="dt">NotImplementedError</span><span class="at">.new</span>(<span class="st">&quot;Missing implementation of foo&quot;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>Allowing existing methods like <code>foo</code> to be abstract at
least requires subclasses to implement them or mark themselves
<code>abstract!</code>. It‚Äôs much better than the alternative above of
just raising hoping that tests discover unimplemented methods.</p>
<p>There‚Äôs an escape hatch for code which chooses to use abstract
singleton class methods (in spite of all their problems). It‚Äôs possible
to manually check whether a class object is abstract before calling the
method:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource ruby numberLines hl-3 hl-10"><code class="sourceCode ruby"><span id="cb4-1"><a href="#cb4-1"></a>sig <span class="kw">{</span> params(<span class="wa">klass: </span>T<span class="at">.class_of</span>(<span class="dt">AbstractParent</span>)) <span class="kw">}</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="cf">def</span> example(klass)</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="cf">if</span> T<span class="kw">::</span><span class="dt">AbstractUtils</span><span class="at">.abstract_module?</span>(klass)</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="cf">return</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="cf">end</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  klass<span class="at">.foo</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="cf">end</span></span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>example(<span class="dt">ConcreteChild</span>)</span>
<span id="cb4-10"><a href="#cb4-10"></a>example(<span class="dt">AbstractParent</span>) <span class="co"># early return, before klass.foo</span></span></code></pre></div>
<p>This <code>abstract_module?</code> method doesn‚Äôt solve the original
problem; nothing in Sorbet checks that it‚Äôs called before calling an
abstract singleton class method. But it at least lets authors work
around known shortcomings in their code‚Äôs design without large
refactors. Know that from the type system‚Äôs perspective, <strong>all the
three options above</strong> are better than relying on
<code>abstract_module?</code> checks at runtime.</p>
<h1 id="further-reading">Further reading</h1>
<ul>
<li><p><a href="/inheritance-in-ruby/">Inheritance in Ruby, in pictures
‚Üí</a><br />
A solid understanding of abstract methods requires understanding how
Ruby‚Äôs inheritance features work (<code>&lt;</code>,
<code>include</code>, and <code>extend</code>).</p></li>
<li><p><a href="/typing-klass-new/">Typing klass.new in Ruby with Sorbet
‚Üí</a><br />
If the method you‚Äôre trying to make abstract is a class‚Äôs constructor,
there‚Äôs some subtlety to it.</p></li>
<li><p><a href="/intro-elim/">Every type is defined by its intro and
elim forms ‚Üí</a><br />
For some high level thoughts on type-driven code organization.</p></li>
</ul>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#types">types</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

