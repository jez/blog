<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2017-07-16 14:45:31 -0400">
<meta name="description" content="After a year and a half of using Haskell on and off, I've finally settled on a set of high-quality development and editor tools, using Stack and Neovim.
">
<title>Haskell Development with Neovim ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Haskell Development with Neovim</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2017-07-16 14:45:31 -0400">July 16, 2017</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">‚äï</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#requirements"
  id="toc-requirements">Requirements</a></li>
  <li><a href="#overview" id="toc-overview">Overview</a></li>
  <li><a href="#syntax-highlighting-indentation"
  id="toc-syntax-highlighting-indentation">Syntax Highlighting &amp;
  Indentation</a></li>
  <li><a href="#auto-formatting-and-indentation"
  id="toc-auto-formatting-and-indentation">Auto-formatting and
  Indentation</a></li>
  <li><a href="#quickfix-sign-columns"
  id="toc-quickfix-sign-columns">Quickfix &amp; Sign Columns</a></li>
  <li><a href="#intero-the-pi√®ce-de-r√©sistance"
  id="toc-intero-the-pi√®ce-de-r√©sistance">Intero: The Pi√®ce de
  R√©sistance</a></li>
  <li><a href="#the-eagerly-awaited-config"
  id="toc-the-eagerly-awaited-config">The Eagerly-Awaited
  Config</a></li>
  <li><a href="#wrap-up" id="toc-wrap-up">Wrap Up</a></li>
  </ul>
</nav>

<main>
<p>Configuring an editor for a new language is a double-edged sword:
it‚Äôs intensely satisfying when done, but takes time away from diving
into the language itself! After using Haskell for a little over a year,
I‚Äôve settled on a high-quality set of editor plugins. They‚Äôre simple,
powerful, and all play nicely together.</p>
<!-- more -->
<h1 id="requirements">Requirements</h1>
<p>I use <a href="https://www.haskellstack.org/">Haskell Stack</a>
exclusively. Stack‚Äôs goal is reproducible builds, which means that in
general, things Just Work.</p>
<p>I also use <a href="https://github.com/neovim/neovim">Neovim</a>,
rather than normal Vim. Usually, my justification is ideological rather
than technical. However, for Haskell my setup <strong>requires</strong>
Neovim. Fear not! Neovim is feature-packed and also very stable. I love
Neovim, and I‚Äôll be writing more about why in a future post.</p>
<p>By the way, new to Vim plugins? I happen to have <a
href="https://github.com/jez/vim-as-an-ide">just the post for
you</a>!</p>
<h1 id="overview">Overview</h1>
<p>We‚Äôre going to move in order of increasing complexity. That said,
even the most ‚Äúcomplex‚Äù plugin here is actually quite painless to set
up. By the end, we‚Äôll have a complete development experience! Coming
up:</p>
<ul>
<li>syntax highlighting &amp; indentation (<strong><a
href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a></strong>)</li>
<li>auto-formatting &amp; style (<strong><a
href="https://github.com/commercialhaskell/hindent">hindent</a>, <a
href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a></strong>)</li>
<li>quickfix and sign column support (<strong>using <a
href="https://github.com/w0rp/ale">ale</a></strong>) for:
<ul>
<li>linter style suggestions (<strong>hlint</strong>)</li>
<li>compiler errors and warnings (<strong>ghc-mod</strong>)</li>
</ul></li>
<li>Type inspection, REPL integration, and more! (<strong><a
href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></strong>)</li>
</ul>
<p>To keep things concise, I‚Äôve moved all the relevant configuration to
the end of the post. For now, let‚Äôs start at the top.</p>
<h1 id="syntax-highlighting-indentation">Syntax Highlighting &amp;
Indentation</h1>
<ul>
<li><strong>Plugin</strong>: <a
href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a><span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">While listed under ‚Äúneovimhaskell‚Äù on GitHub, this
plugin works with normal Vim, too.<br />
<br />
</span></span></li>
</ul>
<p>Vim‚Äôs default Haskell filetype plugin is pretty lack luster.
Everything is blue, except for strings which are colored like comments,
and keywords which are colored like constants. Indentation is wonky in
some cases, and isn‚Äôt configurable.</p>
<p>This plugin corrects all that. It‚Äôs the filetype plugin for Haskell
that <strong>should</strong> ship with Vim.</p>
<p>Not only does it come with saner defaults, it also comes with more
config options, especially for indentation. This is important because it
lets me tweak the automatic indentation to my own personal style.</p>
<p>(Remember: all the config is at the end of the post.)</p>
<h1 id="auto-formatting-and-indentation">Auto-formatting and
Indentation</h1>
<ul>
<li><strong>Plugin</strong>: <a
href="https://github.com/alx741/vim-hindent">vim-hindent</a></li>
<li><strong>Tool</strong>: <code>stack install hindent</code></li>
<li><strong>Tool</strong>:
<code>stack install stylish-haskell</code></li>
</ul>
<p>For small projects, I have an idea of what style I like best.
However, for larger projects it‚Äôs unfair to ask contributors that they
learn the ins and outs of my style. Situations like these call for
automated solutions.</p>
<p><code>go fmt</code> famously solved this problem for Golang by
building the formatting tool into the compiler. For Haskell, there‚Äôs <a
href="https://github.com/commercialhaskell/hindent">hindent</a><span
class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span
class="sidenote">Chris Done explains the appeal of solving style issues
with tooling for Haskell well. The moral of the story is that hindent
version 5 ships with only the most popular style formatter in an effort
to arrive at a singular Haskell style: <a
href="http://chrisdone.com/posts/hindent-5"
class="uri">http://chrisdone.com/posts/hindent-5</a><br />
<br />
</span></span>. <code>hindent</code> can be installed through Stack, and
<code>vim-hindent</code> is a Vim plugin that shims it.</p>
<p>But I said I‚Äôm partial to my own style in personal projects. There‚Äôs
another Haskell formatter that‚Äôs much less invasive: <a
href="https://github.com/jaspervdj/stylish-haskell">stylish-haskell</a>.
It basically only reformats <code>import</code>s, <code>case</code>
branches, and record fields, aligning them vertically. And in fact, it‚Äôs
possible to use this alongside <code>hindent</code>.</p>
<p>With these three tools, I can pick the right tool for the job:</p>
<ul>
<li><strong>Hand saw</strong>: let <code>haskell-vim</code> config
control the indentation</li>
<li><strong>Table saw</strong>: run <code>stylish-haskell</code>
only</li>
<li><strong>Chainsaw</strong>: run <code>hindent</code> only</li>
<li><strong>Chainsaw, then sand paper</strong>: run
<code>hindent</code>, then <code>stylish-haskell</code></li>
</ul>
<p>Getting them to play together requires a bit of config, so I‚Äôve
included mine at the end of the post.</p>
<h1 id="quickfix-sign-columns">Quickfix &amp; Sign Columns</h1>
<ul>
<li><strong>Plugin</strong>: <a
href="https://github.com/w0rp/ale">ale</a></li>
<li><strong>Tool</strong>: <code>stack install hlint</code></li>
<li><strong>Tool</strong>: <code>stack build ghc-mod</code>
<ul>
<li>N.B.: This is <em>build</em> not <em>install</em> here<span
class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span
class="sidenote">We want to install <code>ghc-mod</code> once in every
project. It can be done globally, but it might get out of sync with the
current project.<br />
<br />
</span></span>.</li>
</ul></li>
</ul>
<p>This step requires <em>either</em> Neovim or Vim 8; ALE stands for
‚ÄúAsynchronous Lint Engine,‚Äù so it‚Äôs using the new asynchronous job
control features of these two editors. It‚Äôs like an asynchronous
Syntastic<span
class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span
class="sidenote">Some people are familiar with Neomake for this task.
However, Neomake is much more minimal than ALE. Neomake basically only
builds, whereas ALE is more configurable and hackable.<br />
<br />
</span></span>.</p>
<p>ALE ships with a number of Haskell integrations by default. For
example, it can show errors if only Stack is installed. I prefer
enabling two of ALE‚Äôs Haskell integrations: <code>hlint</code> and
<code>ghc-mod</code>.</p>
<ul>
<li><code>hlint</code> is a linter for Haskell. It warns me when I try
to do silly things like <code>if x then True else False</code>.</li>
<li><code>ghc-mod</code> is a tool that can check files for compiler
errors.</li>
</ul>
<p>The beauty of ALE is that it works almost entirely out of the box.
The only real setup is to tell ALE to use only these two integrations
explicitly. I‚Äôve included the one-liner to do this in the config at the
bottom.</p>
<h1 id="intero-the-pi√®ce-de-r√©sistance">Intero: The Pi√®ce de
R√©sistance</h1>
<ul>
<li><strong>Plugin</strong>: <a
href="https://github.com/parsonsmatt/intero-neovim">intero-neovim</a></li>
</ul>
<p>Intero is a complete development program for Haskell. It started as
an Emacs package, but has been ported almost entirely to Neovim.
Probably the best way to introduce it is with this asciicast:</p>
<p align="center">
<a href="https://asciinema.org/a/128416"> <img
      width="700px"
      alt="Intero for Neovim asciicast"
      src="https://asciinema.org/a/128416.png"> </a>
</p>
<p>Intero is designed for stack, sets itself up automatically, has
point-and-click type information, and lets me jump to identifier
definitions. On top of it all, it uses Neovim to communicate back and
forth with a terminal buffer so that I get a GHCi buffer <strong>right
inside Neovim</strong>. For Emacs users, this is nothing new I‚Äôm sure.
But having the REPL in my editor continues to blow my mind üòÆ.</p>
<p>Developing with the REPL in mind helps me write better code. Only
top-level bindings are exposed in the REPL, so I write more small,
testable functions. See here for more reasons <a
href="http://chrisdone.com/posts/haskell-repl">why the REPL is
awesome</a>.</p>
<p>On top of providing access to the REPL, Intero provides about a dozen
convenience commands that shell out to the REPL backend asynchronously.
Being able to reload my code in the REPL‚Äîfrom Vim, with a single
keystroke!‚Äîis a huge boon when developing.</p>
<p>Intero takes a little getting used to, so be sure to read the docs
for some sample workflows. Intero also sets up no mappings by default,
so I‚Äôve included my settings below.</p>
<h1 id="the-eagerly-awaited-config">The Eagerly-Awaited Config</h1>
<p>And without further ado‚Ä¶</p>
<pre class="vim"><code>&quot; ----- neovimhaskell/haskell-vim -----

&quot; Align &#39;then&#39; two spaces after &#39;if&#39;
let g:haskell_indent_if = 2
&quot; Indent &#39;where&#39; block two spaces under previous body
let g:haskell_indent_before_where = 2
&quot; Allow a second case indent style (see haskell-vim README)
let g:haskell_indent_case_alternative = 1
&quot; Only next under &#39;let&#39; if there&#39;s an equals sign
let g:haskell_indent_let_no_in = 0

&quot; ----- hindent &amp; stylish-haskell -----

&quot; Indenting on save is too aggressive for me
let g:hindent_on_save = 0

&quot; Helper function, called below with mappings
function! HaskellFormat(which) abort
  if a:which ==# &#39;hindent&#39; || a:which ==# &#39;both&#39;
    :Hindent
  endif
  if a:which ==# &#39;stylish&#39; || a:which ==# &#39;both&#39;
    silent! exe &#39;undojoin&#39;
    silent! exe &#39;keepjumps %!stylish-haskell&#39;
  endif
endfunction

&quot; Key bindings
augroup haskellStylish
  au!
  &quot; Just hindent
  au FileType haskell nnoremap &lt;leader&gt;hi :Hindent&lt;CR&gt;
  &quot; Just stylish-haskell
  au FileType haskell nnoremap &lt;leader&gt;hs :call HaskellFormat(&#39;stylish&#39;)&lt;CR&gt;
  &quot; First hindent, then stylish-haskell
  au FileType haskell nnoremap &lt;leader&gt;hf :call HaskellFormat(&#39;both&#39;)&lt;CR&gt;
augroup END

&quot; ----- w0rp/ale -----

let g:ale_linters = {}
let g:ale_linters.haskell = [&#39;stack-ghc-mod&#39;, &#39;hlint&#39;]

&quot; ----- parsonsmatt/intero-neovim -----

&quot; Prefer starting Intero manually (faster startup times)
let g:intero_start_immediately = 0
&quot; Use ALE (works even when not using Intero)
let g:intero_use_neomake = 0

augroup interoMaps
  au!

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;io :InteroOpen&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;iov :InteroOpen&lt;CR&gt;&lt;C-W&gt;H
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;ih :InteroHide&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;is :InteroStart&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;ik :InteroKill&lt;CR&gt;

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;wr :w \| :InteroReload&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;il :InteroLoadCurrentModule&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;if :InteroLoadCurrentFile&lt;CR&gt;

  au FileType haskell map &lt;leader&gt;t &lt;Plug&gt;InteroGenericType
  au FileType haskell map &lt;leader&gt;T &lt;Plug&gt;InteroType
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;it :InteroTypeInsert&lt;CR&gt;

  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;jd :InteroGoToDef&lt;CR&gt;
  au FileType haskell nnoremap &lt;silent&gt; &lt;leader&gt;iu :InteroUses&lt;CR&gt;
  au FileType haskell nnoremap &lt;leader&gt;ist :InteroSetTargets&lt;SPACE&gt;
augroup END</code></pre>
<h1 id="wrap-up">Wrap Up</h1>
<p>With these tools, I feel empowered (rather than hindered) when I sit
down to work with Haskell.</p>
<ul>
<li>The entire setup uses Stack, so things Just Work.
<ul>
<li>As a consequence, everything works with the implicit global Stack
project!</li>
</ul></li>
<li>It scales up in power:
<ul>
<li>From simple syntax highlighting and manual indentation‚Ä¶</li>
<li>to an indentation chainsaw and a <strong>REPL embeded in the
editor</strong>!</li>
</ul></li>
<li>I can take full advantage of all my tools working together, leading
to cleaner code and fewer frustrations.</li>
</ul>
<p>Now that I‚Äôm finally at a point where I can stop fretting about my
Haskell setup, I‚Äôll have more time to explore the language and write
about my experience.</p>
<p>Haskell-the-language isn‚Äôt quite on the same level as
SML-the-language, but it‚Äôs far and above when comparing by tooling
support. I‚Äôm looking forward to taking advantage of that!</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#haskell">haskell</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#vim">vim</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

