<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-02-18 02:59:55 -0500">
<meta name="description" content="There's an interesting property in programming languages with generic types called "parametricity" that says all functions with a given generic type have to behave similarly, which is a powerful tool for understanding generic code.">
<title>Sorbet, Generics, and Parametricity – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Sorbet, Generics, and Parametricity</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2022-02-18 02:59:55 -0500">February 18, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">← Return home</a><br>
</nav>

<main>
<p>Consider this snippet of Ruby code using Sorbet:</p>
<!-- more -->
<figure class="left-align-caption">
<div class="sourceCode" id="cb1"><pre
class="sourceCode numberSource ruby numberLines hl-11"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># typed: true</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">extend</span> T<span class="kw">::</span><span class="dt">Sig</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>sig <span class="cf">do</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  type_parameters(<span class="wa">:U</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="at">.params</span>(<span class="wa">x: </span>T<span class="at">.type_parameter</span>(<span class="wa">:U</span>))</span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="at">.returns</span>(T<span class="at">.type_parameter</span>(<span class="wa">:U</span>))</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="cf">end</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="cf">def</span> fake_identity_function(x)</span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="cf">case</span> x</span>
<span id="cb1-11"><a href="#cb1-11"></a>  <span class="cf">when</span> <span class="dt">Integer</span> <span class="cf">then</span> <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>  <span class="co">#                 ^^^^^^^^ error</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="cf">else</span> <span class="cf">return</span> x</span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="cf">end</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="cf">end</span></span></code></pre></div>
<figcaption>
<a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%20then%20return%200%0A%20%20else%20return%20x%0A%20%20end%0Aend">→
View on sorbet.run</a>
</figcaption>
</figure>
<p>It has the same signature as the identity function (which returns its
argument unchanged), but doesn’t actually do that in all cases. In
particular, on the highlighted line it checks the type of <code>x</code>
at runtime, and if it’s an <code>Integer</code>, it always returns
<code>0</code>, regardless of the input.</p>
<p>Sorbet flags this as an error (see the full error message in the
sorbet.run link). Sometimes I get asked: “why?” The reasoning for why
people think this <em>shouldn’t</em> be an error usually looks like
this: the signature just says that the output has to be the same as the
input, and <code>Integer</code> is the same as <code>Integer</code>.</p>
<p>But the fun thing is that this signature makes a stronger constraint
on the implementation of the method—in this case the signature
<strong>mandates</strong> that the result is the input. The hand-wavy
intuition for how to think about what’s going on is to mentally read the
<code>type_parameters(:U)</code> in the signature as “for all,”
specifically, “the behavior of this function is the same <em>for
all</em> choices of the type parameters.”</p>
<p>In that light, generics put a pretty hefty constraint on the
implementation of a generic method—which is actually a good thing! It
means that the caller of the method can make stronger guarantees about
what the method can or cannot do, even seeing only the types. For
example:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>sig <span class="cf">do</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  type_parameters(<span class="wa">:U</span>, <span class="wa">:V</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">.params</span>(<span class="wa">x: </span>T<span class="at">.type_parameter</span>(<span class="wa">:U</span>), <span class="wa">y: </span>T<span class="at">.type_parameter</span>(<span class="wa">:V</span>))</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">.returns</span>(T<span class="at">.any</span>(T<span class="at">.type_parameter</span>(<span class="wa">:U</span>), T<span class="at">.type_parameter</span>(<span class="wa">:V</span>)))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="cf">end</span></span></code></pre></div>
<p>From this signature we’re guaranteed that the method has to return
exactly one of the arguments we provided (<code>x</code> or
<code>y</code>) and nothing else. It can’t invent some third value and
return that.</p>
<p>But the constraints come within reason: the types don’t say anything
about what side effects the function might have. This isn’t particularly
unique to generics (Sorbet doesn’t track side effects no matter the
types), but it is worth noting as a sneaky way that methods can do
different things with different arguments. Going back to our
<code>fake_identity_function</code> example from earlier:</p>
<figure class="left-align-caption">
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource ruby numberLines hl-12 hl-15"><code class="sourceCode ruby"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># typed: true</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="fu">extend</span> T<span class="kw">::</span><span class="dt">Sig</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>sig <span class="cf">do</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>  type_parameters(<span class="wa">:U</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="at">.params</span>(<span class="wa">x: </span>T<span class="at">.type_parameter</span>(<span class="wa">:U</span>))</span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="at">.returns</span>(T<span class="at">.type_parameter</span>(<span class="wa">:U</span>))</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="cf">end</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="cf">def</span> fake_identity_function(x)</span>
<span id="cb3-10"><a href="#cb3-10"></a>  <span class="cf">case</span> x</span>
<span id="cb3-11"><a href="#cb3-11"></a>  <span class="cf">when</span> <span class="dt">Integer</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="fu">puts</span>(x<span class="at">.even?</span>)</span>
<span id="cb3-13"><a href="#cb3-13"></a>    x</span>
<span id="cb3-14"><a href="#cb3-14"></a>  <span class="cf">else</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>    x<span class="at">.even?</span> <span class="co"># error: Method `even?` does not exist</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>    x</span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="cf">end</span></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="cf">end</span></span></code></pre></div>
<figcaption>
<a
href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20else%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20end%0Aend">→
View on sorbet.run</a>
</figcaption>
</figure>
<p>In this example, the side effect of calling
<code>puts(x.even?)</code> only happens if the type is
<code>Integer</code>, breaking the intuition that the behavior of this
function is uniform for all input types.</p>
<p>If Sorbet wanted,<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">Unlike everything we’ve discussed so far, I’m not
actually sure whether that was a conscious decision or an accident. But
it is a pretty useful feature in practice.<br />
<br />
</span></span> it could prevent this particular form of anti-uniformity
by not allowing any <a
href="https://sorbet.org/docs/flow-sensitive">control-flow-sensitive</a>
type updates. But it wouldn’t change the fact that, for example, one
implementation of <code>fake_identity_function</code> could always print
one log line, while another implementation could always print two log
lines. The only uniformity guarantees we get are about specifically
what’s captured in the input and output types.</p>
<p>It turns out that there’s a name for this property of generic
functions: <a
href="https://en.wikipedia.org/wiki/Parametricity">parametricity</a>.
It’s a fancy word but it basically means what we’ve talked about here:
the implementation of generic functions are constrained to basically
only do one thing, modulo side-effects. It goes further than just
intuition though, and people have done interesting work to formalize the
intuitions into proofs.</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#plt">plt</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

