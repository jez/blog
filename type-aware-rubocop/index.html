<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-05-16 16:17:20 -0400">
<meta name="description" content="From time to time, someone asks, "Would Sorbet ever allow defining some sort of type-aware lint rules?" My answer has usually been "no," for a couple of reasons.">
<title>What would a type-aware Rubocop look like? – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  




</head>
<body>
  




  <header>
    <h1 class="title">What would a type-aware Rubocop look like?</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2022-05-16 16:17:20 -0400">May 16, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it">Should every AST node (i.e., every expression) have a type associated with it?</a></li>
  <li><a href="#maybe-types-for-just-variables-is-enough">Maybe types for just variables is enough?</a></li>
  <li><a href="#even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough">Even if this “give me the type of a variable” API works, is it enough?</a></li>
  <li><a href="#rubocop-types-or-sorbet-linter">Rubocop + types, or Sorbet + linter?</a></li>
  <li><a href="#what-do-people-actually-want-this-for">… what do people actually want this for?</a></li>
  <li><a href="#is-there-anything-like-this-in-another-language">… is there anything like this in another language?</a></li>
  <li><a href="#competing-priorities-tend-to-win-out">Competing priorities tend to win out</a></li>
  <li><a href="#maybe-in-the-future">“Maybe in the future…”</a></li>
  </ul>
</nav>

<main>
<p><em>This post represents my opinions at a point in time. It’s not necessarily the views of my team or my employer.</em></p>
<p>From time to time, someone asks, “Would <a href="https://sorbet.org">Sorbet</a> ever allow defining some sort of type-aware lint rules?” The answer has usually been “no,” for a couple of reasons.</p>
<!-- more -->
<p>The biggest open question is that it’s not 100% clear what use cases people have in mind. Most commonly people imagine “the full <a href="https://rubocop.org/">Rubocop</a> API, but with types,” but this is underspecified, in my opinion.</p>
<h3 id="should-every-ast-node-i.e.-every-expression-have-a-type-associated-with-it">Should every AST node (i.e., every expression) have a type associated with it?</h3>
<p>This would be particularly hard to support, because Sorbet aggressively simplifies the AST from the start to the end of its pipeline. The Rubocop AST has something like 100 node types. Sorbet immediately simplifies this into an AST that only has 30 or so node types, then subsequently keeps refining the AST until it only has about 15. The thing Sorbet type checks looks nothing like the AST that you’d want if you were trying to write a linter, because so much of it has been desugared, rewritten, or simplified.</p>
<p>Then finally right before type checking, Sorbet actually abandons the (tree-based) AST, preferring to use a <strong>control flow graph</strong> (CFG) for type checking! A CFG is no longer tree-based<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">It’s a graph, where nodes are basic blocks and edges are control flow jumps between those blocks.<br />
<br />
</span></span>, which breaks a lot of the assumptions people make about what’s easy and hard to build in a linter rule.</p>
<p>Because Sorbet type checks a CFG only, there’s no tree-based structure inside Sorbet that has types. <em>Maybe</em> it’s possible to take the type-annotated CFG and use it to reconstruct some sort of typed AST, but that sounds brittle and error prone.</p>
<p>And finally, in the CFG Sorbet doesn’t associate types with expressions, only types with variables! This works because the act of building a CFG assigns all intermediate expressions’ results to a variable and then only dealing with variables from then on.</p>
<h3 id="maybe-types-for-just-variables-is-enough">Maybe types for just variables is enough?</h3>
<p>This would likely be somewhat easier to implement, because Sorbet already does maintain environments mapping variables to their types.</p>
<p>However, these data structures are expensive to maintain and therefore not long-lived.<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Sorbet’s LSP editor integration gets around this by re-typechecking an entire method every time the user hovers over a variable. When these hover requests come as (infrequent) requests from the user, this is fine because Sorbet is already initialized. Powering a linter this way would either require that the Sorbet server be initialized for variable type every request (crazy slow), or somehow kept around persistently (brittle).<br />
<br />
</span></span> Unlike Sorbet’s symbol table, which exists indefinitely after creation, the environments that track variable types only last as long as is required to type check a single method.</p>
<p>Maybe there could be an API like “please give me the type of the variable with this name,” but again this would be tricky, because chances are the lint rule author wants to build the lint rule on some tree-based data structure, and Sorbet only has the CFG. So there would additionally need to be some mapping between environments (basic blocks) and AST variable nodes, which again sounds pretty tricky and likely to break some assumptions.</p>
<h3 id="even-if-this-give-me-the-type-of-a-variable-api-works-is-it-enough">Even if this “give me the type of a variable” API works, is it enough?</h3>
<p>Knowing the type of a variable on its own isn’t very useful. The most common questions you want ask of a type are:</p>
<ol type="1">
<li>Is is this type a subtype of this other type?</li>
<li>If a method with a given name is called on a receiver of this type, what are the <em>list</em> of methods that would be dispatched to? (It’s a list because the receiver could be a union type.)</li>
</ol>
<p>The answer to (1) requires having the entire symbol table on hand (lots of memory). The answer to (2) is subtle and complicated—Sorbet spends <a href="https://github.com/sorbet/sorbet/blob/master/core/types/calls.cc">about 4,000 lines of code</a> answering it—and <em>also</em> requires having the symbol table on hand.</p>
<p>So it’s probably not enough to just, e.g., return some JSON representation of one of Sorbet’s types. It’d also require having some structured representation of Sorbet’s symbol table, which brings us to our next question:</p>
<h3 id="rubocop-types-or-sorbet-linter">Rubocop + types, or Sorbet + linter?</h3>
<p>So far I’ve kind of assumed that we want to start with an existing linter (Rubocop) and just add types. But what we’ve seen so far is that the things we’d need to get types into Rubocop basically amount to exporting almost all of Sorbet’s internal data structures.</p>
<p>Sorbet’s internal data structures change all the time as we fix bugs, add features, and refactor things. Having to commit to a stable API for every internal data structure mentioned above would slow down how quickly we can improve the rest of Sorbet.</p>
<p>So maybe instead of exporting an API that Rubocop could use, we should build a linter into Sorbet? This just has different tradeoffs:</p>
<ul>
<li><p>Sorbet has to reinvent the wheel on linter APIs (e.g., are lint rules specified in Ruby code with some new API? Does it attempt to copy as much of Rubocop’s API as possible? What happens when there are papercut differences between what Sorbet’s linter allows and what Rubocop does?)</p></li>
<li><p>How are rules distributed? Are the rules written in Ruby, and Sorbet runs the Ruby code with some sort of FFI to expose the internal data structures? Does Sorbet embed some other scripting language for writing rules? Do people write rules as shared objects which Sorbet dynamically loads, akin to Ruby native extensions? Are the rules committed directly into the Sorbet repo, like how custom DSL and rewriter passes are right now?</p></li>
</ul>
<h3 id="what-do-people-actually-want-this-for">… what do people actually want this for?</h3>
<p>Whenever someone asks for a type-aware linter, here are a sampling of the answers given when I ask, “What are you really trying to do?”</p>
<ol type="1">
<li><p>“Ban calling <code>to_s</code> on <code>nil</code>, because I just spent half an hour tracking down a bug where I had a <code>T.nilable(Symbol)</code> that I called <code>to_s</code> on and got the wrong answer.”</p></li>
<li><p>“Update the <a href="https://docs.rubocop.org/rubocop-performance/cops_performance.html#performanceinefficienthashsearch">Performance/InefficientHashSearch</a> rule to only act on <code>Hash</code> values. Not all calls like <code>xs.values.include?</code> can be safely rewritten to <code>xs.value?</code>.”</p></li>
<li><p>“Do type-aware codemods, for example change all calls to <code>x.merchant_</code> to something like <code>ClassOfX.get_merchant(x.id)</code>”</p></li>
<li><p>“Enforce that all methods returning <code>T::Boolean</code> have names ending in <code>?</code>”</p></li>
</ol>
<p>It’s not clear that “just” building a type-aware linter necessarily solves these problems.</p>
<p>Doing (1) is hard—should we allow <code>Object#to_s</code>? You could still accidentally call <code>to_s</code> on something that’s <code>nil</code> inside a method that accepts <code>Object</code> if you do. Also there are sometimes valid cases to call <code>to_s</code> on <code>nil</code> that no type system will help you discover! This feature seems similar to the <code>#poison</code> pragma in C and C++, but there the language makes it easier because <code>#include</code>’ed files are explicitly ordered, and it’s easy to say “after this point, the identifier is poisoned.” (Also I’m not even sure how <code>#poison</code> works with methods, not just C functions, where things like inheritance become a problem.)</p>
<p>Doing (2) relies on that hard feature we chatted about above: types for arbitrary expressions, not just variables. If we don’t have types for arbitrary expressions, detecting this case in a cop requires essentially re-inventing Sorbet’s inference algorithm: <code>input.map {...}.filter {...}.values.include?</code>. We mentioned the difficulty in exposing types for arbitrary expressions above.</p>
<p>The situation for (3) is something I can really relate to, as there are a lot of cases where I can imagine this being useful. But rather than build this as a lint rule, we’ve historically wanted to build these as IDE-mode code actions: the API is much more constrained (no internal data structures needed) and the IDE already has the type information in memory. Sorbet supports a limited number of refactorings now, but mostly because we haven’t spent time on it. It’s reasonable to assume we’ll build many more refactorings in the future.</p>
<p>And finally, things like (4) can <em>already</em> be done in Rubocop. It’s slightly more annoying (you have to write the code to parse Sorbet signature annotations manually) but Sorbet signature annotations are very stable. Their syntax changes infrequently, and when it does, it’s usually minor and/or backwards compatible changes.</p>
<h3 id="is-there-anything-like-this-in-another-language">… is there anything like this in another language?</h3>
<p>Here’s one of Sorbet’s explicit design principles:</p>
<blockquote>
<ol start="3" type="1">
<li><p>As simple as possible, but powerful enough</p>
<p>Overall, we are not strong believers in super-complex type systems. They have their place, and we need a fair amount of expressive power to model (enough) real Ruby code, but all else being equal we want to be simpler. We believe that such a system scales better, and—most importantly—is easier for our users to learn &amp; understand.</p></li>
</ol>
<p>— <a href="https://github.com/sorbet/sorbet/#sorbet-user-facing-design-principles">Sorbet user-facing design principles</a></p>
</blockquote>
<p>Another way to read this is, “we let other people blaze trails, and then copy their good ideas.”</p>
<p><del>This question comes up often enough that it makes me want to imagine that some sort of similar tool exists for other dynamically typed languages? But as far as I’m aware, no sort of type-aware linter exists for TypeScript, Flow, or Mypy.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote"><del>If you know of a comparable tool, please do share!</del><br />
<br />
</span></span> Not having any sort of frame of reference makes it hard to gauge expectations people have when asking for a tool like this.</del></p>
<p><strong>Update, 2022-05-18</strong><span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Thanks to Steve Dignam for pointing out that not only does C# have static analysis APIs, but that TypeScript does as well, along with an ecosystem of type-aware lint rules.<br />
<br />
</span></span> There <em>are</em> type-aware static analysis tools for C# and TypeScript. Both languages were designed by the <a href="https://en.wikipedia.org/wiki/Anders_Hejlsberg">same person</a>, so maybe this isn’t surprising. Unfortunately for Sorbet, they were architected to support static analysis tooling <a href="https://en.wikipedia.org/wiki/Roslyn_%28compiler%29#:~:text=Roslyn%20was%20designed%20with%20that%20intent%20from%20the%20beginning.">from the beginning</a>. Sorbet’s current architecture was instead designed for batch type checking performance on large monorepos,<span class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="sidenote">All things considered, it’s actually quite good at this.<br />
<br />
</span></span> and IDE support was grafted on later. Exposing hackable APIs has so far not been considered.</p>
<p>For example, TypeScript offers a <a href="https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API">compiler API</a>, which is then used by the TypeScript ESLint project, which allows defining <a href="https://typescript-eslint.io/docs/development/custom-rules#type-checking">custom type-aware lint rules</a>. What can we learn from this project?</p>
<ul>
<li>The TypeScript compiler API does not have any sort of backwards compatibility guarantee, so breaking changes are published from time to time.</li>
<li>It appears that all TypeScript functionality can be accessed behind the API, including instantiating a stateful object representing the type checker, running the type checker end-to-end on a project, spawning an LSP server, etc.</li>
<li>The way custom lint rules are written is by converting between ESLint’s AST node type and TypeScript’s AST node type. The TypeScript compiler APIs then allow asking for the type of an AST (i.e., expression). I haven’t confirmed, but this leads me to believe that TypeScript itself is doing typechecking on the AST (maybe with some auxiliary structures to track control flow), not on a CFG like Sorbet, which makes it easier to present the kind of API that makes sense in a lint rule.</li>
</ul>
<p>It’s interesting to <a href="https://cs.github.com/typescript-eslint/typescript-eslint?q=%22requiresTypeChecking%3A+true%22">browse the rules that require type information</a> to get a sense for what’s possible. Things like <code>strict-boolean-expressions</code> and <code>no-floating-promises</code> are examples of non-trivial lints using type information.</p>
<p>I have spent very limited time looking into how things work exactly, so it’s possible I’m misrepresenting the ideas. In any case, I personally still draw the same conclusion: clearly people in the TypeScript community derive value from building type-aware lint rules, and TypeScript is well-architected to enable this. As mentioned in previous sections, Sorbet’s current architecture does not present the same conveniences.</p>
<h3 id="competing-priorities-tend-to-win-out">Competing priorities tend to win out</h3>
<p>When attempting to build this feature, we’d of course have to judge the cost of what we’d have to give up.</p>
<p>Overwhelmingly, the requests people have about Sorbet are:</p>
<ul>
<li>Please fix shape and tuple types.</li>
<li>Please fix generics (classes and methods).</li>
<li>Please make Sorbet work faster on large codebases, especially in IDE mode.</li>
<li>Please build more refactoring tools. If IntelliJ can do it, I’d like Sorbet to do it too.</li>
</ul>
<p>So far, these requests have taken priority over greenfield projects, including things like a type-aware linter.</p>
<h3 id="maybe-in-the-future">“Maybe in the future…”</h3>
<p>Those are my current thoughts on the topic. Obviously, a lot of these reasons are just “it’s hard,” and maybe for someone else those things would be easy. Others are just selfish, “it’s convenient for us to not have to think about compatibility,” and so they’re easy to disagree with. Some of them are, “there’s no clear answer to this question,” and sometimes you can wave those away by just picking <em>any</em> answer and living with it, rather than searching for the best.</p>
<p>So while I don’t think that Sorbet would <em>never</em> get some sort of type-aware linter, so far there are many factors that present a pretty high barrier to building something like this. Hopefully this post sheds some light on why a type-aware linter for Sorbet does not currently exist.</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#rubocop">rubocop</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

