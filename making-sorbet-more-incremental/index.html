<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2023-01-09 09:19:36 -0500">
<meta name="description" content="A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.">
<title>Making Sorbet more incremental – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Making Sorbet more incremental</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2023-01-09 09:19:36 -0500">January 9, 2023</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">Home</a><br>
  <strong>Contents</strong><label for="contents">⊕</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#step-1-list-all-the-edits">Step 1: List all the edits</a></li>
  <li><a href="#step-2-a-poor-mans-incrementality">Step 2: A poor man’s incrementality</a></li>
  <li><a href="#wait-what-took-so-long">Wait, what took so long?</a></li>
  <li><a href="#can-we-make-everything-incremental">Can we make <em>everything</em> incremental?</a></li>
  </ul>
</nav>

<main>
<p>My main focus last year was improving the Sorbet editor experience: making Sorbet feel snappier while powering language-aware editor features. The biggest improvements came from making Sorbet <strong>more incremental</strong>. By being smarter about skipping redundant work, we slashed the time it takes for Sorbet to do things like update the list of errors, populate autocompletion suggestions, and jump between definitions and usages.</p>
<!-- more -->
<p>I had a lot of fun working on this, so I’m going to gush about it. <strong>It’s going to be long</strong>—don’t say I didn’t warn you. But I think it’s also really cool.</p>
<p><br />
</p>
<p><br />
</p>
<p>Every edit in Sorbet is different—some edits are simply more work to type check than others. For example, it’s a lot more work to type check an edit that changes thousands of files than it is to type check an edit that adds a blank line inside a method body. Ideally Sorbet would figure out what’s changed and use that to type check only as much as necessary.</p>
<p>But Sorbet takes a bit of an unconventional approach to incrementality. In particular, it’s not fully incremental: some kinds of edits cause Sorbet to type check the whole codebase. The changes we built last year made this happen much less often: from 19% of edits when we started to only 10% of edits by the end.</p>
<p>Incrementally responding to an edit is hard for three vague reasons:</p>
<ol type="1">
<li>It’s hard to quickly tell what changed.</li>
<li>Knowing that, it’s hard to correctly update Sorbet’s knowledge of the codebase.</li>
<li>Having done that, it’s hard to decide which files depend on what changed and must be type checked again.</li>
</ol>
<p>Sorbet is stateful, so even a minor bug in solving one of those problems will compound as more edits arrive.</p>
<p>Of those three, Sorbet managed to do (1) and (3) passably well before we started. But (2) is classically the hardest of the three, and Sorbet avoided it in all but the simplest of cases—partly by design! In <a href="https://blog.nelhage.com/post/reflections-on-performance/#performant-foundations-simplify-architecture">Reflections on software performance</a>, Nelson wrote:</p>
<blockquote>
<p>In the case of Sorbet, while we did make use of some caches, and while Sorbet’s LSP server has some complexity to perform incremental re-typechecking, both systems were drastically simpler than the ones in comparable typecheckers I am familiar with. We got away with this simplicity in large part because the base-case performance for Sorbet just isn’t that bad; Sorbet doesn’t have to go to extreme lengths to save work, because it’s often fast enough to just do the work instead.</p>
</blockquote>
<p>Unfortunately, after about 5 years of codebase growth, the base-case performance had slowed to a point where it was no longer fast enough to just do the work. It was finally time to make Sorbet more incremental, which we went about in two steps:</p>
<ul>
<li>Step 1: enumerate all the kinds of edits that could happen</li>
<li>Step 2: teach Sorbet how to incrementally update its knowledge for each kind of edit</li>
</ul>
<h1 id="step-1-list-all-the-edits">Step 1: List all the edits</h1>
<p>Whenever Sorbet gives up on handling an edit incrementally, it emits a metric with the reason.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">One of the cool things about Sorbet is how easy it is to <a href="https://sorbet.org/docs/metrics">get metrics out of it</a>.<br />
<br />
</span></span> In June 2022, the breakdown looked something like this on Stripe’s codebase:</p>
<p><img src="/assets/img/slow-path-reason.png" /></p>
<p>This chart shows that the most common reason was “changed definition,” accounting for 50% of edits that ended in a full type check. “Changed definition” here means any change to a method, class, module, constant, generic type, or instance variable. (Basically: everything but local variables.) Maybe a definition’s type changed, maybe its name changed, maybe it was added or deleted, etc.</p>
<p>Given how common the “changed definition” bucket was, we decided to focus on it first. (I’ll circle back to the other reasons when discussing <a href="#can-we-make-everything-incremental">what’s next</a> below.)</p>
<p>Digging in one step further, next we listed what <em>kinds</em> of definitions were changing in those “changed definition” slow path edits:</p>
<p><img src="/assets/img/which-edits-changed.png" /></p>
<p>The chart confirms what you might have already expected: method and class definitions are commonly changed. Slightly less common are edits to instance variables, constant assignments, and certain things like generic types.</p>
<p>But you’ll notice that the percents here sum to over 100%, because one edit might change more than one kind of definition. If we were to teach Sorbet how to handle changes involving, say, method definitions, it might <strong>still</strong> have to take the slow path if the edit also changed a class.</p>
<p>So we looked at one last breakdown: in changed definition edits where <strong>only one</strong> kind of definition changed, which kind was it:</p>
<p><span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="marginnote">Sorry for the poor screenshot here, but the blue line on top is for changes to only method definitions.<br />
<br />
</span></span></p>
<p><img src="/assets/img/number-of-edits-only-one-kind.png" /></p>
<p>Not every edit changes only one kind of definition, so these lines don’t sum to 100%. But data like this is still great because it tells us what to prioritize.</p>
<p>With this, step 1 was done: we’d listed all the kinds of edits that Sorbet chokes on, and figured out the order we should tackle them.</p>
<p>Next came the hard part—actually teaching Sorbet how to incrementally update its knowledge in response to each one of these edits.</p>
<h1 id="step-2-a-poor-mans-incrementality">Step 2: A poor man’s incrementality</h1>
<p>There are all sorts of principled ways to build an incremental compiler. Anders Hejlsberg describes <a href="https://learn.microsoft.com/en-us/shows/Seth-Juarez/Anders-Hejlsberg-on-Modern-Compiler-Construction">one approach here</a>, used by C# and TypeScript. Alex Kladov describes <a href="https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html#query-based-compiler">another approach here</a>, used by rust-analyzer. The problem with every principled approach I’ve seen is that in practice, it involved a full or near-full rewrite of the codebase.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="marginnote">TypeScript is an exception, but that’s because it was written by the same person who had done the C# rewrite.<br />
<br />
</span></span> From what I can tell, that took <a href="https://en.wikipedia.org/wiki/Roslyn_(compiler)#History">about 3 years for C#</a>, and <a href="https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html#history-and-future">about 3 years</a> for rust-analyzer.</p>
<p>I don’t have that kind of time, so we came up with a different approach: when a file changes, <strong>delete all its old stuff, then define all its new stuff</strong>. This lets Sorbet continue to assume that it has up-to-date information about the while codebase, while still being incremental.</p>
<p>In a picture, it looks a little like this:</p>
<p><span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="marginnote">Funnily enough, Anders’ video explicitly calls out approaches like this, saying “That’s too complicated. I’ve never seen a system succeed that does that.” (19:10) I’m not sure whether to take that as a point of a pride or a warning of impending doom.<br />
<br />
</span></span></p>
<p><img src="/assets/img/light/delete-everything.png" /></p>
<p><img src="/assets/img/dark/delete-everything.png" /></p>
<p>This approach sidesteps an annoying problem: we don’t have to figure out whether a definition was added, deleted, renamed, or moved, nor how to mutate the state in response. Rather, we just toss out everything. This is great! Sorbet <strong>already</strong> has code that’s meant to define everything inside a file, so we’re free to focus on the smaller problem of how to toss out the old stuff.</p>
<p>Another great side-effect: by reusing the code that registers everything a file defines, we bring along all the runtime assertions which enforce Sorbet’s internal invariants. Maintaining invariants is the only thing that makes working on a project like Sorbet tractable!</p>
<p>And finally, this approach is quite practical—it doesn’t require landing one huge change. Instead, the change can be built and deployed <strong>one kind of definition at a time</strong>, ordered by the data we collected in step 1. This allows for steady, low-risk progress over the project’s lifetime. In particular, we got the change working for method definitions specifically only two months into the project.</p>
<p>At the end of the day while this model for incrementality is far from ideal, it’s <strong>simple</strong> and it’s <strong>fast enough</strong>. Importantly, it restricts the work required to handle an edit to the size of the edit, instead of type checking the entire codebase, which is many orders of magnitude larger than the size of an edit.</p>
<p>After a few months of prototyping, we had rolled out support for deleting and redefining methods, then we followed up with instance and class variables and finally constant assignments and type members. The only definition kind that we haven’t handled yet is class and module definitions, which I’ll discuss in a moment.</p>
<h1 id="wait-what-took-so-long">Wait, what took so long?</h1>
<p>“You’ve made things out as though this is all very simple. Then what took so long? You’ve been working on this for months.” For the sake of explanation I’ve papered over a lot of subtlety. Here’s a sense of what I papered over:</p>
<p><strong>It took us a while to arrive at the exact idea presented here.</strong><br />
My first attempts tried and failed to do smarter things, like track additions, deletions, renames, and moves.</p>
<p>It’s only from attempting to implement it that I realized the “delete everything” approach would be simpler and also good enough.</p>
<p><strong>“Delete everything” is simpler, but not simple.</strong><br />
You still have to figure out what “everything in a file” is, which Sorbet had no need to track this before. It simply tracked “everything in the codebase.”</p>
<p>Also, some parts of Sorbet clung to the idea that nothing would be deleted. While we like to have a single source of truth for all bits of knowledge, sometimes I was surprised to find places where Sorbet effectively had more than one source of truth, which caused problems when deleting one source but forgetting the other.</p>
<p><strong>Lots of code needed restructuring.</strong><br />
Most of the refactors were to work around the fact that we avoided deleting class and module definitions. Our approach for figuring out what to delete involves an assumption that the edit changes neither classes nor modules.</p>
<p>Even still, getting Sorbet to a state where we could take advantage of that assumption involved <a href="https://github.com/sorbet/sorbet/pull/6422">no fewer than 12 changes</a> to restructure Sorbet’s internals.</p>
<p><strong>We wanted to be very deliberate about testing and correctness.</strong><br />
Probably half of the time or more was spent thinking of weird and wacky sequences of edits to expose potential bugs.</p>
<p>We couldn’t just rely on the existing tests, because tests for Sorbet’s incremental mode previously accounted for only 2% of all Sorbet tests. We 4x’d that, and now 8% of all Sorbet tests are specifically testing the incremental mode.</p>
<p><strong>As we kept writing tests, we kept finding bugs.</strong><br />
Most of these bugs were problems in the change itself. But some were pre-existing bugs in Sorbet!</p>
<p>The sheer volume of new tests we wrote helped find minimal reproducers for many bugs that we knew of but couldn’t pin down. In particular, we found and fixed the most common source of production crashes in Sorbet: a problem with updating source location information.</p>
<p>We also ran into a snag in our first production rollout where a bug meant that older Sorbet versions wouldn’t evict on-disk caches created by newer Sorbet versions in certain situations. We had to roll back our first attempt to ship methods and fix this bug before proceeding.</p>
<p>And finally, for a three-week stretch somewhere in the middle, I nerd sniped myself into fixing a couple dozen bugs in Sorbet’s <a href="https://sorbet.org/docs/generics">support for generics</a>. This had nothing to do with incrementality but was was a lot of fun and a welcome break from pure performance work.</p>
<p><br />
</p>
<p>While this approach definitely has limitations, in practice it’s had a huge impact for a low cost. Sorbet <em>feels</em> much snappier, even if sometimes it still isn’t perfect. A few months is a pretty great return for the amount of incrementality we got in return.</p>
<h1 id="can-we-make-everything-incremental">Can we make <em>everything</em> incremental?</h1>
<p>At the top of the post, I mentioned that the current split of incremental to non-incremental is 90/10. For the 10% of edits that still require a full type check, here’s how often each of the slow path reasons show up, and what it would take to address them:</p>
<p><strong>33% of slow path edits – changed definition</strong><span class="sidenote-wrapper"><label for="sn-4" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-4" class="margin-toggle"/><span class="marginnote">Since slow path edits are 10% of all edits, this bucket accounts for 3.3% of all edits.<br />
<br />
</span></span><br />
At this point, the only definitions that are not handled incrementally are class and module definitions.</p>
<p>This bucket is the trickiest, as some of the approaches we described for deleting everything break down with classes. We still have a few ideas, but this is the biggest unknown.</p>
<p><strong>28% of slow path edits – new file</strong><br />
This bucket represents any time Sorbet sees an edit that creates a file.</p>
<p>In practice, handling new <em>empty</em> files is not hard, but the first thing someone does in a new file is define a class or a module. So while fixing this bucket is easy, it’s blocked on “changed definition” above, to the point where it’s almost better to lump these buckets together and say that “changed definition” is the cause of 61% of slow path edits.</p>
<p><strong>13% of slow path edits – too many extra files</strong><br />
This bucket represents when a small number of files were edited <strong>and</strong> Sorbet could have processed the edit incrementally, but it would have involved type checking hundreds or thousands of files that didn’t change. Sorbet’s incremental mode is currently single threaded and can’t be interrupted, so naively attempting to handle these edits incrementally would have the effect of locking the user out for a long time.</p>
<p>Fixing this bucket should be as simple as taking all the fancy things we do to handle large slow path edits in parallel and making them work for incremental edits too.</p>
<p><strong>10% of slow path edits – too many files</strong><br />
This bucket represents when the number of changed files was large. Historically, since it was so rare for large edits to be handled incrementally, we short circuited as a performance optimization.</p>
<p>There’s no technical limitation why we can’t treat these edits like other edits (except for maybe ironing out some kinks).</p>
<p><strong>9% of slow path edits – package file</strong><span class="sidenote-wrapper"><label for="sn-5" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-5" class="margin-toggle"/><span class="marginnote">Not much has been written about how these files work, but it’s all built into Sorbet and open source. If you’re curious, you can dig into the test suite and see them in action.<br />
<br />
</span></span><br />
<code>__package.rb</code> files are special Ruby files used in Stripe’s codebase to enforce public/private boundaries owned by different teams. This bucket represents any change in one of these files.</p>
<p>Handling these files shouldn’t be much harder than how handling method public/private visibility incrementally works today.</p>
<p><strong>7% of slow path edits – syntax error</strong><br />
This bucket represents when Sorbet parsed a Ruby file, encountered a syntax error, <strong>and</strong> failed to recover, producing an empty parse tree.</p>
<p>First, bear in mind that this is the smallest bucket, accounting for only 0.7% of all edits! Arguably Sorbet is already quite good at <a href="/error-recovery-part-1/">recovering from syntax errors</a>.</p>
<p>But second, if Sorbet could handle changes to class or module definitions incrementally, then “failing to parse a file” looks the same as “deleting every definition in the file.” So really, we might want to bucket this in with “changed definition.”</p>
<p>That brings our final score to:</p>
<ul>
<li>68% – changed definition (classes or modules)</li>
<li>13% – too many extra files</li>
<li>10% – too many files</li>
<li>9% – package file</li>
</ul>
<p>Of these buckets, “changed definition” is the hardest, so it might be smarter to knock out the other three three first, and then circle back. Once we’ve solved all of these buckets, <strong>Sorbet will never fail to process an edit incrementally</strong>.</p>
<p>We haven’t won yet, but we’re getting close!</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#language-servers">language-servers</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

