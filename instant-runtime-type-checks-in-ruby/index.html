<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2021-04-25 20:13:11 -0400">
<meta name="description" content="A dive into runtime type checking, like the kind used in Sorbet signatures, and how the Sorbet Compiler can speed it up.">
<title>Instant Runtime Type Checks in Ruby ‚Äì Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Instant Runtime Type Checks in Ruby</h1>
    <blockquote class="metadata">
    <p class="date before-toc"><time datetime="2021-04-25 20:13:11 -0400">April 25, 2021</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">‚Üê Return home</a><br>
</nav>

<main>
<blockquote>
<p><strong>Disclaimer</strong>: this post was first drafted as a
Stripe-internal email. On December 10, 2022 I republished it here,
largely unchanged from the original. See <a
href="/old-compiler-notes/">Some Old Sorbet Compiler Notes</a> for more.
The Sorbet Compiler is still largely an experimental project: this post
is available purely for curiosity‚Äôs sake.</p>
<p>Any benchmark numbers included in this post are intended to be
educational about how the Sorbet Compiler approaches speeding up code.
They should not be taken as representative or predictive of any
real-world workload, and are likely out-of-date with respect to
improvements that have been made since this post originally
appeared.</p>
</blockquote>
<p>After an embarrassingly long break, we‚Äôre back with another post on
compiled Ruby performance! Previously in this series:</p>
<ul>
<li><a href="/types-make-array-access-faster/">Types Make Array Access
Faster</a></li>
<li><a href="/another-look-at-typed-array-access/">Another Look at Typed
Array Access</a></li>
<li><a href="/fast-while-loops-in-ruby/">Fast While Loops in
Ruby</a></li>
</ul>
<p>In this post, we‚Äôre going to look at something that I‚Äôve hinted at
for a long time and sort of taken for granted: the Sorbet Compiler is
<strong>much faster at runtime type checks</strong> than the
interpreter.</p>
<p>Why do we care? In a compiler for a dynamically-typed language,
runtime type checks are the name of the game‚Äîthey show up in all kinds
of places:</p>
<ul>
<li>When checking that arguments provided at a call site match the
method‚Äôs <code>sig</code></li>
<li>When checking the value returned by a method against that method‚Äôs
<code>sig</code></li>
<li>In the implementation of <code>T.let</code> and <code>T.cast</code>
annotations</li>
<li><a href="https://sorbet.org/docs/flow-sensitive">Flow-sensitive
checks</a> required by Sorbet, like in <code>case</code>
expressions</li>
<li>Internal ‚Äúfast path‚Äù guards for speculative optimizations,
including:
<ul>
<li>type-directed optimizations (e.g., <a
href="/types-make-array-access-faster/">Types Make Array Access
Faster</a>)</li>
<li>direct calls for <a
href="https://sorbet.org/docs/final#final-methods">final
methods</a></li>
</ul></li>
</ul>
<p>So, runtime type checks show up all over the place, but how much
faster are they? Let‚Äôs zoom in on the runtime type checks that happen in
<code>case</code> expressions with some benchmarks:</p>
<table style="width:81%;">
<colgroup>
<col style="width: 45%" />
<col style="width: 19%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">benchmark</th>
<th style="text-align: right;">interpreted</th>
<th style="text-align: right;">compiled</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/while_10_000_000.rb">while_10_000_000.rb</a></td>
<td style="text-align: right;">0.212s</td>
<td style="text-align: right;">0.070s</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a
href="https://github.com/sorbet/sorbet/blob/master/test/testdata/ruby_benchmark/stripe/case_nil_str_obj.rb">case_nil_str_obj.rb</a></td>
<td style="text-align: right;">2.227s</td>
<td style="text-align: right;">0.142s</td>
</tr>
<tr class="odd">
<td style="text-align: left;">case_nil_str_obj.rb ‚àí baseline</td>
<td style="text-align: right;">2.015s</td>
<td style="text-align: right;">0.072s</td>
</tr>
</tbody>
</table>
<p>The first benchmark, <code>while_10_000_000.rb</code>, is our
baseline. It‚Äôs just a Ruby <code>while</code> loop that increments a
counter 10 million times and then prints the counter. We subtract the
time it takes from other benchmarks to control for the fact that
compiled <code>while</code> loops really fast (see <a
href="/fast-while-loops-in-ruby">Fast While Loops in Ruby</a>).</p>
<p>Our real benchmark is <code>case_nil_str_obj.rb</code>. It has a
bunch of case expressions that basically look like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>res <span class="kw">=</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> x</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">when</span> <span class="dt">String</span> <span class="cf">then</span> <span class="dv">true</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="dv">false</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span></code></pre></div>
<p>for a selection of different classes (<code>NilClass</code>,
<code>String</code>, and <code>Object</code>) and values
(<code>nil</code> and <code>''</code>). After subtracting the baseline
from both interpreted and compiled timings, we see that what takes the
interpreter 2.015s to run takes the compiler just 72ms. (And in fact,
nearly all of that comes from the two <code>case</code> expressions
checking for <code>Object</code>‚Äîif we delete those two and leave just
<code>NilClass</code> and <code>String</code> checks, the compiled time
drops down to about 8ms ü§Ø).</p>
<p>So the Sorbet compiler is <strong>much</strong> faster at runtime
type checks than the Ruby VM‚Ä¶ why is that? There are a few reasons:</p>
<ol type="1">
<li>Sorbet‚Äôs type tests cut out the Ruby VM.</li>
<li>Type tests for common Ruby classes have fast special cases.</li>
<li>The power of LLVM gets us a lot of free wins.</li>
</ol>
<p>I‚Äôd love to cover all of these, but for the sake of keeping this note
short and sweet, I‚Äôm only going to focus on the first two. (Let me know
if you‚Äôd like to hear more about the power of LLVM though!)</p>
<p>To see what ‚Äú<strong>cutting out the Ruby VM</strong>‚Äù means, let‚Äôs
dig into a specific example. Consider some code like we saw earlier:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode ruby"><code class="sourceCode ruby"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>res <span class="kw">=</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">case</span> x</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">when</span> <span class="dt">Integer</span> <span class="cf">then</span> <span class="dv">true</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> <span class="dv">false</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end</span></span></code></pre></div>
<p>We can get the Ruby VM to tell us the bytecode instructions that it
translates this Ruby program into with the <code>ruby</code> command
line:</p>
<pre class="tight-code"><code>‚ùØ ruby --dump=insns -e &quot;x = 0; case x when Integer then true else false end&quot;
# ...
0000 putobject_INT2FIX_0_                ‚îÄ‚îê x = 0
0002 setlocal_WC_0            x@0        ‚îÄ‚îò
0004 getlocal_WC_0            x@0        ‚îÄ‚îê store `x` on the Ruby stack
0006 dup                                 ‚îÄ‚îò (for checkmatch below)
0007 opt_getinlinecache       16, &lt;is:0&gt; ‚îÄ‚îê
0010 putobject                true        ‚îÇ load ::Integer constant
0012 getconstant              :Integer    ‚îÇ (and populate inline cache)
0014 opt_setinlinecache       &lt;is:0&gt;     ‚îÄ‚îò
0016 checkmatch               2          ‚îÄ‚îê compute `when Integer`, jump
0018 branchif                 24         ‚îÄ‚îò to 0024 if there&#39;s a match
0020 pop                                 ‚îÄ‚îê
0021 putobject                false       ‚îÇ false branch
0023 leave                               ‚îÄ‚îò
0024 pop                                 ‚îÄ‚îê
0025 putobject                true        ‚îÇ true branch
0027 leave                               ‚îÄ‚îò</code></pre>
<p><em>(I‚Äôve annotated hand-annotated the output. Run the provided
command to see the original output.)</em></p>
<p>If you‚Äôre not familiar with bytecode instructions, you can imagine
this as a sort of assembly language that only the Ruby VM understands
and that it evaluates in order to execute a Ruby program.</p>
<p>So to do a type test in a <code>case</code> expression, the Ruby VM
has to:</p>
<ol type="1">
<li>Store the local variable <code>x</code> onto the Ruby stack</li>
<li>Load the constant named <code>:Integer</code> by doing a search on
<code>Object</code> and caching the result
<ul>
<li>The cache will be shared across repeated invocations of the method,
to speed up the search for next time.</li>
</ul></li>
<li>Run a <code>checkmatch</code> instruction to do the
<code>when Integer</code> comparison, and then do a
<code>branchif</code> conditional jump on the result.
<ul>
<li>Not pictured: the <code>checkmatch</code> instruction involves
searching for an <code>Integer.===</code> method definition, which is
how the Ruby VM implements class matching.</li>
</ul></li>
<li>Use the result to jump to the corresponding branch</li>
</ol>
<p>The problem is that this is an absolute <strong>ton</strong> of slow
code. Here‚Äôs a breakdown of all the things I can see that are slow, and
how the Sorbet compiler makes them faster.</p>
<p>First: storing variables on the stack (i.e., RAM) is much slower than
registers (CPU). The compiler keeps things in registers as much as
possible.</p>
<p>Next up: searching for methods is slow. In this case,
<code>Integer.===</code> is actually defined on <code>Module</code>,
which means chasing a lot of superclass pointers to find the class with
the <code>===</code> method:</p>
<pre class="plain"><code>‚ùØ irb
irb(main):001:0&gt; Integer.singleton_class.ancestors
=&gt; [#&lt;Class:Integer&gt;, #&lt;Class:Numeric&gt;, #&lt;Class:Object&gt;, #&lt;Class:BasicObject&gt;, Class, Module, Object, Kernel, BasicObject]</code></pre>
<p>Instead of searching, the compiler can just know. Sorbet knows that
<code>String.===</code> dispatches to <code>Module#===</code>, and it
knows that <code>Module#===</code> is implemented by a C function called
<a
href="https://github.com/ruby/ruby/blob/5445e0435260b449decf2ac16f9d09bae3cafe72/object.c#L1774-L1778"><code>rb_obj_is_kind_of</code></a>.
Rather than doing a method search, it just calls
<code>rb_obj_is_kind_of</code> directly.</p>
<p>More than that, sometimes the <code>===</code> method isn‚Äôt even
needed. The Ruby VM has special ways of doing type checks for the most
common classes, like <code>Integer</code>, <code>NilClass</code>,
<code>Array</code>, and more. For <code>Integer</code> specifically, if
the <a
href="https://github.com/ruby/ruby/blob/5445e0435260b449decf2ac16f9d09bae3cafe72/include/ruby/ruby.h#L444">least-significant
bit</a> of a Ruby value is <code>1</code>, then it‚Äôs an
<code>Integer</code>. Sorbet is aware of these <a
href="https://github.com/sorbet/sorbet/blob/f03e6be0599f509524a24273c0d14738048d5bc7/compiler/IREmitter/Payload.cc#L198">optimized
type tests</a> and can emit code to check them without even calling
<code>rb_obj_is_kind_of</code>.</p>
<p>And last, using a bytecode instruction for conditional branches is
expensive. Sorbet compiles the conditional jump directly to an assembly
instruction.</p>
<p>Putting that all together, in this case, Sorbet is able to do the
<code>Integer</code> type test with just three CPU instructions (I‚Äôm
showing the corresponding LLVM IR instead of assembly to make it easier
to read):</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Take arg x (stored in register %rawArg_x) and bitwise AND with 0x1</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">%17</span> = <span class="kw">and</span> <span class="dt">i64</span> <span class="fu">%rawArg_x</span>, <span class="dv">1</span>, !dbg !<span class="dv">35</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">; Compare whether %17 == 0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">%18</span> = <span class="kw">icmp</span> <span class="kw">eq</span> <span class="dt">i64</span> <span class="fu">%17</span>, <span class="dv">0</span>, !dbg !<span class="dv">35</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">; Jump to one of two branches depending on what the comparison said</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">br</span> <span class="dt">i1</span> <span class="fu">%18</span>, <span class="dt">label</span> <span class="fu">%20</span>, <span class="dt">label</span> <span class="fu">%sorbet_isa_Integer.exit.thread</span>, !dbg !<span class="dv">35</span>, !prof !<span class="dv">36</span></span></code></pre></div>
<p>Pretty amazing!</p>
<p>Runtime type checks are so fast in compiled code that we can afford
to always emit them. While most code at Stripe runs with runtime type
checking enabled, there are a handful of performance-sensitive paths in
Stripe‚Äôs codebase that use <code>.checked(:never)</code> annotations on
<code>sig</code>s to completely disable runtime type checking. This
makes the code run faster, but at the cost of runtime safety guarantees
enjoyed by other parts of the codebase. With compiled code, the checks
are so fast that we don‚Äôt have to strip them out to make the code
fast.</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#ruby">ruby</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet-compiler">sorbet-compiler</a></strong></span>
        
      </p>
      <p><a href="/">‚Üê Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

