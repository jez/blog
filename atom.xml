<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2022-02-18T06:09:04-05:00</updated><id>https://blog.jez.io/atom.xml</id><title type="html">Jake Zimmerman</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Sorbet, Generics, and Parametricity</title><link href="https://blog.jez.io/sorbet-parametricity/" rel="alternate" type="text/html" title="Sorbet, Generics, and Parametricity" /><published>2022-02-18T02:59:55-05:00</published><updated>2022-02-18T02:59:55-05:00</updated><id>https://blog.jez.io/sorbet-parametricity</id><content type="html" xml:base="https://blog.jez.io/sorbet-parametricity/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Consider this snippet of Ruby code using Sorbet:&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-11&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; fake_identity_function(x)&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;#                 ^^^^^^^^ error&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%20then%20return%200%0A%20%20else%20return%20x%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;It has the same signature as the identity function (which returns its argument unchanged), but doesn’t actually do that in all cases. In particular, on the highlighted line it checks the type of &lt;code&gt;x&lt;/code&gt; at runtime, and if it’s an &lt;code&gt;Integer&lt;/code&gt;, it always returns &lt;code&gt;0&lt;/code&gt;, regardless of the input.&lt;/p&gt;
&lt;p&gt;Sorbet flags this as an error (see the full error message in the sorbet.run link). Sometimes I get asked: “why?” The reasoning for why people think this &lt;em&gt;shouldn’t&lt;/em&gt; be an error usually looks like this: the signature just says that the output has to be the same as the input, and &lt;code&gt;Integer&lt;/code&gt; is the same as &lt;code&gt;Integer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But the fun thing is that this signature makes a stronger constraint on the implementation of the method—in this case the signature &lt;strong&gt;mandates&lt;/strong&gt; that the result is the input. The hand-wavy intuition for how to think about what’s going on is to mentally read the &lt;code&gt;type_parameters(:U)&lt;/code&gt; in the signature as “for all,” specifically, “the behavior of this function is the same &lt;em&gt;for all&lt;/em&gt; choices of the type parameters.”&lt;/p&gt;
&lt;p&gt;In that light, generics put a pretty hefty constraint on the implementation of a generic method—which is actually a good thing! It means that the caller of the method can make stronger guarantees about what the method can or cannot do, even seeing only the types. For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;), &lt;span class=&quot;wa&quot;&gt;y: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;), T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)))&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From this signature we’re guaranteed that the method has to return exactly one of the arguments we provided (&lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;) and nothing else. It can’t invent some third value and return that.&lt;/p&gt;
&lt;p&gt;But the constraints come within reason: the types don’t say anything about what side effects the function might have. This isn’t particularly unique to generics (Sorbet doesn’t track side effects no matter the types), but it is worth noting as a sneaky way that methods can do different things with different arguments. Going back to our &lt;code&gt;fake_identity_function&lt;/code&gt; example from earlier:&lt;/p&gt;
&lt;figure class=&quot;left-align-caption&quot;&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode numberSource ruby numberLines hl-12 hl-15&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:U&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; fake_identity_function(x)&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt;(x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot;&gt;&lt;/a&gt;    x&lt;/span&gt;
&lt;span id=&quot;cb3-14&quot;&gt;&lt;a href=&quot;#cb3-14&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-15&quot;&gt;&lt;a href=&quot;#cb3-15&quot;&gt;&lt;/a&gt;    x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# error: Method `even?` does not exist&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-16&quot;&gt;&lt;a href=&quot;#cb3-16&quot;&gt;&lt;/a&gt;    x&lt;/span&gt;
&lt;span id=&quot;cb3-17&quot;&gt;&lt;a href=&quot;#cb3-17&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-18&quot;&gt;&lt;a href=&quot;#cb3-18&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20do%0A%20%20type_parameters%28%3AU%29%0A%20%20%20%20.params%28x%3A%20T.type_parameter%28%3AU%29%29%0A%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0Aend%0Adef%20fake_identity_function%28x%29%0A%20%20case%20x%0A%20%20when%20Integer%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20else%0A%20%20%20%20x.even%3F%0A%20%20%20%20x%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;In this example, the side effect of calling &lt;code&gt;puts(x.even?)&lt;/code&gt; only happens if the type is &lt;code&gt;Integer&lt;/code&gt;, breaking the intuition that the behavior of this function is uniform for all input types.&lt;/p&gt;
&lt;p&gt;If Sorbet wanted,&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Unlike everything we’ve discussed so far, I’m not actually sure whether that was a conscious decision or an accident. But it is a pretty useful feature in practice.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; it could prevent this particular form of anti-uniformity by not allowing any &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;control-flow-sensitive&lt;/a&gt; type updates. But it wouldn’t change the fact that, for example, one implementation of &lt;code&gt;fake_identity_function&lt;/code&gt; could always print one log line, while another implementation could always print two log lines. The only uniformity guarantees we get are about specifically what’s captured in the input and output types.&lt;/p&gt;
&lt;p&gt;It turns out that there’s a name for this property of generic functions: &lt;a href=&quot;https://en.wikipedia.org/wiki/Parametricity&quot;&gt;parametricity&lt;/a&gt;. It’s a fancy word but it basically means what we’ve talked about here: the implementation of generic functions are constrained to basically only do one thing, modulo side-effects. It goes further than just intuition though, and people have done interesting work to formalize the intuitions into proofs.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="plt" /><summary type="html">← Return home Consider this snippet of Ruby code using Sorbet:</summary></entry><entry><title type="html">Typed Errors in Sorbet</title><link href="https://blog.jez.io/typed-errors-sorbet/" rel="alternate" type="text/html" title="Typed Errors in Sorbet" /><published>2021-06-05T01:12:37-04:00</published><updated>2021-06-05T01:12:37-04:00</updated><id>https://blog.jez.io/typed-errors-sorbet</id><content type="html" xml:base="https://blog.jez.io/typed-errors-sorbet/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I really like this post from Matt Parsons, &lt;a href=&quot;https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html&quot;&gt;The Trouble with Typed Errors&lt;/a&gt;. It’s written for an audience writing Haskell, but if you can grok Haskell syntax, it’s worth the read because the lessons apply broadly to most statically typed programming languages.&lt;/p&gt;
&lt;p&gt;If you haven’t read it (or it’s been a while) the setup is basically: typing errors is hard, and nearly every solution is either brittle, clunky, verbose, or uses powerful type system features that we didn’t want to have to reach for.&lt;/p&gt;
&lt;p&gt;Hidden towards the bottom of the post, we find:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In PureScript or OCaml, you can use open variant types to do this flawlessly. Haskell doesn’t have open variants, and the attempts to &amp;gt; mock them end up quite clumsy to use in practice.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What Matt calls “open variant types” I call &lt;strong&gt;ad hoc union types&lt;/strong&gt; (see my previous post about &lt;a href=&quot;https://blog.jez.io/union-types-checked-exceptions/&quot;&gt;checked exceptions and Sorbet&lt;/a&gt;). Naming aside, Sorbet has them! We don’t have to suffer from clunky error handling!&lt;/p&gt;
&lt;p&gt;I thought it’d be interesting to show what Matt meant in this quote by translating his example to Sorbet.&lt;/p&gt;
&lt;p&gt;I wrote a complete, working example, but rather than repeat the whole thing here, I’m just going to excerpt the good stuff. If you’re wondering how something is defined in full, check the full example:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0A%0A%23%20This%20is%20a%20re-implementation%20of%20Matt%20Parsons&amp;#39;s%20%22The%20Trouble%20with%20Typed%0A%23%20Errors%22%20in%20Sorbet%20(Ruby)%20because%20I%20think%20Sorbet%20happens%20to%20handle%20it%0A%23%20pretty%20well%20all%20things%20considered.%0A%23%0A%23%20%20%20%20%20%3Chttps%3A%2F%2Fwww.parsonsmatt.org%2F2018%2F11%2F03%2Ftrouble_with_typed_errors.html%3E%0A%23%0A%23%20Specifically%2C%20he%20mentions%0A%23%0A%23%20%20%20%20%20In%20PureScript%20or%20OCaml%2C%20you%20can%20use%20open%20variant%20types%20to%20do%20this%0A%23%20%20%20%20%20flawlessly.%0A%23%0A%23%20and%20Sorbet%20more%20or%20less%20has%20those%20(untagged%20unions).%20It&amp;#39;s%20interesting%0A%23%20to%20see%20what%20that%20means%20for%20being%20able%20to%20track%20errors%2C%20because%20we%0A%23%20actually%20use%20Sorbet%20in%20a%20huge%20codebase%20at%20work.%20Tracking%20all%20the%20kinds%0A%23%20of%20errors%20that%20could%20happen--and%20no%20more--can%20make%20code%20far%20easier%20to%0A%23%20understand.%0A%0A%23%20To%20run%20this%20file%3A%0A%23%0A%23%20%20%20gem%20install%20sorbet-runtime%0A%23%20%20%20ruby%20typed-errors.rb%0A%0Arequire%20&amp;#39;sorbet-runtime&amp;#39;%0A%0A%23%20There&amp;#39;s%20a%20bug%20in%20Sorbet%20that%20forces%20us%20to%20wrap%20all%20this%20code%20in%20a%0A%23%20class%2C%20but%20I%20have%20a%20PR%20open%20to%20fix%20it.%20For%20now%2C%20we%20tolerate%20it.%0Aclass%20Main%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20%23%20-----%20Custom%20error%20types%20-----%0A%0A%20%20%23%20Defining%20custom%20data%20types%20is%20a%20little%20clunky%20in%20Ruby%20%2F%20Sorbet.%20You%0A%20%20%23%20have%20to%20chose%20whether%20you%20want%20a%20plain%20class%2C%20an%20enum%2C%20a%20sealed%0A%20%20%23%20class%20hierarchy%2C%20etc.%20In%20a%20real%20codebase%2C%20I%20think%20if%20you%20were%20going%0A%20%20%23%20to%20this%20length%20to%20care%20for%20errors%20the%20kinds%20of%20errors%20that%20you%20have%0A%20%20%23%20are%20usually%20pretty%20rich%20(e.g.%2C%20there&amp;#39;s%20a%20message%20and%20context%20with%0A%20%20%23%20the%20failures)%2C%20so%20you&amp;#39;d%20probably%20go%20with%20the%20sealed%20class%20hierarchy.%0A%20%20%23%0A%20%20%23%20For%20this%20example%2C%20I%20chose%20three%20different%20ways%20to%20just%20show%20them%20all.%0A%0A%20%20class%20HeadError%0A%20%20end%0A%0A%20%20class%20LookupError%20%3C%20T%3A%3AEnum%0A%20%20%20%20enums%20do%0A%20%20%20%20%20%20KeyWasNotPresent%20%3D%20new%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20module%20ParseError%0A%20%20%20%20extend%20T%3A%3AHelpers%0A%20%20%20%20sealed!%0A%0A%20%20%20%20class%20UnexpectedChar%20%3C%20T%3A%3AStruct%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20%20%20prop%20%3Amessage%2C%20String%0A%20%20%20%20end%0A%0A%20%20%20%20class%20RanOutOfInput%0A%20%20%20%20%20%20include%20ParseError%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Helper%20methods%20-----%0A%0A%20%20%23%20Again%2C%20concise%20syntax%20is%20not%20Sorbet&amp;#39;s%20strong%20suit.%20The%20signature%0A%20%20%23%20annotations%20are%20pretty%20verbose%20here%20(especially%20generics)%20but%20they%0A%20%20%23%20pretty%20much%20exactly%20map%20to%20the%20Haskell%20functions%20in%20the%20post.%0A%0A%20%20sig%20do%0A%20%20%20%20%20%20params(xs%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(String%2C%20HeadError))%0A%20%20end%0A%20%20def%20self.head(xs)%0A%20%20%20%20case%20xs.size%0A%20%20%20%20when%200%20then%20HeadError.new%0A%20%20%20%20else%20T.must(xs%5B0%5D)%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20type_parameters(%3AK%2C%20%3AV)%0A%20%20%20%20%20%20.params(%0A%20%20%20%20%20%20%20%20hash%3A%20T%3A%3AHash%5BT.type_parameter(%3AK)%2C%20T.type_parameter(%3AV)%5D%2C%0A%20%20%20%20%20%20%20%20key%3A%20T.type_parameter(%3AK)%0A%20%20%20%20%20%20)%0A%20%20%20%20%20%20.returns(T.any(T.type_parameter(%3AV)%2C%20LookupError))%0A%20%20end%0A%20%20def%20self.lookup(hash%2C%20key)%0A%20%20%20%20if%20hash.key%3F(key)%0A%20%20%20%20%20%20hash.fetch(key)%0A%20%20%20%20else%0A%20%20%20%20%20%20LookupError%3A%3AKeyWasNotPresent%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20sig%20do%0A%20%20%20%20params(source%3A%20String).returns(T.any(Integer%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.parse(source)%0A%20%20%20%20case%20source%0A%20%20%20%20when%20%22%22%20then%20ParseError%3A%3ARanOutOfInput.new%0A%20%20%20%20else%0A%20%20%20%20%20%20begin%0A%20%20%20%20%20%20%20%20Integer(source%2C%2010)%0A%20%20%20%20%20%20rescue%20ArgumentError%20%3D%3E%20exn%0A%20%20%20%20%20%20%20%20ParseError%3A%3AUnexpectedChar.new(message%3A%20exn.message)%0A%20%20%20%20%20%20end%0A%20%20%20%20end%0A%20%20end%0A%0A%20%20%23%20-----%20Composing%20errors%20-----%0A%0A%20%20STR_MAP%20%3D%20T.let(%7B%0A%20%20%20%20%224__%22%20%3D%3E%20%222%22%0A%20%20%7D%2C%20T%3A%3AHash%5BString%2C%20String%5D)%0A%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20HeadError%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.foo(str)%0A%20%20%20%20%23%20These%20%60return%60%20lines%20are%20definitely%20not%20as%20convenient%20as%20do%0A%20%20%20%20%23%20notation%20in%20Haskell%2C%20but%20the%20interesting%20thing%20is%20that%20they&amp;#39;re%0A%20%20%20%20%23%20still%20pretty%20nice%3A%20because%20of%20flow-sensitive%20typing%2C%20the%20type%20of%0A%20%20%20%20%23%20%60c%60%20changes%2C%20as%20commented%3A%0A%20%20%20%20c%20%3D%20head(str)%20%23%20%3D%3E%20c%20%3A%20T.any(String%2C%20HeadError)%0A%20%20%20%20return%20c%20unless%20c.is_a%3F(String)%0A%20%20%20%20%23%20%3D%3E%20c%20%3A%20String%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(%22%23%7Bc%7D%23%7Br%7D%22)%0A%20%20end%0A%0A%20%20%23%20This%20method%20doesn&amp;#39;t%20call%20%60head%60%20like%20before%2C%20so%20it%20doesn&amp;#39;t%20need%20to%0A%20%20%23%20have%20%60HeadError%60%20in%20the%20return%20type.%0A%20%20sig%20do%0A%20%20%20%20params(str%3A%20String)%0A%20%20%20%20%20%20.returns(T.any(Integer%2C%20LookupError%2C%20ParseError))%0A%20%20end%0A%20%20def%20self.bar(str)%0A%20%20%20%20r%20%3D%20lookup(STR_MAP%2C%20str)%0A%20%20%20%20return%20r%20unless%20r.is_a%3F(String)%0A%20%20%20%20parse(r)%0A%20%20end%0A%0A%20%20p%20foo(%224__%22)%0A%20%20p%20bar(%224__%22)%0Aend%0A%0A%23%20Because%20%60T.any%60%20can%20create%20ad%20hoc%2C%20untagged%20union%20types%20anywhere%2C%0A%23%20there&amp;#39;s%20no%20need%20to%20define%20an%20%60AllErrorsEver%60%20data%20type%20like%20the%20reader%0A%23%20was%20tempted%20to%20in%20the%20Typed%20Errors%20blog%20post.%0A%23%0A%23%20If%20you%20find%20that%20a%20particular%20set%20of%20errors%20are%20showing%20up%20super%0A%23%20frequently%2C%20you%20can%20lurk%20them%20into%20a%20type%20alias%3A%0A%23%0A%23%20%20%20%20%20MostCommonErrors%20%3D%20T.type_alias%20%7BT.any(LookupError%2C%20ParseError)%7D%0A%23%0A%23%20and%20then%20use%20this%20alias%20in%20various%20places.%0A%23%0A%23%20One%20other%20note%3A%20to%20make%20this%20pattern%20nicer%2C%20code%20might%20want%20to%0A%23%20explicitly%20box%20up%20successful%20results%2C%20with%20a%20type%20like%0A%23%0A%23%20%20%20%20%20class%20Ok%20%3C%20T%3A%3AStruct%0A%23%20%20%20%20%20%20%20extend%20T%3A%3AGeneric%0A%23%20%20%20%20%20%20%20Type%20%3D%20type_member%0A%23%20%20%20%20%20%20%20prop%20%3Aval%2C%20Type%0A%23%20%20%20%20%20end%0A%23%0A%23%20So%20then%20you&amp;#39;d%20have%0A%23%20%20%20%20%20T.any(Ok%5BString%5D%2C%20MostCommonErrors)%0A%23%20and%20you%20could%20do%20make%20all%20the%20%60return%60%20lines%20always%20look%20the%20same%3A%0A%23%20%20%20%20%20return%20x%20unless%20x.is_a%3F(Ok)%0A%23%20but%20the%20flipside%20would%20mean%20that%20you&amp;#39;d%20have%20to%20use%20%60.val%60%20at%20all%20the%0A%23%20places%20that%20you%20would%20have%20normally%20used%20%60x%60%3A%0A%23%20%20%20%20%20parse(x.val)%0A%23%20so%20it&amp;#39;s%20maybe%20not%20worth%20it.%0A%0A&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;First, here’s how we’d type the three running helper methods from Matt’s post:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Returns the first letter of the input,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# or returns `HeadError` if empty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;xs: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.head&lt;/span&gt;(xs); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Gets the value for `key` in `hash`, or returns LookupError.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# This is normally defined in the stdlib, and in trying to&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# match Matt&amp;#39;s post, it ends up not being super idiomatic,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# but the types still work out.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  type_parameters(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-14&quot;&gt;&lt;a href=&quot;#cb1-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.params&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb1-15&quot;&gt;&lt;a href=&quot;#cb1-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;hash: &lt;/span&gt;T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;), T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb1-16&quot;&gt;&lt;a href=&quot;#cb1-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;key: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:K&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb1-17&quot;&gt;&lt;a href=&quot;#cb1-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    )&lt;/span&gt;
&lt;span id=&quot;cb1-18&quot;&gt;&lt;a href=&quot;#cb1-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.type_parameter&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;:V&lt;/span&gt;), &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb1-19&quot;&gt;&lt;a href=&quot;#cb1-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-20&quot;&gt;&lt;a href=&quot;#cb1-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.lookup&lt;/span&gt;(hash, key); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; en&lt;/span&gt;
&lt;span id=&quot;cb1-21&quot;&gt;&lt;a href=&quot;#cb1-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-22&quot;&gt;&lt;a href=&quot;#cb1-22&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-23&quot;&gt;&lt;a href=&quot;#cb1-23&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Convert a String to an integer, or return ParseError.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-24&quot;&gt;&lt;a href=&quot;#cb1-24&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;source: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-25&quot;&gt;&lt;a href=&quot;#cb1-25&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.parse&lt;/span&gt;(source); &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice how in all three cases, we use a normal &lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;Sorbet union type&lt;/a&gt; in the return, like &lt;code&gt;T.any(String, HeadError)&lt;/code&gt;. All of the error types are just user-defined classes. For example, &lt;code&gt;HeadError&lt;/code&gt; is just defined like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;ParseError&lt;/code&gt; is defined using &lt;a href=&quot;https://sorbet.org/docs/sealed&quot;&gt;sealed classes&lt;/a&gt; and &lt;a href=&quot;https://sorbet.org/docs/tstruct&quot;&gt;typed structs&lt;/a&gt; to approximate algebraic data types in other typed languages:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Helpers&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  sealed!&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UnexpectedChar&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Struct&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    prop &lt;span class=&quot;wa&quot;&gt;:message&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RanOutOfInput&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then at the caller side, it’s simple to handle the errors:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;HeadError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.foo&lt;/span&gt;(str)&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  c &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; head(str) &lt;span class=&quot;co&quot;&gt;# =&amp;gt; c : T.any(String, HeadError)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; c &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; c&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# =&amp;gt; c : String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  r &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; lookup(&lt;span class=&quot;cn&quot;&gt;STR_MAP&lt;/span&gt;, str)&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; r &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; r&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  parse(&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;c&lt;span class=&quot;sc&quot;&gt;}#{&lt;/span&gt;r&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-12&quot;&gt;&lt;a href=&quot;#cb4-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that the return type includes the possible errors, so we have to handle them. This example handles the errors by checking for success and returning early with the error otherwise. This manifests in the return type of &lt;code&gt;foo&lt;/code&gt;, which mentions four outcomes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a successful result (&lt;code&gt;Integer&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;three kinds of failures (&lt;code&gt;HeadError&lt;/code&gt;, &lt;code&gt;LookupError&lt;/code&gt;, and &lt;code&gt;ParseError&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It would have worked equally well to handle and recover from any or all of the errors: Sorbet knows exactly which error is returned by which method, so there’s never a burden of handling more errors than are possible.&lt;/p&gt;
&lt;p&gt;It’s fun that what makes this work is Sorbet’s natural &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;flow-sensitive typing&lt;/a&gt;, not some special language feature. Notice how before and after the first early return, Sorbet updates its knowledge of the type of &lt;code&gt;c&lt;/code&gt; (shown in the comments) because it knows how &lt;code&gt;is_a?&lt;/code&gt; works.&lt;/p&gt;
&lt;p&gt;Another example: if some other method only calls &lt;code&gt;lookup&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; (but not &lt;code&gt;head&lt;/code&gt;), it doesn’t have to mention &lt;code&gt;HeadError&lt;/code&gt; in its return:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# does need to mention HeadError&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb5-5&quot;&gt;&lt;a href=&quot;#cb5-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-6&quot;&gt;&lt;a href=&quot;#cb5-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.bar&lt;/span&gt;(str)&lt;/span&gt;
&lt;span id=&quot;cb5-7&quot;&gt;&lt;a href=&quot;#cb5-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  r &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; lookup(&lt;span class=&quot;cn&quot;&gt;STR_MAP&lt;/span&gt;, str)&lt;/span&gt;
&lt;span id=&quot;cb5-8&quot;&gt;&lt;a href=&quot;#cb5-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; r &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; r&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb5-9&quot;&gt;&lt;a href=&quot;#cb5-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  parse(r)&lt;/span&gt;
&lt;span id=&quot;cb5-10&quot;&gt;&lt;a href=&quot;#cb5-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And while there’s never a &lt;strong&gt;need&lt;/strong&gt; to predeclare one monolithic error type (like &lt;code&gt;AllErrorsEver&lt;/code&gt; in Matt’s post), if it happens to be convenient, Sorbet still lets you, using type aliases. For example, maybe there are a bunch of methods that all return &lt;code&gt;LookupError&lt;/code&gt; and &lt;code&gt;ParseError&lt;/code&gt;. We can factor that out into a type alias:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;MostCommonErrors&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; T&lt;span class=&quot;at&quot;&gt;.type_alias&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;LookupError&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;)&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s it! Sorbet’s union types in method returns provide a low-friction, high value way to model how methods can fail.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">← Return home I really like this post from Matt Parsons, The Trouble with Typed Errors. It’s written for an audience writing Haskell, but if you can grok Haskell syntax, it’s worth the read because the lessons apply broadly to most statically typed programming languages.</summary></entry><entry><title type="html">Sorbet Does Not Have Checked Exceptions</title><link href="https://blog.jez.io/union-types-checked-exceptions/" rel="alternate" type="text/html" title="Sorbet Does Not Have Checked Exceptions" /><published>2021-05-29T04:21:41-04:00</published><updated>2021-05-29T04:21:41-04:00</updated><id>https://blog.jez.io/union-types-checked-exceptions</id><content type="html" xml:base="https://blog.jez.io/union-types-checked-exceptions/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#background-sorbets-union-types&quot;&gt;Background: Sorbet’s union types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#example-from-checked-exceptions-to-union-types&quot;&gt;Example: From checked exceptions to union types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#analysis&quot;&gt;Analysis: Why the union types approach is better&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix&quot;&gt;Appendix: Checked Exceptions&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Here’s a common question I get asked about Sorbet:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Does Sorbet support checked exceptions, like Java?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(In fact, this was the &lt;a href=&quot;https://youtu.be/odmlf_ezsBo?t=1921&quot;&gt;first question&lt;/a&gt; I was asked at my &lt;a href=&quot;https://jez.io/talks/state-of-sorbet-2019/&quot;&gt;first conference talk&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The answer: Sorbet doesn’t support checked exceptions, and I don’t think it ever should.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Before I dive in, there are two pretexts I’m assuming: either you asked this question and someone linked you this post, or the post title was enough to catch your attention. Either way, I’m going to take for granted that you know what I mean by “checked exceptions.” If you want a quick refresher, jump down to the &lt;a href=&quot;#appendix&quot;&gt;Appendix&lt;/a&gt; and then come back.&lt;/p&gt;
&lt;p&gt;My claim is that checked exceptions are a poor man’s ad hoc union types, that since Sorbet has ad hoc union types it doesn’t need checked exceptions. I’ll discuss this claim in three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I’ll give some background on what it means for union types to be “ad hoc,” which applies to Sorbet’s union types but are somewhat rare.&lt;/li&gt;
&lt;li&gt;I’ll describe a translation from checked exceptions in Java to union-typed returns in Ruby with a concrete example.&lt;/li&gt;
&lt;li&gt;I’ll give evidence for why the union types approach is better.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(If you want to skip straight to the good stuff, the analysis &lt;a href=&quot;#analysis&quot;&gt;is down here&lt;/a&gt;.)&lt;/p&gt;
&lt;h1 id=&quot;background-sorbets-union-types&quot;&gt;Background: Sorbet’s union types&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The throws clause is the only point in the entire Java language that allows union types. You can tack “throws A,B,C” onto a method signature meaning it might throw A or B or C, but outside of the throws clause you cannot say “type A or B or C” in Java.&lt;/p&gt;
&lt;p&gt;— James Iry, &lt;em&gt;&lt;a href=&quot;http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html&quot;&gt;Checked Exceptions Might Have Their Place, But It Isn’t In Java&lt;/a&gt;&lt;/em&gt; (2012)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sorbet supports &lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;union types&lt;/a&gt;. More specifically, Sorbet’s union types are ad hoc: any number of types can be unioned together on demand:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;returns(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(A, B, C))&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo; &lt;span class=&quot;kw&quot;&gt;...&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By contrast, many languages with union types require predeclaring a union’s variants, for example in Rust:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode rust&quot;&gt;&lt;code class=&quot;sourceCode rust&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; AorBorC &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    A(A)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    B(B)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    C(C)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That Sorbet allows defining union types on demand is similar to Java’s &lt;code&gt;throws&lt;/code&gt; clause, but more powerful: &lt;code&gt;throws A, B, C&lt;/code&gt; is not a type, while &lt;code&gt;T.any(A, B, C)&lt;/code&gt; is. We’ll see why that matters below.&lt;/p&gt;
&lt;h1 id=&quot;example-from-checked-exceptions-to-union-types&quot;&gt;Example: From checked exceptions to union types&lt;/h1&gt;
&lt;p&gt;Using Sorbet’s ad hoc union types, it’s mechanical to convert Java-style checked exceptions to Sorbet-annotated Ruby. To demonstrate:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;Currency&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;parseCurrency&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;String&lt;/span&gt; currencyStr) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;ParseException&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;bu&quot;&gt;Currency&lt;/span&gt; currency = KNOWN_CURRENCIES.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(currencyStr);&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (currency == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;        &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;ParseException&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;          &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;#39;&amp;quot;&lt;/span&gt; currencyStr + &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;#39; is not a valid currency&amp;quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; currency;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a somewhat contrived Java method, but it’ll be good enough to demonstrate the concepts.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;parseCurrency&lt;/code&gt; is given a string it can’t handle, it raises a &lt;code&gt;ParseException&lt;/code&gt;. It declares this with &lt;code&gt;throws&lt;/code&gt; because &lt;code&gt;ParseException&lt;/code&gt; is a checked exception. If the currency string is recognized, it returns some &lt;code&gt;Currency&lt;/code&gt; object.&lt;/p&gt;
&lt;p&gt;Here’s how we’d write that in Sorbet:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (0) Ruby&amp;#39;s standard library doesn&amp;#39;t have `ParseException`,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# so I&amp;#39;ve re-implemented it.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Struct&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  const &lt;span class=&quot;wa&quot;&gt;:message&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  const &lt;span class=&quot;wa&quot;&gt;:offset&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (1) return type + `throws` becomes just `returns`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (2) Return type uses `T.any`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;currency_str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb4-12&quot;&gt;&lt;a href=&quot;#cb4-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Currency&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb4-13&quot;&gt;&lt;a href=&quot;#cb4-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-14&quot;&gt;&lt;a href=&quot;#cb4-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; parse_currency(currency_str)&lt;/span&gt;
&lt;span id=&quot;cb4-15&quot;&gt;&lt;a href=&quot;#cb4-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  currency &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;KNOWN_CURRENCIES&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;currency_str&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-16&quot;&gt;&lt;a href=&quot;#cb4-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; currency&lt;span class=&quot;at&quot;&gt;.nil?&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-17&quot;&gt;&lt;a href=&quot;#cb4-17&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;# (3) `throw` becomes `return`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-18&quot;&gt;&lt;a href=&quot;#cb4-18&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;(&lt;/span&gt;
&lt;span id=&quot;cb4-19&quot;&gt;&lt;a href=&quot;#cb4-19&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;message: &lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;#{&lt;/span&gt;currency_str&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;#39; is not a valid currency&amp;quot;&lt;/span&gt;,&lt;/span&gt;
&lt;span id=&quot;cb4-20&quot;&gt;&lt;a href=&quot;#cb4-20&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;      &lt;span class=&quot;wa&quot;&gt;offset: &lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-21&quot;&gt;&lt;a href=&quot;#cb4-21&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    )&lt;/span&gt;
&lt;span id=&quot;cb4-22&quot;&gt;&lt;a href=&quot;#cb4-22&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-23&quot;&gt;&lt;a href=&quot;#cb4-23&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-24&quot;&gt;&lt;a href=&quot;#cb4-24&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  currency&lt;/span&gt;
&lt;span id=&quot;cb4-25&quot;&gt;&lt;a href=&quot;#cb4-25&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The important changes:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Where Java had a return type and a &lt;code&gt;throws&lt;/code&gt; clause, Sorbet just has a return type.&lt;/li&gt;
&lt;li&gt;Sorbet’s return type is a union type (&lt;code&gt;T.any(...)&lt;/code&gt;). It mentions the Java method’s return type and all the exceptions mentioned in the &lt;code&gt;throws&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Where the Java example uses &lt;code&gt;throw&lt;/code&gt;, the Ruby example uses &lt;code&gt;return&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Our translation isn’t complete until we see how the &lt;code&gt;parseCurrency&lt;/code&gt; caller side changes. In Java, we call &lt;code&gt;parseCurrency&lt;/code&gt; like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;Charge &lt;span class=&quot;fu&quot;&gt;createCharge&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; amount, &lt;span class=&quot;bu&quot;&gt;String&lt;/span&gt; currencyStr) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;ParseException&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;bu&quot;&gt;Currency&lt;/span&gt; currency = &lt;span class=&quot;fu&quot;&gt;parseCurrency&lt;/span&gt;(currencyStr);&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Charge&lt;/span&gt;(amount, currency);&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With Sorbet, this snippet becomes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  params(&lt;span class=&quot;wa&quot;&gt;amount: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;currency_str: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;at&quot;&gt;.returns&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Charge&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;ParseError&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; create_charge(amount, currency_str)&lt;/span&gt;
&lt;span id=&quot;cb6-6&quot;&gt;&lt;a href=&quot;#cb6-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  currency &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; parse_currency(currency_str)&lt;/span&gt;
&lt;span id=&quot;cb6-7&quot;&gt;&lt;a href=&quot;#cb6-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; currency &lt;span class=&quot;cf&quot;&gt;unless&lt;/span&gt; currency&lt;span class=&quot;at&quot;&gt;.is_a?&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;Currency&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&quot;cb6-8&quot;&gt;&lt;a href=&quot;#cb6-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-9&quot;&gt;&lt;a href=&quot;#cb6-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;dt&quot;&gt;Charge&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;(&lt;span class=&quot;wa&quot;&gt;amount: &lt;/span&gt;amount, &lt;span class=&quot;wa&quot;&gt;currency: &lt;/span&gt;currency)&lt;/span&gt;
&lt;span id=&quot;cb6-10&quot;&gt;&lt;a href=&quot;#cb6-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As before, the &lt;code&gt;throws&lt;/code&gt; clause in Java becomes a union-typed return in Ruby.&lt;/p&gt;
&lt;p&gt;The new bit is the explicit &lt;code&gt;return ... unless ...&lt;/code&gt;. Whereas uncaught exceptions implicitly bubble up to the caller, return values only bubble up if explicitly returned. This is a key benefit of the union types approach, which brings us to our next section.&lt;/p&gt;
&lt;h1 id=&quot;analysis&quot;&gt;Analysis: Why the union types approach is better&lt;/h1&gt;
&lt;p&gt;To recap, Sorbet’s union types are ad hoc, much in the same sense as the classes mentioned in Java’s &lt;code&gt;throws&lt;/code&gt; clause. When converting from &lt;code&gt;Java&lt;/code&gt; to &lt;code&gt;Ruby&lt;/code&gt;, a single, union-typed return takes the place of a separate return type and &lt;code&gt;throws&lt;/code&gt; clause.&lt;/p&gt;
&lt;p&gt;First off, this translation preserves the best parts of checked exceptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A method’s failure modes still appear in an &lt;strong&gt;explicit, public API&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In both Java and Ruby, the method signature behaves as machine-checked error documentation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ad hoc error specifications enable &lt;strong&gt;low-friction composition&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;In both Java and Ruby, if our method is the first to combine two methods with unrelated failure modes, there’s no ceremony to predeclare that combination. Instead, we just mention one more class in the method’s signature.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But this approach is not only as good, it’s better, because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;As a language feature, &lt;strong&gt;union types are not special&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Union types are types. Like other types, we can store them in variables. We can factor common error recovery code into helper functions. We can map functions returning union types over lists. We can write type aliases that abbreviate commonly-grouped error classes. We can’t do any of this with checked exceptions, and this is the most common complaint against them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Union types have &lt;strong&gt;call-site granularity&lt;/strong&gt;, not method-body granularity.&lt;/p&gt;
&lt;p&gt;The union types approach forces a choice of how to handle errors at each call site. This is more robust in the face of changing code, because new call sites should not necessarily inherit the error handling logic of existing call sites. Just because one &lt;code&gt;ParseException&lt;/code&gt; was uncaught and mentioned in the &lt;code&gt;throws&lt;/code&gt; does not mean all of them should be.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And finally, let me get out ahead of some common counter arguments.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The union types approach requires more typing at the call site!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yep. But I’ve already counted this as a blessing, not a curse.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But real-world Ruby code already uses exceptions!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Yep. But in Java too, the world is already split into checked and unchecked exceptions. In both Java and Ruby, exceptions are a fact of life, and you’ll always need a way to deal with unexpected exceptions (e.g., comprehensive tests, automated production alerting, etc.).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;With checked exceptions, I could handle all the failures at once!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That’s true; with checked exceptions, it’s easy to write a single &lt;code&gt;catch&lt;/code&gt; statement that handles all failures due to, say, a &lt;code&gt;ParseException&lt;/code&gt; in a whole region of code, avoiding the need for code repetition.&lt;/p&gt;
&lt;p&gt;The upshot is that with union types, we can just use functions. Take everything in the &lt;code&gt;catch&lt;/code&gt; body, put it in a helper function, and call it at each call site. This cuts down on duplication, and I already mentioned how call-site granularity is a win.&lt;/p&gt;
&lt;p&gt;That’s pretty much it. Sorbet doesn’t need checked exceptions, it already has ad hoc union types.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;appendix&quot;&gt;Appendix: Checked Exceptions&lt;/h1&gt;
&lt;p&gt;As a quick refresher, &lt;a href=&quot;https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions&quot;&gt;checked exceptions&lt;/a&gt; are a feature popularized by Java. The syntax looks like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doThing&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; MyException {&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;throws&lt;/code&gt; keyword is a part of the method’s signature, just like argument and return types. It declares that this method might throw &lt;code&gt;MyException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since it’s a part of this method’s signature the &lt;code&gt;throws&lt;/code&gt; annotation will be checked at all call sites (just like argument and return types). A method containing calls to &lt;code&gt;doThing&lt;/code&gt; must either &lt;code&gt;catch&lt;/code&gt; all mentioned exceptions or repeat any maybe-thrown-but-uncaught exceptions in its own &lt;code&gt;throws&lt;/code&gt; clause.&lt;/p&gt;
&lt;p&gt;If a method throws multiple classes of exceptions, they can all be listed:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doThing&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; MyException, YourException, AnotherException {&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The argument in favor of checked exceptions is that they’re explicit and machine-checked. Users don’t have to guess at what a method might throw, or hope that there’s accurate documentation—all benefits shared by static typing in general, which is a sympathetic goal.&lt;/p&gt;
&lt;p&gt;Checked exceptions seem like a good feature on paper. In practice, they’re generally regretted. I’m nowhere near the first person to come to this conclusion, so instead I’ll link you to some previous discussions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.artima.com/articles/the-trouble-with-checked-exceptions&quot;&gt;The Trouble with Checked Exceptions&lt;/a&gt;, A Conversation with Anders Hejlsberg&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://james-iry.blogspot.com/2012/02/checked-exceptions-might-have-their.html&quot;&gt;Checked Exceptions Might Have Their Place, But It Isn’t In Java&lt;/a&gt;, by James Iry&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ericlippert.com/2008/09/10/vexing-exceptions/&quot;&gt;Vexing Exceptions&lt;/a&gt;, by Eric Lippert&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(The last one isn’t actually about checked exceptions: it’s just about exceptions and I like it, so I included it.)&lt;/p&gt;
&lt;p&gt;Java has been copied and imitated for decades. Among all the features we see other languages copy from Java, checked exceptions are absent.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">← Return home Here’s a common question I get asked about Sorbet:</summary></entry><entry><title type="html">Exploring Ruby with clangd</title><link href="https://blog.jez.io/clangd-ruby/" rel="alternate" type="text/html" title="Exploring Ruby with clangd" /><published>2020-07-21T18:40:23-04:00</published><updated>2020-07-21T18:40:23-04:00</updated><id>https://blog.jez.io/clangd-ruby</id><content type="html" xml:base="https://blog.jez.io/clangd-ruby/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#steps&quot;&gt;Steps&lt;/a&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#install-bear&quot;&gt;1. Install &lt;span&gt;Bear&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#clone-the-ruby-source-code.&quot;&gt;2. Clone the Ruby source code.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#configure-the-ruby-build.&quot;&gt;3. Configure the Ruby build.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#use-bear-to-invoke-make&quot;&gt;4. Use &lt;code&gt;bear&lt;/code&gt; to invoke &lt;code&gt;make&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#thats-it&quot;&gt;5. That’s it!&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-building-bear-from-source&quot;&gt;Appendix: Building Bear from source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-lsp-in-neovim-with-languageclient-neovim&quot;&gt;Appendix: LSP in Neovim with LanguageClient-neovim&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I’ve managed to get LSP-based IDE features powered by &lt;a href=&quot;https://clangd.llvm.org/&quot;&gt;clangd&lt;/a&gt; working for the Ruby VM’s source code (in my case, in Vim). Here’s how I did it!&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;I’ve been making a point to learn more about &lt;a href=&quot;/search-down-the-stack/&quot;&gt;things I depend on&lt;/a&gt; recently. Today, that means learning about Ruby. And what better way to learn than to check out the source code, and jump around?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://clangd.llvm.org/&quot;&gt;clangd&lt;/a&gt; is an editor-agnostic language server that uses the &lt;a href=&quot;https://langserver.org/&quot;&gt;Language Server Protocol&lt;/a&gt; to power IDE-like features in your preferred text editor. All it needs is a &lt;code&gt;compile_commands.json&lt;/code&gt;, which is basically a mapping of filename to options to pass to &lt;code&gt;clang&lt;/code&gt; so that it knows things like which warnings to enable and where to search for header files.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://clangd.llvm.org/&quot;&gt;clangd&lt;/a&gt; works best for projects built using &lt;code&gt;cmake&lt;/code&gt;, but the Ruby VM doesn’t use &lt;code&gt;cmake&lt;/code&gt;. Regardless, we can make a &lt;code&gt;compile_commands.json&lt;/code&gt; file by using &lt;a href=&quot;https://github.com/rizsotto/Bear&quot;&gt;Bear&lt;/a&gt; to trace the execution of a Ruby build, and use the trace information to write out a &lt;code&gt;compile_commands.json&lt;/code&gt; file.&lt;/p&gt;
&lt;h1 id=&quot;steps&quot;&gt;Steps&lt;/h1&gt;
&lt;p&gt;I could only get these steps to work for Linux, as the Bear README mentions that on macOS you have to disable System Integrity Protection to get it to work.&lt;/p&gt;
&lt;h2 id=&quot;install-bear&quot;&gt;1. Install &lt;a href=&quot;https://github.com/rizsotto/Bear&quot;&gt;Bear&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I describe how I built Bear from source in the Appendix.&lt;/p&gt;
&lt;h2 id=&quot;clone-the-ruby-source-code.&quot;&gt;2. Clone the Ruby source code.&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; clone https://github.com/ruby/ruby&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; ruby&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;configure-the-ruby-build.&quot;&gt;3. Configure the Ruby build.&lt;/h2&gt;
&lt;p&gt;We have to tell the &lt;code&gt;configure&lt;/code&gt; script to use Clang to compile (or if you’re confident that your system compiler toolchain is Clang, you can just run &lt;code&gt;./configure&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Create the ./configure file&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;autoconf&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# This only works when using clang to build Ruby&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;./configure&lt;/span&gt; CC=clang&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;use-bear-to-invoke-make&quot;&gt;4. Use &lt;code&gt;bear&lt;/code&gt; to invoke &lt;code&gt;make&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Bear will use a dynamically preloaded library to trace system calls that exec &lt;code&gt;clang&lt;/code&gt; processes, looking at things like the command line arguments given to Clang.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;bear&lt;/span&gt; make&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;thats-it&quot;&gt;5. That’s it!&lt;/h2&gt;
&lt;p&gt;The output is &lt;code&gt;./compile_commands.json&lt;/code&gt;, which should be non-empty. If it’s empty or just has &lt;code&gt;[]&lt;/code&gt;, it didn’t work. There’s some troubleshooting in the &lt;a href=&quot;https://github.com/rizsotto/Bear&quot;&gt;Bear&lt;/a&gt; README.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;compile_commands.json&lt;/code&gt; file will be consumed by &lt;code&gt;clangd&lt;/code&gt; in your editor. Check &lt;a href=&quot;https://langserver.org&quot; class=&quot;uri&quot;&gt;https://langserver.org&lt;/a&gt; to find an LSP client for your preferred editor, and follow its setup instructions.&lt;/p&gt;
&lt;p&gt;Once you’ve built the &lt;code&gt;compile_commands.json&lt;/code&gt; file and configured your editor to use LSP with &lt;code&gt;clangd&lt;/code&gt;, you should be able to do things like Jump to Definition and Hover on the Ruby source code!&lt;/p&gt;
&lt;h1 id=&quot;appendix-building-bear-from-source&quot;&gt;Appendix: Building Bear from source&lt;/h1&gt;
&lt;p&gt;This is probably common knowledge for people who use &lt;code&gt;cmake&lt;/code&gt; regularly, but this is how I built Bear from source, because I built it on a machine where I didn’t have root so I couldn’t write to &lt;code&gt;/usr/local&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; clone https://github.com/rizsotto/Bear&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; Bear&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;mkdir&lt;/span&gt; build&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;bu&quot;&gt;cd&lt;/span&gt; build&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Install to $HOME/.local/bin instead of /usr/local/bin&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;cmake&lt;/span&gt; .. &lt;span class=&quot;st&quot;&gt;&amp;quot;-DCMAKE_INSTALL_PREFIX=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;$HOME&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;/.local&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt; -j&lt;span class=&quot;va&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;ex&quot;&gt;nproc&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt; install&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# → $HOME/.local/bin/bear exists now&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&quot;appendix-lsp-in-neovim-with-languageclient-neovim&quot;&gt;Appendix: LSP in Neovim with LanguageClient-neovim&lt;/h1&gt;
&lt;p&gt;I use Neovim. My preferred LSP client is &lt;a href=&quot;https://github.com/autozimu/LanguageClient-neovim&quot;&gt;LanguageClient-neovim&lt;/a&gt;. Here’s the parts of my Neovim config files that setup &lt;code&gt;clangd&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jez/dotfiles/blob/865a74d93d8ab1c28713ae0dcd53797b6c26dc6a/vim/plug-settings.vim#L576-L587&quot;&gt;→ &lt;code&gt;vim/plug-settings.vim&lt;/code&gt; in jez/dotfiles&lt;/a&gt;&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="vim" /><category term="debugging" /><summary type="html">← Return home I’ve managed to get LSP-based IDE features powered by clangd working for the Ruby VM’s source code (in my case, in Vim). Here’s how I did it!</summary></entry><entry><title type="html">Linkers &amp;amp; Ruby C Extensions</title><link href="https://blog.jez.io/linkers-ruby-c-exts/" rel="alternate" type="text/html" title="Linkers &amp;amp; Ruby C Extensions" /><published>2020-06-07T13:05:07-04:00</published><updated>2020-06-07T13:05:07-04:00</updated><id>https://blog.jez.io/linkers-ruby-c-exts</id><content type="html" xml:base="https://blog.jez.io/linkers-ruby-c-exts/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I recently learned that linkers are really cool. It all started when I saw an error message that looked something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ rake test
symbol lookup error: /home/jez/.../foo.so: undefined symbol bar&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I &lt;a href=&quot;/search-down-the-stack/&quot;&gt;already wrote&lt;/a&gt; about finding where this error was coming from. The tl;dr is that it was coming from GNU’s libc implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ rg -t c &amp;#39;symbol lookup error&amp;#39;
dl-lookup.c
876:      _dl_signal_cexception (0, &amp;amp;exception, N_(&amp;quot;symbol lookup error&amp;quot;));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That led me to a fun exploration of how linux linkers work, and how Ruby C extensions rely on them.&lt;/p&gt;
&lt;p&gt;I always knew that Ruby C extensions existed (that they &lt;a href=&quot;https://twitter.com/asolove/status/1261339091485917184&quot;&gt;break all the time&lt;/a&gt; is a constant reminder…) but I never really connected the dots between “here’s some C code” and how Ruby actually runs that code.&lt;/p&gt;
&lt;p&gt;Ruby C extensions are just shared libraries following certain conventions. Specifically, a Ruby C extension might look like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode c&quot;&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;pp&quot;&gt;#include &lt;/span&gt;&lt;span class=&quot;im&quot;&gt;&amp;quot;ruby.h&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;VALUE my_foo(VALUE self, VALUE val) {&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; rb_funcall(self, rb_intern(&lt;span class=&quot;st&quot;&gt;&amp;quot;puts&amp;quot;&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, val)&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;// This function&amp;#39;s name matters:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; Init_my_lib() {&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  rb_define_method(rb_cObject, &lt;span class=&quot;st&quot;&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;, my_foo);&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The important part is that the name of that &lt;code&gt;Init_my_lib&lt;/code&gt; function matters. When Ruby sees a line like&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;require_relative&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;./my_lib&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it looks for a file called &lt;code&gt;my_lib.so&lt;/code&gt; (or &lt;code&gt;my_lib.bundle&lt;/code&gt; on macOS), asks the operating system to load that file as a shared library, and then looks for a function with the name &lt;code&gt;Init_my_lib&lt;/code&gt; inside the library it just loaded.&lt;/p&gt;
&lt;p&gt;When that function runs, it’s a chance for the C extension to do the same sorts of things that a normal Ruby file might have done if it had been &lt;code&gt;require&lt;/code&gt;’d. In this example, it defines a method &lt;code&gt;foo&lt;/code&gt; at the top level, almost like the user had written normal Ruby code like this:&lt;/p&gt;
&lt;figure&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo(val)&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt; val&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
my_lib.rb
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;That’s kind of wild! That means:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C programs can load libraries dynamically at runtime, using arbitrary user input.&lt;/li&gt;
&lt;li&gt;C programs can then ask if there’s a function defined in that library with an arbitrary name, and get a function pointer to call it if there is!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I was pretty shocked to learn this, because my mental model of how linking worked was that it split evenly into two parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;“My application is statically linked, where all the code and libraries my application depends on are compiled into my binary.”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“My application is dynamically linked, which means my binary pre-declares some libraries that must be loaded before my program can start running.”&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There’s actually a third option!&lt;/p&gt;
&lt;p&gt;Then I looked into what code Ruby actually calls to do this. I found the code in &lt;code&gt;dln.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode c&quot;&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;/* Load file */&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb6-2&quot;&gt;&lt;a href=&quot;#cb6-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; ((handle = (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;*)dlopen(file, RTLD_LAZY|RTLD_GLOBAL)) == NULL) {&lt;/span&gt;
&lt;span id=&quot;cb6-3&quot;&gt;&lt;a href=&quot;#cb6-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    error = dln_strerror();&lt;/span&gt;
&lt;span id=&quot;cb6-4&quot;&gt;&lt;a href=&quot;#cb6-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;goto&lt;/span&gt; failed;&lt;/span&gt;
&lt;span id=&quot;cb6-5&quot;&gt;&lt;a href=&quot;#cb6-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
dln.c
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1341&quot;&gt;→ View on github.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Ruby uses the &lt;code&gt;dlopen(3)&lt;/code&gt; function in libc to request that an arbitrary user library be loaded. From the man page:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The function dlopen() loads the dynamic shared object (shared library) file named by the null-terminated string filename and returns an opaque “handle” for the loaded object.&lt;/p&gt;
&lt;p&gt;— man dlopen&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The next thing Ruby does with this opaque &lt;code&gt;handle&lt;/code&gt; is to find if the thing it just loaded has an &lt;code&gt;Init_&amp;lt;...&amp;gt;&lt;/code&gt; function inside it:&lt;/p&gt;
&lt;figure&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode c&quot;&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;init_fct = (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;(*)())(VALUE)dlsym(handle, buf);&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (init_fct == NULL) {&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;size_t&lt;/span&gt; errlen = strlen(error = dln_strerror()) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    error = memcpy(ALLOCA_N(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;, errlen), error, errlen);&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    dlclose(handle);&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;cf&quot;&gt;goto&lt;/span&gt; failed;&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
dln.c
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1363-L1369&quot;&gt;→ View on github.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It uses &lt;code&gt;dlsym(3)&lt;/code&gt; (again in libc) to look up a method with an arbitrary name (&lt;code&gt;buf&lt;/code&gt;) inside the library it just opened (&lt;code&gt;handle&lt;/code&gt;). That function must exist—if it doesn’t, it’s not a valid Ruby C extension and Ruby reports an error.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;dlsym&lt;/code&gt; found a function with the right name, it stores a function pointer into &lt;code&gt;init_fct&lt;/code&gt;, which Ruby immediately dereferences and calls:&lt;/p&gt;
&lt;figure&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode c&quot;&gt;&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;/* Call the init code */&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;(*init_fct)();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
dln.c
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/dln.c#L1370-L1371&quot;&gt;→ View on github.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It’s still kind of mind bending to think that C provides this level of “dynamism.” I had always thought that being a compiled language meant that the set of functions a C program could call was fixed at compile time, but that’s not true at all!&lt;/p&gt;
&lt;p&gt;This search led me down a rabbit hole of learning more about linkers, and now I think they’re super cool—and far less cryptic! I &lt;strong&gt;highly&lt;/strong&gt; recommend &lt;em&gt;Chapter 7: Linking&lt;/em&gt; from &lt;a href=&quot;http://www.csapp.cs.cmu.edu/&quot;&gt;Computer Systems: A Programmer’s Perspective&lt;/a&gt; if this was interesting to you.&lt;/p&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="linux" /><category term="ruby" /><category term="c" /><summary type="html">← Return home I recently learned that linkers are really cool. It all started when I saw an error message that looked something like this:</summary></entry><entry><title type="html">Search Down the Stack</title><link href="https://blog.jez.io/search-down-the-stack/" rel="alternate" type="text/html" title="Search Down the Stack" /><published>2020-06-06T20:08:20-04:00</published><updated>2020-06-06T20:08:20-04:00</updated><id>https://blog.jez.io/search-down-the-stack</id><content type="html" xml:base="https://blog.jez.io/search-down-the-stack/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I’ve found it useful to search though the source code of things lower in the stack lately. For example I saw an error something like this at work recently:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ rake test
symbol lookup error: /home/jez/.../foo.so: undefined symbol bar&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I was pretty confused. Modulo the names of commands and files, this was pretty much all the output.&lt;/p&gt;
&lt;p&gt;So I started searching. First I searched through my codebase for &lt;code&gt;&quot;symbol lookup error&quot;&lt;/code&gt;, but found nothing. Surely that string exists somewhere. That must mean it’s coming from lower in the stack?&lt;/p&gt;
&lt;p&gt;The next level lower would mean third party Ruby gems. At work we use Bundler &lt;a href=&quot;https://bundler.io/v2.0/guides/deploying.html#manual-deployment&quot;&gt;in a mode&lt;/a&gt; where it installs all gems into a single convenient folder in the current directory: &lt;code&gt;./vendor/bundle/&lt;/code&gt;. But a search in that folder turned up nothing again. So… further down?&lt;/p&gt;
&lt;p&gt;If it’s not from the app, and not from the gems, then maybe it’s in Ruby itself? I cloned the &lt;a href=&quot;https://github.com/ruby/ruby&quot;&gt;Ruby source&lt;/a&gt;, checked out the &lt;a href=&quot;https://github.com/ruby/ruby/tree/v2_6_5&quot;&gt;version tag&lt;/a&gt; for the Ruby version we’re running, and searched for &lt;code&gt;&quot;symbol lookup error&quot;&lt;/code&gt; once again. And again nothing!&lt;/p&gt;
&lt;p&gt;There’s still plenty of layers below us, so let’s keep peeling them back. Ruby is written in C, which means we should check libc next (the C standard library). There are multiple libc implementations, but I was running this on Linux, so let’s check GNU libc (glibc). glibc is &lt;a href=&quot;https://www.gnu.org/software/libc/sources.html&quot;&gt;isn’t on GitHub&lt;/a&gt;, but that’s not a huge deterrant. Here’s the search:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ rg -t c &amp;#39;symbol lookup error&amp;#39;
dl-lookup.c
876:      _dl_signal_cexception (0, &amp;amp;exception, N_(&amp;quot;symbol lookup error&amp;quot;));&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s a bit of a smoking gun! After all those layers, we found our error message in libc itself. (This gave me a lot of leads on the problem at hand, e.g., I had definitely ruled out a problem in my app or its dependencies, and I was thinking, “probably something is wrong about how &lt;code&gt;foo.so&lt;/code&gt; was compiled.” There’s a fun story here about how Ruby C extensions work, but that’s a &lt;a href=&quot;/linkers-ruby-c-exts/&quot;&gt;tangent for another time&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;My point is that &lt;a href=&quot;https://livegrep.com/search/linux&quot;&gt;searching all the code&lt;/a&gt; is a super power, and it applies to more than just searching the code we’ve written. What a blessing that the tools we’re building on, like Ruby and GNU libc, are all open source!&lt;/p&gt;
&lt;p&gt;The next time it looks like a problem is outside the scope of your app’s code, maybe try searching the code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;inside your gems or packages!&lt;/li&gt;
&lt;li&gt;inside your language’s standard library!
&lt;ul&gt;
&lt;li&gt;Some IDEs will even let you jump-to-def into core libraries 😮&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;inside your language’s runtime
&lt;ul&gt;
&lt;li&gt;(if you’re using a language with a runtime like Ruby or Python or even &lt;a href=&quot;https://github.com/v8/v8&quot;&gt;JavaScript&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;powering your operating system kernel! &lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;This might sound daunting, but sometimes it can be useful. A good thing to keep in mind: every &lt;strong&gt;system call&lt;/strong&gt; like &lt;code&gt;open(2)&lt;/code&gt; or &lt;code&gt;write(2)&lt;/code&gt; or &lt;code&gt;select(2)&lt;/code&gt; (and every other function from section 2 of the man pages) is really just a way for your program to request that the operating system do something; knowing that can be a decent place to start traipsing through code in the operating system.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For me, I’ve already noticed it help save me time and give me more context when I’m debugging.&lt;/p&gt;
&lt;!-- vim:tw=72
--&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="fragment" /><category term="linux" /><category term="debugging" /><summary type="html">← Return home I’ve found it useful to search though the source code of things lower in the stack lately. For example I saw an error something like this at work recently:</summary></entry><entry><title type="html">Sorbet Does Not Have FixMe Comments</title><link href="https://blog.jez.io/sorbet-fixme-comment/" rel="alternate" type="text/html" title="Sorbet Does Not Have FixMe Comments" /><published>2020-02-12T02:18:40-05:00</published><updated>2020-02-12T02:18:40-05:00</updated><id>https://blog.jez.io/sorbet-fixme-comment</id><content type="html" xml:base="https://blog.jez.io/sorbet-fixme-comment/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Sorbet has no way to ignore an error on a specific line with a magic comment. This is different from all other gradual static type checkers I know about:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript: &lt;code&gt;// @ts-ignore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Flow: &lt;code&gt;// $FlowFixMe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Hack: &lt;code&gt;// HH_FIXME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MyPy: &lt;code&gt;# type: ignore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When I first joined the team, I was skeptical. But having seen it play out in practice, it’s actually worked great.&lt;/p&gt;
&lt;p&gt;Instead of ignore comments, Sorbet has &lt;code&gt;T.unsafe&lt;/code&gt;, which accepts anything and returns it unchanged (so for example &lt;code&gt;T.unsafe(3)&lt;/code&gt; evaluates to &lt;code&gt;3&lt;/code&gt;). The trick is that it forces Sorbet to forget the type of the input statically. This confers the power to silence most errors. For example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;# error: Expected `Integer` but found `String`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.unsafe&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# no error&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%20%20%20%20%20%20%20%20%201%20%20%2B%20'1'%20%20%23%20error%3A%20Expected%20%60Integer%60%20but%20found%20%60String%60%0AT.unsafe(1)%20%2B%20'1'%20%20%23%20no%20error&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this example, Sorbet knows that calling &lt;code&gt;+&lt;/code&gt; on an Integer with a String would raise an exception at runtime, and so it reports a static type error. But wrapping the &lt;code&gt;1&lt;/code&gt; in a call to &lt;code&gt;T.unsafe&lt;/code&gt; causes Sorbet to think that the expression &lt;code&gt;T.unsafe(1)&lt;/code&gt; has type &lt;code&gt;T.untyped&lt;/code&gt;. Then, like for all untyped code, Sorbet admits the addition.&lt;/p&gt;
&lt;p&gt;All Sorbet-typed Ruby programs must grapple with &lt;code&gt;T.untyped&lt;/code&gt;. Every Sorbet user has to learn how it works and what the tradeoffs of using it are. In particular, that &lt;code&gt;T.untyped&lt;/code&gt; is viral. Given a variable that’s &lt;code&gt;T.untyped&lt;/code&gt;, all method calls on that variable will also be untyped:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: true&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.untyped&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.void&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo(x)&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  y &lt;span class=&quot;kw&quot;&gt;=&lt;/span&gt; x&lt;span class=&quot;at&quot;&gt;.even?&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# ^ type: T.untyped&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  z &lt;span class=&quot;kw&quot;&gt;= !&lt;/span&gt;y&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# ^ type: T.untyped&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-10&quot;&gt;&lt;a href=&quot;#cb2-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams(x%3A%20T.untyped).void%7D%0Adef%20foo(x)%0A%20%20y%20%3D%20x.even%3F%0A%23%20%5E%20type%3A%20T.untyped%0A%20%20z%20%3D%20!y%0A%23%20%5E%20type%3A%20T.untyped%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this example &lt;code&gt;x&lt;/code&gt; enters the method as &lt;code&gt;T.untyped&lt;/code&gt;, so calling the method &lt;code&gt;.even?&lt;/code&gt; propagates the &lt;code&gt;T.untyped&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;. Then again because &lt;code&gt;y&lt;/code&gt; is untyped, calling&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Did you know that &lt;code&gt;!x&lt;/code&gt; in Ruby is syntactic sugar for &lt;code&gt;x.!()&lt;/code&gt;, which means that you can override &lt;code&gt;!&lt;/code&gt; to make it do something else?&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; &lt;code&gt;!&lt;/code&gt; on it propgates the &lt;code&gt;T.untyped&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt;. There are plenty of reasons to &lt;a href=&quot;https://sorbet.org/docs/gradual&quot;&gt;both embrace and avoid&lt;/a&gt; &lt;code&gt;T.untyped&lt;/code&gt; in a type system but the point is: Sorbet’s type system already has it.&lt;/p&gt;
&lt;p&gt;Re-using &lt;code&gt;T.untyped&lt;/code&gt; as the way to silence errors plays nicely with everything else in Sorbet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Hover and jump to definition become tools to track down the source of silenced errors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Errors are effectively silenced at the source of the error. There are no errors downstream that only show up because an error was silenced earlier.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We plan to eventually build a tool to show which parts of a file are untyped (to see things like which methods don’t have signatures). That tool will trivially take suppressed errors into account.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;a href=&quot;https://sorbet.org/docs/gradual&quot;&gt;Sorbet docs&lt;/a&gt; bill &lt;code&gt;T.untyped&lt;/code&gt; as the way to “turn off the type system.” By reusing &lt;code&gt;T.untyped&lt;/code&gt; to supress errors, silencing one error means silencing them all, which is a win for simplicity.&lt;/p&gt;
&lt;!-- vim:tw=72
--&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html">← Return home</summary></entry><entry><title type="html">Intersection Types in Sorbet are Surprisingly Common</title><link href="https://blog.jez.io/intersection-types-common/" rel="alternate" type="text/html" title="Intersection Types in Sorbet are Surprisingly Common" /><published>2020-01-04T20:50:32-05:00</published><updated>2020-01-04T20:50:32-05:00</updated><id>https://blog.jez.io/intersection-types-common</id><content type="html" xml:base="https://blog.jez.io/intersection-types-common/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;← Return home&lt;/a&gt;&lt;br&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;Conventional knowledge is that union types are common and intersection types are rare. But actually that’s not the case—intersection types show up in nearly every program Sorbet type checks thanks to control flow.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;Union types&lt;/a&gt; in Sorbet are incredibly common, which should be no surprise. In Sorbet, &lt;code&gt;T.nilable(...)&lt;/code&gt; is sugar for &lt;code&gt;T.any(NilClass, ...)&lt;/code&gt;. &lt;code&gt;T.nilable&lt;/code&gt; shows up all over the place and probably catches more bugs than any other feature in Sorbet.&lt;/p&gt;
&lt;p&gt;Sorbet also has &lt;a href=&quot;https://sorbet.org/docs/intersection-types&quot;&gt;intersection types&lt;/a&gt;. While union types mean “either this or that,” intersection types mean “both this and that.” On first glance, intersection types seem like some super niche feature which only benefits a handful of programs. In Stripe’s Ruby monorepo, the strings &lt;code&gt;T.any&lt;/code&gt; and &lt;code&gt;T.nilable&lt;/code&gt; occur nearly 300 times more than &lt;code&gt;T.all&lt;/code&gt; does.&lt;/p&gt;
&lt;p&gt;But those numbers hide something critical: intersection types power Sorbet’s &lt;a href=&quot;https://sorbet.org/docs/flow-sensitive&quot;&gt;control flow-sensitive typing&lt;/a&gt;. They’re actually present in every Ruby program, but just a little hard to spot. Let’s look at how pervasive they are with a few examples:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: strict&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parent&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Child&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parent&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-6&quot;&gt;&lt;a href=&quot;#cb1-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-7&quot;&gt;&lt;a href=&quot;#cb1-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Parent&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.void&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-8&quot;&gt;&lt;a href=&quot;#cb1-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; example1(x)&lt;/span&gt;
&lt;span id=&quot;cb1-9&quot;&gt;&lt;a href=&quot;#cb1-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb1-10&quot;&gt;&lt;a href=&quot;#cb1-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Child&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-11&quot;&gt;&lt;a href=&quot;#cb1-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    T&lt;span class=&quot;at&quot;&gt;.reveal_type&lt;/span&gt;(x) &lt;span class=&quot;co&quot;&gt;# Revealed type: `Child`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-12&quot;&gt;&lt;a href=&quot;#cb1-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb1-13&quot;&gt;&lt;a href=&quot;#cb1-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20Parent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20Parent).void%7D%0Adef%20example1(x)%0A%20%20case%20x%0A%20%20when%20Child%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20%60Child%60%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here &lt;code&gt;x&lt;/code&gt; starts out having type &lt;code&gt;Parent&lt;/code&gt;, but inside the &lt;code&gt;case&lt;/code&gt; statement Sorbet treats &lt;code&gt;x&lt;/code&gt; as having the more specific type &lt;code&gt;Child&lt;/code&gt;. There’s no &lt;code&gt;T.all&lt;/code&gt; in sight, but that’s because it’s hiding. Sorbet doesn’t just throw away the fact that it knew &lt;code&gt;x &amp;lt;: Parent&lt;/code&gt;. Instead, it uses &lt;code&gt;T.all&lt;/code&gt; to update its type for &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;T.all(Parent, Child)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T.all(Parent, Child)&lt;/code&gt; is equivalent to &lt;code&gt;Child&lt;/code&gt; because &lt;code&gt;Child&lt;/code&gt; is a subtype of &lt;code&gt;Parent&lt;/code&gt;. If types represent sets of values, then the set of values represented by &lt;code&gt;Child&lt;/code&gt; is a subset of the set of values represented by &lt;code&gt;Parent&lt;/code&gt;, so the intersection of those two sets would just leave &lt;code&gt;Child&lt;/code&gt;.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;If you’re not convinced, consider: with &lt;code&gt;T.all(Parent, Child)&lt;/code&gt; we should be able to call all the methods on &lt;code&gt;Parent&lt;/code&gt; and all the methods on &lt;code&gt;Child&lt;/code&gt;. But &lt;code&gt;Child&lt;/code&gt; inherits &lt;code&gt;Parent&lt;/code&gt;’s methods, so any method &lt;code&gt;Parent&lt;/code&gt; has will already be on &lt;code&gt;Child&lt;/code&gt;. So &lt;code&gt;Child&lt;/code&gt; is equivalently good as &lt;code&gt;T.all(Parent, Child)&lt;/code&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Sorbet attempts to simplify a large type to a smaller, equivalent type when it can for two reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;smallcaps&quot;&gt;&lt;strong&gt;Usability&lt;/strong&gt;&lt;/span&gt; – Most users don’t know that &lt;code&gt;T.all&lt;/code&gt; means “intersection type” or even what intersection types are. (And even those who do still end up drawing Venn diagrams from time to time!) It only gets more complicated when &lt;code&gt;T.all&lt;/code&gt;s and &lt;code&gt;T.any&lt;/code&gt;s nest inside each other.&lt;/p&gt;
&lt;p&gt;Meanwhile, &lt;code&gt;Child&lt;/code&gt; is a super easy type to understand, and leads to nice, short error messages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&quot;smallcaps&quot;&gt;&lt;strong&gt;Performance&lt;/strong&gt;&lt;/span&gt; – Checking whether one type is a subtype of another is a super common operation, so it has to be fast. By collapsing &lt;code&gt;T.all(Parent, Child)&lt;/code&gt; to &lt;code&gt;Child&lt;/code&gt;, Sorbet does at least half as much work when checking subtyping (probably more, because of some common path optimizations).&lt;/p&gt;
&lt;p&gt;When this simplification happens, Sorbet even skips an allocation entirely. Cnstructing &lt;code&gt;T.all(Parent, Child)&lt;/code&gt; in Sorbet short circuits and returns a reference to the already allocated &lt;code&gt;Child&lt;/code&gt; type that was passed as an argument (with ownership tracked via &lt;code&gt;std::shared_ptr&lt;/code&gt;&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-1&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-1&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;If you’re looking for a good intro to modern C++ things like &lt;code&gt;shared_ptr&lt;/code&gt;, I can’t recommend &lt;a href=&quot;https://berthub.eu/articles/posts/cpp-intro/&quot;&gt;this blog post series&lt;/a&gt; enough.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s look at another example of control flow:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# typed: strict&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;extend&lt;/span&gt; T&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;Sig&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; B; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-6&quot;&gt;&lt;a href=&quot;#cb2-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-7&quot;&gt;&lt;a href=&quot;#cb2-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;a_or_b: &lt;/span&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(A, B))&lt;span class=&quot;at&quot;&gt;.void&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-8&quot;&gt;&lt;a href=&quot;#cb2-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; example2(a_or_b)&lt;/span&gt;
&lt;span id=&quot;cb2-9&quot;&gt;&lt;a href=&quot;#cb2-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; a_or_b&lt;/span&gt;
&lt;span id=&quot;cb2-10&quot;&gt;&lt;a href=&quot;#cb2-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb2-11&quot;&gt;&lt;a href=&quot;#cb2-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    T&lt;span class=&quot;at&quot;&gt;.reveal_type&lt;/span&gt;(a_or_b) &lt;span class=&quot;co&quot;&gt;# Revealed type: `A`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-12&quot;&gt;&lt;a href=&quot;#cb2-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-13&quot;&gt;&lt;a href=&quot;#cb2-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Aclass%20A%3B%20end%0Aclass%20B%3B%20end%0A%0Asig%20%7Bparams(a_or_b%3A%20T.any(A%2C%20B)).void%7D%0Adef%20example2(a_or_b)%0A%20%20case%20a_or_b%0A%20%20when%20A%0A%20%20%20%20T.reveal_type(a_or_b)%20%23%20Revealed%20type%3A%20%60A%60%0A%20%20end%0Aend&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This example method accepts either &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; (&lt;code&gt;T.any(A, B)&lt;/code&gt;) and then branches on whether &lt;code&gt;a_or_b&lt;/code&gt; is an instance of &lt;code&gt;A&lt;/code&gt;. Again: Sorbet doesn’t throw away that it knows &lt;code&gt;a_or_b &amp;lt;: T.any(A, B)&lt;/code&gt;. Instead it updates its knowledge of the type of &lt;code&gt;a_or_b&lt;/code&gt; using &lt;code&gt;T.all&lt;/code&gt; to get &lt;code&gt;T.all(T.any(A, B), A)&lt;/code&gt;. Realizing that this is equivalent to &lt;code&gt;A&lt;/code&gt; is a bit trickier:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.all&lt;/span&gt;(T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;(A, B), A)&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# Distribute&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-4&quot;&gt;&lt;a href=&quot;#cb3-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;( T&lt;span class=&quot;at&quot;&gt;.all&lt;/span&gt;(A, A) , T&lt;span class=&quot;at&quot;&gt;.all&lt;/span&gt;(B, A) )&lt;/span&gt;
&lt;span id=&quot;cb3-5&quot;&gt;&lt;a href=&quot;#cb3-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-6&quot;&gt;&lt;a href=&quot;#cb3-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# T.all(A, A) is just A (idempotence)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-7&quot;&gt;&lt;a href=&quot;#cb3-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;( A , T&lt;span class=&quot;at&quot;&gt;.all&lt;/span&gt;(B, A) )&lt;/span&gt;
&lt;span id=&quot;cb3-8&quot;&gt;&lt;a href=&quot;#cb3-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-9&quot;&gt;&lt;a href=&quot;#cb3-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# A and B are classes (not mixins) and neither inherits the other.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-10&quot;&gt;&lt;a href=&quot;#cb3-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# It&amp;#39;s impossible to have a value of that type, so it&amp;#39;s bottom:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-11&quot;&gt;&lt;a href=&quot;#cb3-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.any&lt;/span&gt;( A , T&lt;span class=&quot;at&quot;&gt;.noreturn&lt;/span&gt; )&lt;/span&gt;
&lt;span id=&quot;cb3-12&quot;&gt;&lt;a href=&quot;#cb3-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-13&quot;&gt;&lt;a href=&quot;#cb3-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# bottom is the identity of union&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-14&quot;&gt;&lt;a href=&quot;#cb3-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;A&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can start to see how usability and performance and might get a little out of hand if Sorbet didn’t keep attempting to simplify things! The cumulative effect of all the control flow in a program would result in huge, unweidly types.&lt;/p&gt;
&lt;p&gt;Until now you could claim that I’ve been hyping up intersection types as the solution to problems that were self-imposed. That if we just invented some other method for modeling control flow, it would have been naturally usable or naturally performant, and we wouldn’t have had problems in the first place. So next let’s look at some examples to see why intersection types really are the most natural solution:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;I1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo1; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;I2&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-5&quot;&gt;&lt;a href=&quot;#cb4-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo2; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-6&quot;&gt;&lt;a href=&quot;#cb4-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-7&quot;&gt;&lt;a href=&quot;#cb4-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-8&quot;&gt;&lt;a href=&quot;#cb4-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;sig &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;params(&lt;span class=&quot;wa&quot;&gt;x: &lt;/span&gt;&lt;span class=&quot;cn&quot;&gt;I1&lt;/span&gt;)&lt;span class=&quot;at&quot;&gt;.void&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-9&quot;&gt;&lt;a href=&quot;#cb4-9&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; example3(x)&lt;/span&gt;
&lt;span id=&quot;cb4-10&quot;&gt;&lt;a href=&quot;#cb4-10&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  x&lt;span class=&quot;at&quot;&gt;.foo1&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# Works outside&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-11&quot;&gt;&lt;a href=&quot;#cb4-11&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;case&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&quot;cb4-12&quot;&gt;&lt;a href=&quot;#cb4-12&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;I2&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-13&quot;&gt;&lt;a href=&quot;#cb4-13&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    x&lt;span class=&quot;at&quot;&gt;.foo1&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;# Should (and does) still work inside&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-14&quot;&gt;&lt;a href=&quot;#cb4-14&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    x&lt;span class=&quot;at&quot;&gt;.foo2&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-15&quot;&gt;&lt;a href=&quot;#cb4-15&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-16&quot;&gt;&lt;a href=&quot;#cb4-16&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unlike in the other examples, this is the first example where had we tried to implement control-flow-sensitive typing by throwing away the old type and using the new type instead it wouldn’t have worked. The key thing to notice: this example uses modules. Outside the &lt;code&gt;case&lt;/code&gt; of course calling &lt;code&gt;x.method_from_1&lt;/code&gt; works because &lt;code&gt;x&lt;/code&gt; starts out at type &lt;code&gt;I1&lt;/code&gt;. But if we treated &lt;code&gt;x&lt;/code&gt; as only &lt;code&gt;I2&lt;/code&gt; inside the &lt;code&gt;when I2&lt;/code&gt;, we’d start reporting an error for calling &lt;code&gt;x.method_from_1&lt;/code&gt; because it doesn’t exist on &lt;code&gt;I2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unlike intersecting unrelated classes (our &lt;code&gt;T.all(B, A)&lt;/code&gt; example from earlier), intersecting unrelated modules does’t collapse to &lt;code&gt;T.noreturn&lt;/code&gt;. There’s nothing stopping some class from including both &lt;code&gt;I1&lt;/code&gt; and &lt;code&gt;I2&lt;/code&gt;. Instances of that class would be values of type &lt;code&gt;T.any(I1, I2)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SomeClass&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;I1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;cn&quot;&gt;I2&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-5&quot;&gt;&lt;a href=&quot;#cb5-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-6&quot;&gt;&lt;a href=&quot;#cb5-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# This type assertion is okay:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-7&quot;&gt;&lt;a href=&quot;#cb5-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.let&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;, T&lt;span class=&quot;at&quot;&gt;.all&lt;/span&gt;(&lt;span class=&quot;cn&quot;&gt;I1&lt;/span&gt;, &lt;span class=&quot;cn&quot;&gt;I2&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20I1%0A%20%20def%20foo1%3B%20end%0Aend%0Amodule%20I2%0A%20%20def%20foo2%3B%20end%0Aend%0A%0Asig%20%7Bparams(x%3A%20I1).void%7D%0Adef%20example3(x)%0A%20%20x.foo1%20%20%23%20Works%20outside%0A%20%20case%20x%0A%20%20when%20I2%0A%20%20%20%20x.foo1%20%20%23%20Should%20(and%20does)%20still%20work%20inside%0A%20%20%20%20x.foo2%0A%20%20end%0Aend%0A%0Aclass%20SomeClass%0A%20%20include%20I1%0A%20%20include%20I2%0Aend%0A%0A%23%20This%20type%20assertion%20is%20okay%3A%0AT.let(SomeClass.new%2C%20T.all(I1%2C%20I2))&quot;&gt;→ View on sorbet.run&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So at least for implementing certain cases of flow sensitive typing, we’ll &lt;em&gt;need&lt;/em&gt; intersection types anyways. Then for these certain cases we’d incur the usability and performance problems we discovered earlier and have to solve them.&lt;/p&gt;
&lt;p&gt;But more than that, intersection types are fundamentally easier to work with compared to some ad hoc approach to flow sensitive typing. Type system bugs are weird. It’s frquently harder to figure out whether the current behavior is buggy in the first place than it is to find the cause!&lt;/p&gt;
&lt;p&gt;In that light, intersection types present an elegant, robust model for arriving at what the correct behavior &lt;em&gt;should&lt;/em&gt; be, independent of what Sorbet’s existing behavior is. It’s clear how intersection types interact with union types, and with subtyping, and with generics, and with variance, etc.&lt;/p&gt;
&lt;p&gt;By repurposing intersection types to model control flow sensitivity, when things go wrong there’s a framework for discovering what’s right.&lt;/p&gt;
&lt;p&gt;(Speaking of repurposing, intersection types also play an important role in how Sorbet &lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20M%3B%20end%0Amodule%20N%3B%20end%0A%0Asig%20%7Bparams(m%3A%20M).void%7D%0Adef%20takes_m(m)%3B%20end%0Asig%20%7Bparams(n%3A%20N).void%7D%0Adef%20takes_n(n)%3B%20end%0A%0Adef%20needs_sig(x)%0A%20%20takes_m(x)%0A%20%20takes_n(x)%0Aend&quot;&gt;suggests potential method signatures&lt;/a&gt;! That’s three birds with one stone.)&lt;/p&gt;
&lt;!-- vim:tw=72
--&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="sorbet" /><category term="ruby" /><category term="types" /><summary type="html">← Return home Conventional knowledge is that union types are common and intersection types are rare. But actually that’s not the case—intersection types show up in nearly every program Sorbet type checks thanks to control flow.</summary></entry><entry><title type="html">What makes type checking Ruby hard?</title><link href="https://blog.jez.io/ruby-mutation/" rel="alternate" type="text/html" title="What makes type checking Ruby hard?" /><published>2019-12-29T02:29:52-05:00</published><updated>2019-12-29T02:29:52-05:00</updated><id>https://blog.jez.io/ruby-mutation</id><content type="html" xml:base="https://blog.jez.io/ruby-mutation/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#dsls-and-metaprogramming&quot;&gt;DSLs and metaprogramming&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#modeling-mutation&quot;&gt;Modeling mutation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#beyond-mutation&quot;&gt;Beyond mutation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-a-by-comparison-with-typed-javascript&quot;&gt;Appendix A: By comparison with typed JavaScript&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#appendix-b-more-things-that-are-actually-mutation&quot;&gt;Appendix B: More things that are actually mutation&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;
&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Mutation makes typechecking Ruby harder than many other programming languages. Most people will immediately think I mean mutation in the sense of &lt;code&gt;x += 1&lt;/code&gt; or something—that’s not what I’m referring to. In fact, that’s the easy kind of mutation to model in a type system.&lt;/p&gt;
&lt;p&gt;What I mean is that nearly everything worth knowing statically about a Ruby program involves mutation. Defining a class?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That mutates the global namespace of constants. After those lines run, all code in the project can reference the class &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Defining a method?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-4&quot;&gt;&lt;a href=&quot;#cb2-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb2-5&quot;&gt;&lt;a href=&quot;#cb2-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The method &lt;code&gt;foo&lt;/code&gt; is undefined just before the &lt;code&gt;def&lt;/code&gt; block (at runtime!), but defined after—mutation again.&lt;/p&gt;
&lt;p&gt;Ruby provides things like &lt;code&gt;attr_reader&lt;/code&gt; and &lt;code&gt;attr_accessor&lt;/code&gt; to define getter and setter methods:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; B&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ot&quot;&gt;attr_reader&lt;/span&gt; &lt;span class=&quot;wa&quot;&gt;:foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;attr_reader&lt;/code&gt; is not a Ruby keyword, contrary to popular belief: it’s a method on the singleton class which takes an argument. It defines an instance method called &lt;code&gt;foo&lt;/code&gt; as a side effect by mutating the class &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It’s the same for mixing modules into classes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb4&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb4-1&quot;&gt;&lt;a href=&quot;#cb4-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;module&lt;/span&gt; M; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb4-2&quot;&gt;&lt;a href=&quot;#cb4-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; C&lt;/span&gt;
&lt;span id=&quot;cb4-3&quot;&gt;&lt;a href=&quot;#cb4-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;include&lt;/span&gt; M&lt;/span&gt;
&lt;span id=&quot;cb4-4&quot;&gt;&lt;a href=&quot;#cb4-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;include&lt;/code&gt; is another method disguised like a keyword which mutates the class’s list of ancestors.&lt;/p&gt;
&lt;p&gt;One of my least favorite Ruby features: you can &lt;strong&gt;redefine&lt;/strong&gt; (not override) a method:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; D&lt;/span&gt;
&lt;span id=&quot;cb5-2&quot;&gt;&lt;a href=&quot;#cb5-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ot&quot;&gt;attr_reader&lt;/span&gt; &lt;span class=&quot;wa&quot;&gt;:foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-3&quot;&gt;&lt;a href=&quot;#cb5-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  alias_method &lt;span class=&quot;wa&quot;&gt;:old_foo&lt;/span&gt;, &lt;span class=&quot;wa&quot;&gt;:foo&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-4&quot;&gt;&lt;a href=&quot;#cb5-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; foo&lt;/span&gt;
&lt;span id=&quot;cb5-5&quot;&gt;&lt;a href=&quot;#cb5-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;fu&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;Calling D#foo&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-6&quot;&gt;&lt;a href=&quot;#cb5-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    old_foo&lt;/span&gt;
&lt;span id=&quot;cb5-7&quot;&gt;&lt;a href=&quot;#cb5-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb5-8&quot;&gt;&lt;a href=&quot;#cb5-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because &lt;code&gt;D#foo&lt;/code&gt; is defined by the &lt;code&gt;attr_reader&lt;/code&gt; line, the subsequent &lt;code&gt;def&lt;/code&gt; overwrites it (akin to mutating a local variable, like &lt;code&gt;x += 1&lt;/code&gt;). Oh and that &lt;code&gt;alias_method&lt;/code&gt;? Another method looking like a keyword which mutates the class.&lt;/p&gt;
&lt;p&gt;Even the way libraries work in Ruby is powered by mutation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;some_gem&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;require&lt;/code&gt; is a method (again, not a keyword) that looks up and runs arbitrary Ruby code, whose result we discard. It’s only convention that the primary side effect of the &lt;code&gt;require&lt;/code&gt;’d code is to mutate the global namespace, defining more classes and methods.&lt;/p&gt;
&lt;h1 id=&quot;dsls-and-metaprogramming&quot;&gt;DSLs and metaprogramming&lt;/h1&gt;
&lt;p&gt;It would be one thing if Ruby constrained the places where this mutation could occur. But instead, it provides first-class support for these features anywhere Ruby code runs. Everything we’ve seen so far can be hidden behind arbitrary computation at runtime:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;With &lt;code&gt;Module#const_set&lt;/code&gt;, a Ruby program can compute an arbitrary name and use it to create new constant at runtime.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Module#define_method&lt;/code&gt; does the same for methods.&lt;/li&gt;
&lt;li&gt;Again &lt;code&gt;require&lt;/code&gt; is a method, so it can occur wherever other methods are called.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It’s not uncommon to see Ruby libraries embrace this rather than avoid it (Rails definitely does). Ruby programs frequently build up large abstractions and do tons of computation which at the end of the day result in a &lt;code&gt;define_method&lt;/code&gt; or a &lt;code&gt;const_set&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rubyists call this “metaprogramming” or “building DSLs” but I call it like I see it: mutation.&lt;/p&gt;
&lt;h1 id=&quot;modeling-mutation&quot;&gt;Modeling mutation&lt;/h1&gt;
&lt;p&gt;Type systems are notoriously bad at modelling this kind of mutation. Look at other typed, object-oriented languages: Java, Scala, C++, … Each of these languages &lt;strong&gt;forbids&lt;/strong&gt; this kind of mutation. (Whether because it’s hard to implement support for it or because they’re making a value judgement is beyond me.)&lt;/p&gt;
&lt;p&gt;So how can Sorbet can model this? Mostly, it just cheats. Err, “approximates.” From my experience working on the Sorbet team, I can think of three main ways it cheats.&lt;/p&gt;
&lt;p&gt;First, Sorbet assumes that if a class or method might exist, it does exist, and universally throughout a project.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;Frequently this assumption is backed up by an autoloader. For example, Rails includes an autoloader that loads constants lazily on demand, so that the programmer doesn’t have to sprinkle require statements throughout the code. But how do autoloads work? Mutation again 🙂.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; It pretends that all &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;extend&lt;/code&gt;, and &lt;code&gt;alias_method&lt;/code&gt; statements in a class run first, before all other code at the top-level of that class. It restricts method redefinitions—the old and new methods must take the same number and kinds of arguments. And it restricts &lt;code&gt;alias_method&lt;/code&gt;: you can only alias to a method on your class, not to a parent class. Sorbet makes no attempt to model &lt;code&gt;undef_method&lt;/code&gt; at all (another method-not-keyword!).&lt;/p&gt;
&lt;p&gt;Second, Sorbet cheats by implementing heuristics for the most common DSLs. To support &lt;code&gt;attr_reader&lt;/code&gt;, Sorbet says, “Hey, this method call happens to be to some method named &lt;code&gt;attr_reader&lt;/code&gt;. I’m not sure if it’s to &lt;code&gt;Module#attr_reader&lt;/code&gt; or to some other &lt;code&gt;attr_reader&lt;/code&gt; definition or to any definition at all, but it’s provided with a single Symbol argument, the result is discarded, and it’s called at the syntactic top-level of a class, so I bet that it is a call to &lt;code&gt;Module#attr_reader&lt;/code&gt;.” It’s similar for many other popular DSLs: it makes decent educated guesses.&lt;/p&gt;
&lt;p&gt;But after all that, it sort of gives up. Sorbet makes no attempts to work backwards from a call to &lt;code&gt;define_method&lt;/code&gt; or &lt;code&gt;const_set&lt;/code&gt; inside a method body to learn that a class or method might have been defined somewhere. Instead, it cheats one last time and uses runtime information.&lt;/p&gt;
&lt;p&gt;As a part of initializing a Sorbet project, Sorbet &lt;code&gt;require&lt;/code&gt;s (read: executes) as much code in a project as it can: all the gems listed in the Gemfile and all the Ruby files in the current folder. Afterwards, it can see the result of all that’s been mutated thus far (via reflection) and serialize what it sees into &lt;a href=&quot;https://sorbet.org/docs/rbi&quot;&gt;RBI files&lt;/a&gt; to convey what it saw to the static checker. This is still imperfect (it completely misses things that are defined after &lt;code&gt;require&lt;/code&gt; time), but empirically it finds most of the remaining undiscovered definitions.&lt;/p&gt;
&lt;h1 id=&quot;beyond-mutation&quot;&gt;Beyond mutation&lt;/h1&gt;
&lt;p&gt;Don’t get me wrong, those approximations are really useful and effective. But really, the way Sorbet handles mutation in a codebase is by incentivicing people to get rid of it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Sorbet can type check a project in seconds, but it takes minutes to re-generate all RBIs files. When Sorbet can see things statically, there’s also a canonical place to write a type annotation for it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It’s a much better experience to click “Go to Definition” and jump to the actual source definition rather than to an auto-generated RBI file.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And arguably, if it’s easy for Sorbet to understand what’s defined and where, it’s easier for a programmer to understand. Understandable code lets people iterate faster, is less brittle, and harder to break by accident.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Programming languages are tools to change and structure the way we think. In the long run, all code can be changed. We adopt type systems specifically to help guide these changes, which &lt;a href=&quot;https://blog.jez.io/on-language-choice/&quot;&gt;I’ve touched on before&lt;/a&gt;. When it comes to mutation in Ruby, Sorbet makes a solid effort to model the helpful parts, while providing guide rails and suggestions to deal with the rest.&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;appendix-a-by-comparison-with-typed-javascript&quot;&gt;Appendix A: By comparison with typed JavaScript&lt;/h1&gt;
&lt;p&gt;You might say, “the things that you’re talking about aren’t unique to Ruby! It’s the same for all dynamic programming languages!” But is that true in practice?&lt;/p&gt;
&lt;p&gt;Let’s compare our Ruby snippets from before with JavaScript.&lt;/p&gt;
&lt;p&gt;Ruby:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;class&lt;/span&gt; A&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.my_dsl&lt;/span&gt;(name)&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    define_method(name) &lt;span class=&quot;cf&quot;&gt;do&lt;/span&gt;; &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;cf&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JavaScript:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A {&lt;/span&gt;
&lt;span id=&quot;cb8-2&quot;&gt;&lt;a href=&quot;#cb8-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;kw&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;myDsl&lt;/span&gt;(name) {&lt;/span&gt;
&lt;span id=&quot;cb8-3&quot;&gt;&lt;a href=&quot;#cb8-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;prototype&lt;/span&gt;[name] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() {}&lt;/span&gt;
&lt;span id=&quot;cb8-4&quot;&gt;&lt;a href=&quot;#cb8-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&quot;cb8-5&quot;&gt;&lt;a href=&quot;#cb8-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First I’ll point out: the mutation becomes way more obvious in the JavaScript program! But second: both TypeScript and Flow report static errors on this program. They both complain that there’s no type annotation declaring that it’s ok to treat &lt;code&gt;this.prototype&lt;/code&gt; as if it were a key-value mapping.&lt;/p&gt;
&lt;p&gt;The fact that both Flow and TypeScript report an error here speak to how common this idiom is in practice. It’s not common, and they’d rather not encourage programs like this, so they forbid it.&lt;/p&gt;
&lt;p&gt;Here’s another example, first in Ruby:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb9&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb9-1&quot;&gt;&lt;a href=&quot;#cb9-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;fu&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;vs&quot;&gt;&amp;#39;some_gem&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-2&quot;&gt;&lt;a href=&quot;#cb9-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb9-3&quot;&gt;&lt;a href=&quot;#cb9-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;dt&quot;&gt;SomeNamespace&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;.new&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then in JavaScript:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode js&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span id=&quot;cb10-1&quot;&gt;&lt;a href=&quot;#cb10-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; someNamespace &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;some_package&amp;#39;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-2&quot;&gt;&lt;a href=&quot;#cb10-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-3&quot;&gt;&lt;a href=&quot;#cb10-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; someNamespace&lt;span class=&quot;op&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;SomeClass&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With no RBI files declaring whether &lt;code&gt;SomeNamespace::SomeClass&lt;/code&gt; exists or not, Sorbet will report an error that the class doesn’t exist. But in TypeScript and Flow, the code is just fine, even if there’s no type declaration file. Both can still see that whatever vale is imported will be bound to the &lt;code&gt;someNamespace&lt;/code&gt; variable (even if it’s treated as &lt;code&gt;any&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Sorbet is thus forced to come up with ways to generate RBI files for all new projects, because without them Sorbet would be crippled: it would have no way to distinguish between a class name that has actually been typoed vs one that is typed correctly but for which there’s no visible definition. Meanwhile, TypeScript and Flow work completely fine in new codebases out of the box.&lt;/p&gt;
&lt;p&gt;So my claim is that: no, these problems &lt;strong&gt;are&lt;/strong&gt; unique to Ruby, because the design of the language and the culture of its use so pervasively promote or require mutation.&lt;/p&gt;
&lt;h1 id=&quot;appendix-b-more-things-that-are-actually-mutation&quot;&gt;Appendix B: More things that are actually mutation&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;freeze&lt;/code&gt; (ironic: to prevent mutation on a class or object… we mutate it!)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;private&lt;/code&gt; / &lt;code&gt;private_class_method&lt;/code&gt; (not keywords! These are methods that take a &lt;strong&gt;Symbol&lt;/strong&gt;; it just so happens that &lt;code&gt;def foo; end&lt;/code&gt; is an expression that evaluates to the symbol &lt;code&gt;:foo&lt;/code&gt;. Which is why there’s both &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private_class_method&lt;/code&gt;, because &lt;code&gt;def self.foo; end&lt;/code&gt; also evaluates to &lt;code&gt;:foo&lt;/code&gt;, so &lt;code&gt;private def self.foo; end&lt;/code&gt; would attempt to mark an &lt;strong&gt;instance&lt;/strong&gt; method named &lt;code&gt;:foo&lt;/code&gt; private, even it didn’t exist!)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- vim:tw=72
--&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="ruby" /><category term="sorbet" /><category term="types" /><summary type="html">← Return home</summary></entry><entry><title type="html">Surgery on Code from the Command Line</title><link href="https://blog.jez.io/surgery-on-code/" rel="alternate" type="text/html" title="Surgery on Code from the Command Line" /><published>2019-07-30T12:32:48-04:00</published><updated>2019-07-30T12:32:48-04:00</updated><id>https://blog.jez.io/surgery-on-code</id><content type="html" xml:base="https://blog.jez.io/surgery-on-code/">&lt;nav id=&quot;TOC&quot; role=&quot;doc-toc&quot;&gt;
  &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt;&lt;br&gt;
  &lt;strong&gt;Contents&lt;/strong&gt;&lt;label for=&quot;contents&quot;&gt;⊕&lt;/label&gt;
  &lt;input type=&quot;checkbox&quot; id=&quot;contents&quot;&gt;
  &lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#multi-grep&quot;&gt;&lt;code&gt;multi-grep&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#multi-sub&quot;&gt;&lt;code&gt;multi-sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#a-larger-example&quot;&gt;A larger example&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#diff-locs&quot;&gt;&lt;code&gt;diff-locs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#aside-the-implementations&quot;&gt;Aside: The implementations&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;

&lt;main&gt;
&lt;p&gt;I’m frequently faced wth problems like “find and replace this pattern, but only on specific lines,” especially lines that have type errors on them. I’ve built three new CLI tools that fit the need to operate on a specific set of lines in a codebase. In this post I’ll walk through a couple examples to show them in action.&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;For the impatient, the tools that I’ve built are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jez/multi-grep&quot;&gt;&lt;code&gt;multi-grep&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Like &lt;code&gt;grep&lt;/code&gt;, but search for a pattern only at the specified locations, printing the locations where a match was found.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jez/multi-sub&quot;&gt;&lt;code&gt;multi-sub&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Substitute a pattern with a replacement at the specified locations, editing the file in place.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/jez/diff-locs&quot;&gt;&lt;code&gt;diff-locs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Convert a unified diff (like the output of &lt;code&gt;git diff&lt;/code&gt;) into a list of locations affected by that diff.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the quick intros out of the way, let’s dive into some examples.&lt;/p&gt;
&lt;h1 id=&quot;multi-grep&quot;&gt;&lt;code&gt;multi-grep&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;Consider the file &lt;code&gt;locs.txt&lt;/code&gt; below which is a list of &lt;code&gt;filename:line&lt;/code&gt; pairs:&lt;/p&gt;
&lt;figure&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb1&quot;&gt;&lt;pre class=&quot;sourceCode numberSource plain numberLines&quot;&gt;&lt;code class=&quot;sourceCode&quot;&gt;&lt;span id=&quot;cb1-1&quot;&gt;&lt;a href=&quot;#cb1-1&quot;&gt;&lt;/a&gt;file_a.txt:13&lt;/span&gt;
&lt;span id=&quot;cb1-2&quot;&gt;&lt;a href=&quot;#cb1-2&quot;&gt;&lt;/a&gt;file_a.txt:22&lt;/span&gt;
&lt;span id=&quot;cb1-3&quot;&gt;&lt;a href=&quot;#cb1-3&quot;&gt;&lt;/a&gt;file_a.txt:79&lt;/span&gt;
&lt;span id=&quot;cb1-4&quot;&gt;&lt;a href=&quot;#cb1-4&quot;&gt;&lt;/a&gt;file_b.txt:10&lt;/span&gt;
&lt;span id=&quot;cb1-5&quot;&gt;&lt;a href=&quot;#cb1-5&quot;&gt;&lt;/a&gt;file_b.txt:11&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figcaption&gt;
locs.txt
&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;(I call such &lt;code&gt;filename:line&lt;/code&gt; pairs “locations” or “locs.”)&lt;/p&gt;
&lt;p&gt;Also consider that our project is huge, and has many more files than just &lt;code&gt;file_a.txt&lt;/code&gt; and &lt;code&gt;file_b.txt&lt;/code&gt;. To filter the &lt;code&gt;locs.txt&lt;/code&gt; list to only the lines that contain the pattern “hello”, we can use &lt;code&gt;multi-grep&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb2&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb2-1&quot;&gt;&lt;a href=&quot;#cb2-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;❯ &lt;span class=&quot;ex&quot;&gt;multi-grep&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt; locs.txt&lt;/span&gt;
&lt;span id=&quot;cb2-2&quot;&gt;&lt;a href=&quot;#cb2-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;file_a.txt&lt;/span&gt;:13&lt;/span&gt;
&lt;span id=&quot;cb2-3&quot;&gt;&lt;a href=&quot;#cb2-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;ex&quot;&gt;file_b.txt&lt;/span&gt;:10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output means that only line 13 in &lt;code&gt;file_a.txt&lt;/code&gt; and line 10 in &lt;code&gt;file_b.txt&lt;/code&gt; contain &lt;code&gt;hello&lt;/code&gt;, given our initial set of 5 locs. The search completely ignored all other files in the project because they weren’t mentioned in &lt;code&gt;locs.txt&lt;/code&gt;. Searching with &lt;code&gt;multi-grep&lt;/code&gt; scales with the size of the input list, not with the size of the codebase being searched.&lt;/p&gt;
&lt;p&gt;This was a contrived example, but let’s keep plowing forward with the basics so we can apply them to a real example.&lt;/p&gt;
&lt;h1 id=&quot;multi-sub&quot;&gt;&lt;code&gt;multi-sub&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;If &lt;code&gt;multi-grep&lt;/code&gt; is like &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;multi-sub&lt;/code&gt; is like &lt;code&gt;sed&lt;/code&gt; but with only the substitute command (&lt;code&gt;s/find/replace/&lt;/code&gt;). Taking our previous example, &lt;code&gt;multi-sub&lt;/code&gt; finds and replaces a pattern on specific input lines:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb3&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb3-1&quot;&gt;&lt;a href=&quot;#cb3-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;❯ &lt;span class=&quot;ex&quot;&gt;multi-sub&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;hello&amp;#39;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;goodbye&amp;#39;&lt;/span&gt; locs.txt&lt;/span&gt;
&lt;span id=&quot;cb3-2&quot;&gt;&lt;a href=&quot;#cb3-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# ... file_a.txt:13 edited: s/hello/goodbye/ ...&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb3-3&quot;&gt;&lt;a href=&quot;#cb3-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# ... file_b.txt:10 edited: s/hello/goodbye/ ...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In our previous example, only locations &lt;code&gt;file_a.txt:13&lt;/code&gt; and &lt;code&gt;file_b.txt:10&lt;/code&gt; matched the pattern &lt;code&gt;hello&lt;/code&gt;. So after running this &lt;code&gt;multi-sub&lt;/code&gt; command, those two files will be updated in place. On both lines, &lt;code&gt;hello&lt;/code&gt; will be replaced with &lt;code&gt;goodbye&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;a-larger-example&quot;&gt;A larger example&lt;/h1&gt;
&lt;p&gt;With the basics out of the way, let’s tackle a real-world problem. I work with the output of &lt;a href=&quot;https://sorbet.org&quot;&gt;Sorbet&lt;/a&gt; a lot, so I’ve used it for this next example (Sorbet is a type checker for Ruby). When Sorbet detects type errors in a program, it generates output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test/payment_methods/update.rb:648: Method `[]` does not exist on `NilClass` component of `T.nilable(T::Hash[T.untyped, T.untyped])` http://go/e/7003
     648 |   assert_equal(nil, previous[&amp;#39;billing_details&amp;#39;][&amp;#39;address&amp;#39;][&amp;#39;line1&amp;#39;])
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^

test/payment_methods/update.rb:649: Method `[]` does not exist on `NilClass` component of `T.nilable(T::Hash[T.untyped, T.untyped])` http://go/e/7003
     649 |   assert_equal(nil, previous[&amp;#39;card&amp;#39;][&amp;#39;checks&amp;#39;][&amp;#39;address_line1_check&amp;#39;])
                               ^^^^^^^^^^^^^^^^

test/payment_methods/webhooks.rb:610: Method `[]` does not exist on `NilClass` component of `T.nilable(T::Hash[T.untyped, T.untyped])` http://go/e/7003
     610 |   assert_equal(2, notification[&amp;#39;card&amp;#39;][&amp;#39;exp_month&amp;#39;])
                             ^^^^^^^^^^^^^^^^^^^^

... many more errors ...

Errors: 253&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error messages look a lot better with colors! If you don’t believe me, you can &lt;a href=&quot;https://sorbet.run&quot;&gt;try Sorbet in the browser&lt;/a&gt; and see for yourself.&lt;/p&gt;
&lt;p&gt;The example above is inspired by real output that we saw at Stripe while iterating on Sorbet. In this specific case, one of my coworkers had improved Sorbet to track more information statically, which uncovered a bunch of new type errors.&lt;/p&gt;
&lt;p&gt;On the Sorbet team, we have a policy that before landing changes like this, we modify Stripe’s monorepo to preemptively silence the new errors. Jordan Brown has a great article on the &lt;a href=&quot;https://medium.com/flow-type/upgrading-flow-codebases-40ef8dd3ccd8&quot;&gt;Flow blog&lt;/a&gt; justifying this technique, so I’ll skip the why and focus only on how to carry out codemods like this.&lt;/p&gt;
&lt;p&gt;As seen above, Sorbet error output always looks like &lt;code&gt;filename.rb:line:Error message&lt;/code&gt;. With a little massaging, this will feed directly into &lt;code&gt;multi-sub&lt;/code&gt;. Also notice that on the lines with errors, the file contents always looked something like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb5&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb5-1&quot;&gt;&lt;a href=&quot;#cb5-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;foo&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To tell Sorbet to silence the errors on these lines, we’ll need to wrap the variable in a call to &lt;code&gt;T.unsafe(...)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb6&quot;&gt;&lt;pre class=&quot;sourceCode ruby&quot;&gt;&lt;code class=&quot;sourceCode ruby&quot;&gt;&lt;span id=&quot;cb6-1&quot;&gt;&lt;a href=&quot;#cb6-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;T&lt;span class=&quot;at&quot;&gt;.unsafe&lt;/span&gt;(foo)&lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;#39;bar&amp;#39;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This instructs to Sorbet to &lt;a href=&quot;https://sorbet.org/docs/troubleshooting#escape-hatches&quot;&gt;forget all static type information&lt;/a&gt; about the variable, thus silencing the error. The key is to only perform this edit on lines with errors— we’d hate to needlessly throw away type information by changing unrelated lines! For things like this, &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;sed&lt;/code&gt; are often too coarse-grained, because accessing a hash like this in Ruby is abundantly common.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;multi-sub&lt;/code&gt;, we can write a really simple regex targetting these hash lookups, but scope the regex to only lines in the error output:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb7&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb7-1&quot;&gt;&lt;a href=&quot;#cb7-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (1) Type check the project&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-2&quot;&gt;&lt;a href=&quot;#cb7-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;❯ &lt;span class=&quot;ex&quot;&gt;srb&lt;/span&gt; tc &lt;span class=&quot;op&quot;&gt;2&amp;gt;&amp;amp;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;\&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-3&quot;&gt;&lt;a href=&quot;#cb7-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# (2) Filter the error output to only have the top-level error lines&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-4&quot;&gt;&lt;a href=&quot;#cb7-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;sed&lt;/span&gt; -e &lt;span class=&quot;st&quot;&gt;&amp;#39;/^ /d; /^$/d; /^Errors:/d&amp;#39;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;\&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-5&quot;&gt;&lt;a href=&quot;#cb7-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# (3) Chop off the error message, keeping only the filename:line&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-6&quot;&gt;&lt;a href=&quot;#cb7-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;fu&quot;&gt;cut&lt;/span&gt; -d : -f 1-2 &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;\&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-7&quot;&gt;&lt;a href=&quot;#cb7-7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# (4) Use multi-sub to replace things like foo[ with T.unsafe(foo)[&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb7-8&quot;&gt;&lt;a href=&quot;#cb7-8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ex&quot;&gt;multi-sub&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;\([a-zA-Z0-9_]+\)\[&amp;#39;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;T.unsafe(\1)[&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Take a look through the four steps in the bash oneliner above:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Type check the project, then&lt;/li&gt;
&lt;li&gt;filter out every line that doesn’t have a location, then&lt;/li&gt;
&lt;li&gt;chop of the error messages, and finally&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;multi-sub&lt;/code&gt; to perform the substitution.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The net result is to update the files in place, performing the substitution only on the lines with errors. Altogether once more, but on one line, making use of a shell alias that I have to abbreviate the inner two steps:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb8&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb8-1&quot;&gt;&lt;a href=&quot;#cb8-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;❯ &lt;span class=&quot;ex&quot;&gt;srb&lt;/span&gt; tc &lt;span class=&quot;op&quot;&gt;2&amp;gt;&amp;amp;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;onlylocs&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;ex&quot;&gt;multi-sub&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;\([a-zA-Z0-9_]+\)\[&amp;#39;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;T.unsafe(\1)[&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So with a super short bash oneliner, we’ve done a mass codemod that fixes hundreds of errors at once, without having to silence more than necessary.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;sed&lt;/code&gt; are like chainsaws, I like to think of &lt;code&gt;multi-grep&lt;/code&gt; and &lt;code&gt;multi-sub&lt;/code&gt; like scalpels—ideal for performing surgery on a codebase. Regular expressions are often super imprecise tools for codemods. But by scoping down the regex to run only on specific lines, it doesn’t matter. The added precision from explicit locations makes up for how blunt regular expressions are.&lt;/p&gt;
&lt;h1 id=&quot;diff-locs&quot;&gt;&lt;code&gt;diff-locs&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;I’ve built one more command in the same spirit as &lt;code&gt;multi-grep&lt;/code&gt; and &lt;code&gt;multi-sub&lt;/code&gt;, except that instead of consuming locations, it emits them. Specifically, given a diff it outputs one &lt;code&gt;filename:line&lt;/code&gt; pair for every line that was affected by the diff.&lt;span class=&quot;sidenote-wrapper&quot;&gt;&lt;label for=&quot;sn-0&quot; class=&quot;margin-toggle sidenote-number&quot;&gt;&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;sn-0&quot; class=&quot;margin-toggle&quot;/&gt;&lt;span class=&quot;sidenote&quot;&gt;It defaults to only lines affected after the diff applies, but there’s an option to make it show both added and removed lines.&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;&lt;/span&gt; It’s ideal for consuming the output of &lt;code&gt;git show&lt;/code&gt; or &lt;code&gt;git diff&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ git show HEAD | diff-locs
test/payment_methods/update.rb:648
test/payment_methods/update.rb:649
test/payment_methods/webhooks.rb:610&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I frequently use &lt;code&gt;diff-locs&lt;/code&gt; to tweak codemods that I’ve already committed. For example, we could go back and add a TODO comment above each new &lt;code&gt;T.unsafe&lt;/code&gt; call:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; id=&quot;cb10&quot;&gt;&lt;pre class=&quot;sourceCode bash&quot;&gt;&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span id=&quot;cb10-1&quot;&gt;&lt;a href=&quot;#cb10-1&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;span class=&quot;co&quot;&gt;# (1) Generate a diff from git&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-2&quot;&gt;&lt;a href=&quot;#cb10-2&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;❯ &lt;span class=&quot;fu&quot;&gt;git&lt;/span&gt; show HEAD &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;\&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-3&quot;&gt;&lt;a href=&quot;#cb10-3&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# (2) Convert the diff to a list of locations&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-4&quot;&gt;&lt;a href=&quot;#cb10-4&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ex&quot;&gt;diff-locs&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;\&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-5&quot;&gt;&lt;a href=&quot;#cb10-5&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;co&quot;&gt;# (3) Use multi-sub to insert a comment before each line&lt;/span&gt;&lt;/span&gt;
&lt;span id=&quot;cb10-6&quot;&gt;&lt;a href=&quot;#cb10-6&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;  &lt;span class=&quot;ex&quot;&gt;multi-sub&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;#39;^\( *\)&amp;#39;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;$&amp;#39;&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;1# TODO: Unsilence this error&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;\n\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;1&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recapping the pipeline above:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Use &lt;code&gt;git show&lt;/code&gt; to generate a diff, then&lt;/li&gt;
&lt;li&gt;convert the diff to a list of locations with &lt;code&gt;diff-locs&lt;/code&gt;, and finally&lt;/li&gt;
&lt;li&gt;insert a comment before each location with &lt;code&gt;multi-sub&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;diff-locs&lt;/code&gt; is particularly handy because after the first codemod, there won’t be type errors anymore! So to get a list of locations to perform the edit on, we’d have had to check out the commit before fixing the errors, save the list of errors to a file, go back, and finally do the edit we wanted to in the first place.&lt;/p&gt;
&lt;p&gt;Instead, we can take advantage of the fact that all that information is already stored in git history, skipping a bunch of steps. (And asking git to show a diff is way faster than asking Sorbet to re-typecheck a whole project 😅)&lt;/p&gt;
&lt;h1 id=&quot;aside-the-implementations&quot;&gt;Aside: The implementations&lt;/h1&gt;
&lt;p&gt;One thing I’d like to point out is that I took some care to make sure these commands weren’t eggregiously slow. I prototyped these commands with some hacky scripts, but after doing some rather large codemods I got annoyed with them taking minutes to finish.&lt;/p&gt;
&lt;p&gt;Some things that make these new commands fast:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;multi-grep&lt;/code&gt; and &lt;code&gt;multi-sed&lt;/code&gt; re-use an already opened file to avoid reading extra information.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;multi-grep&lt;/code&gt; is written in Standard ML, &lt;code&gt;multi-sub&lt;/code&gt; is written in OCaml, and &lt;code&gt;diff-locs&lt;/code&gt; is written in Haskell—all languages which have great optimizing compilers. This means much better performance than a scripting language.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you’re curious, you can read through their implementations on GitHub:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jez/multi-grep&quot;&gt;&lt;code&gt;multi-grep&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jez/multi-sub&quot;&gt;&lt;code&gt;multi-sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jez/diff-locs&quot;&gt;&lt;code&gt;diff-locs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As always if you have questions or notice issues please don’t hesitate to reach out!&lt;/p&gt;
&lt;!-- vim:tw=72
--&gt;
&lt;/main&gt;</content><author><name>Jake Zimmerman</name></author><category term="bash" /><category term="unix" /><summary type="html">← Return home I’m frequently faced wth problems like “find and replace this pattern, but only on specific lines,” especially lines that have type errors on them. I’ve built three new CLI tools that fit the need to operate on a specific set of lines in a codebase. In this post I’ll walk through a couple examples to show them in action.</summary></entry></feed>