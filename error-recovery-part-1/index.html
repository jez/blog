<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-02-21 03:56:34 -0500">
<meta name="description" content="I've spent a lot of time recently making Sorbet's parser recover from syntax errors when parsing. I didn't have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I'd share the experience so that you can learn too.
">
<title>Parse Error Recovery in Sorbet: Part 1 – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Parse Error Recovery in Sorbet: Part 1</h1>
    <blockquote class="metadata">
    <p class="subtitle">Why Recover from Syntax Errors</p>
    <p class="date before-toc"><time datetime="2022-02-21 03:56:34 -0500">February 21, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">← Return home</a><br>
</nav>

<main>
<p>I’ve spent a lot of time recently making <a
href="https://sorbet.org">Sorbet</a>’s parser recover from syntax errors
when parsing. I didn’t have any experience with this before getting
started, no one told me what the good tools or techniques for improving
a parser were, and none of the things I read quite described the ideas I
ended up implementing. I figured I’d share the experience so that you
can learn too.</p>
<!-- more -->
<p>The original post kept growing and growing as I wrote it, so I broke
it up into a handful of parts:</p>
<ul>
<li><a href="/error-recovery-part-1/"><strong>Part 1: Why Recover from
Syntax Errors</strong></a></li>
<li><a href="/error-recovery-part-2/">Part 2: What I Didn’t Do</a></li>
<li><a href="/error-recovery-part-3/">Part 3: Tools and Techniques for
Debugging a (Bison) Parser</a></li>
<li><a href="/error-recovery-part-4/">Part 4: Bison’s <code>error</code>
Token</a></li>
<li>(<em>coming soon</em>) Part 5: Backtracking, aka Lexer Hacks</li>
<li>(<em>coming soon</em>) Part 6: Falling Back on Indentation, aka More
Lexer Hacks</li>
</ul>
<!-- more -->
<p>This part is going to set the stage a bit and briefly mention why
Sorbet cares so much about syntax errors. The short answer? Editor
support is everything.</p>
<p>There are people out there who clamor for a type checker in any
codebase they work for. They’re zealous, early-adopters who evangelize
types to everyone around them. They love even just being able to run the
type checker in the command line or in CI hand have it reject code where
the types don’t check. Sorbet has snuck its way into many codebases this
way! But this approach always introduces friction: there’s always a
group of people who see the type checker as an antagonist, sitting there
and rejecting code that passes the test suite and gets the job done.</p>
<p>Having a powerful editor integration drives organic adoption. A
command line interface to a type checker is only really good at
reporting errors, but an editor interface exposes so much more: inline
hover lets programmers explore a code’s types and documentation by
pointing. Language-aware jump-to-definition and find-all-references mean
spending less time fumbling around a code base and more time looking at
the code that’s relevant in the moment. And of course autocompletion is
huge. Maybe you’re a curmudgeon like me who doesn’t use completion
except the occasional keyword completion in Vim, but I’ve learned that
many, many people feel like moving back to the dark ages when they have
to work in a codebase that doesn’t have fast, accurate autocompletion.
Every additional editor feature is another spoonful of sugar—once there
are enough, it overwhelms any feeling that the type checker tastes like
medicine.</p>
<p>But if a syntax error means that the parser returns an empty parse
result, all those spoonfuls fall to the floor with a loud clang. Hover
and go-to-def are serve stale (read: imperfect) results at best, if
anything. Autocomplete yields no results no matter how long you wait for
the menu to appear.</p>
<p>And in Sorbet’s situation, it’s even more severe because of how it
has chosen to implement the persistent editor mode. I’m sure I’ll
discuss this in more depth at some point (because despite the criticism
I’m going to leverage against it, I still think it works
<strong>really</strong> well), but here’s a quick overview of Sorbet’s
language server architecture:</p>
<ul>
<li><p>Nearly every part of Sorbet’s offline pipeline is embarrassingly
parallel.</p>
<p>All of the syntactic transformations on the tree happen without
access to any sort of codebase-wide information. Type inference is only
local—inferring types in one method body never affects the type check
result of another method, let alone another file. Program-wide state is
made immutable and shared across threads using shared memory (no
copying).</p></li>
<li><p>Sorbet does not track dependencies.</p>
<p>That means it doesn’t track which files <code>require</code> what
other files. It doesn’t have a way to incrementally update its class
hierarchy (symbol table) when something changes. It only caches parse
results and which what errors came from which files. There are no module
or package boundaries—Sorbet views a codebase as one codebase.<span
class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span
class="sidenote">This is starting to change, but only because the
approach mentioned here doesn’t scale to 10 million-line Ruby codebases.
It’s probably possible to count all such codebases on your
fingers.<br />
<br />
</span></span></p></li>
<li><p>Given all of this, there are two paths in server mode: the fast
path and the slow path.</p>
<p>When an edit comes in, Sorbet quickly decides whether the edit
changes any global information. If it can, Sorbet throws everything away
(except for cached parse results) and type checks the entire codebase
from scratch. Otherwise, it leaves the symbol table unchanged and just
retypechecks the edited file.</p></li>
</ul>
<p>On one hand, this is a very elegant architecture. Sorbet can be
almost entirely understood by how it behaves in batch mode. Put another
way, if a user reports a bug in the editor mode, it almost always
reproduces outside of the editor mode. It’s rare in Sorbet to find a bug
that only reproduces when the user makes one edit followed by another
edit.</p>
<p>But on the other hand, if the parser can’t recover from a syntax
error, not only can Sorbet not provide those fancy editor features, it
also makes it look like all the definitions in a file were deleted,
which makes it look like the contents of the symbol table will have
changed, which kicks off a retypecheck of the whole codebase. Most
syntax errors are introduced in completely benign places (like
<code>x.</code> or <code>if x</code>), not as part of changing what’s
defined in a file (like <code>def foo</code> or <code>X =</code>)
because people spend more time editing method bodies than anything else.
So most syntax errors can take the fast path as long as the parser can
manage to return a decent result.</p>
<p><strong>All of this is to say</strong>: it’s important for Sorbet to
recover from syntax errors for two reasons: it can’t provide editor
features like completion consistently without it, and in large codebases
it makes Sorbet deliver in-editor type checking errors far faster. In
future posts we’ll ramp up to more technical and esoteric parsing
topics. In particular, the next post gives some historical context about
Sorbet’s parser and some ideas I rejected for how to get better parse
results for syntax errors.</p>
<p style="text-align: right;">
<a href="/error-recovery-part-2/">Part 2: What I Didn’t Do →</a>
</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#parsing">parsing</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script>
  ;(function() {
    // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
    var selector = '.task-list > li > input[type="checkbox"]';
    var checkboxes = document.querySelectorAll(selector);
    Array.from(checkboxes).forEach((checkbox) => {
      var wasChecked = checkbox.checked;
      checkbox.disabled = false;
      checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
    });
  })();
  </script>

  



</body>
</html>

