<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en" dir="ltr">
<head>
    <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<meta name="author" content="Jake Zimmerman">
<meta name="dcterms.date" content="2022-02-21 03:56:34 -0500">
<meta name="description" content="I've spent a lot of time recently making Sorbet's parser recover from syntax errors when parsing. I didn't have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I'd share the experience so that you can learn too.
">
<title>Parse Error Recovery in Sorbet: Part 1 – Jake Zimmerman</title>

  <link rel="stylesheet" href="/assets/css/theme.css">
<link rel="stylesheet" href="/assets/css/skylighting-solarized-theme.css">




  
    <link rel="apple-touch-icon-precomposed" href="/assets/img/touch-icon.png">
  
    <link rel="icon" sizes="32x32" href="/assets/img/favicon@2x.png">
  
    <link rel="icon" sizes="16x16" href="/assets/img/favicon.png">
  
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
  
    <link rel="stylesheet" href="/assets/css/extra.css">
  




</head>
<body>
  




  <header>
    <h1 class="title">Parse Error Recovery in Sorbet: Part 1</h1>
    <blockquote class="metadata">
    <p class="subtitle">Why Recover from Syntax Errors</p>
    <p class="date before-toc"><time datetime="2022-02-21 03:56:34 -0500">February 21, 2022</time></p>
    </blockquote>
  </header>


  <nav id="TOC" role="doc-toc">
  <a href="/">← Return home</a><br>
</nav>

<main>
<p>I’ve spent a lot of time recently making <a href="https://sorbet.org">Sorbet</a>’s parser recover from syntax errors when parsing. I didn’t have any experience with this before getting started, no one told me what the good tools or techniques for improving a parser were, and none of the things I read quite described the ideas I ended up implementing. I figured I’d share the experience so that you can learn too.</p>
<!-- more -->
<p>The original post kept growing and growing as I wrote it, so I broke it up into a handful of parts:</p>
<ul>
<li><a href="/error-recovery-part-1/"><strong>Part 1: Why Recover from Syntax Errors</strong></a></li>
<li><a href="/error-recovery-part-2/">Part 2: What I Didn’t Do</a></li>
<li><a href="/error-recovery-part-3/">Part 3: Tools and Techniques for Debugging a (Bison) Parser</a></li>
<li><a href="/error-recovery-part-4/">Part 4: Bison’s <code>error</code> Token</a></li>
<li>(<em>coming soon</em>) Part 5: Backtracking, aka Lexer Hacks</li>
<li>(<em>coming soon</em>) Part 6: Falling Back on Indentation, aka More Lexer Hacks</li>
</ul>
<!-- more -->
<p>This part is going to set the stage a bit and briefly mention why Sorbet cares so much about syntax errors. The short answer? Editor support is everything.</p>
<p>There are people out there who clamor for a type checker in any codebase they work for. They’re zealous, early-adopters who evangelize types to everyone around them. They love even just being able to run the type checker in the command line or in CI hand have it reject code where the types don’t check. Sorbet has snuck its way into many codebases this way! But this approach always introduces friction: there’s always a group of people who see the type checker as an antagonist, sitting there and rejecting code that passes the test suite and gets the job done.</p>
<p>Having a powerful editor integration drives organic adoption. A command line interface to a type checker is only really good at reporting errors, but an editor interface exposes so much more: inline hover lets programmers explore a code’s types and documentation by pointing. Language-aware jump-to-definition and find-all-references mean spending less time fumbling around a code base and more time looking at the code that’s relevant in the moment. And of course autocompletion is huge. Maybe you’re a curmudgeon like me who doesn’t use completion except the occasional keyword completion in Vim, but I’ve learned that many, many people feel like moving back to the dark ages when they have to work in a codebase that doesn’t have fast, accurate autocompletion. Every additional editor feature is another spoonful of sugar—once there are enough, it overwhelms any feeling that the type checker tastes like medicine.</p>
<p>But if a syntax error means that the parser returns an empty parse result, all those spoonfuls fall to the floor with a loud clang. Hover and go-to-def are serve stale (read: imperfect) results at best, if anything. Autocomplete yields no results no matter how long you wait for the menu to appear.</p>
<p>And in Sorbet’s situation, it’s even more severe because of how it has chosen to implement the persistent editor mode. I’m sure I’ll discuss this in more depth at some point (because despite the criticism I’m going to leverage against it, I still think it works <strong>really</strong> well), but here’s a quick overview of Sorbet’s language server architecture:</p>
<ul>
<li><p>Nearly every part of Sorbet’s offline pipeline is embarrassingly parallel.</p>
<p>All of the syntactic transformations on the tree happen without access to any sort of codebase-wide information. Type inference is only local—inferring types in one method body never affects the type check result of another method, let alone another file. Program-wide state is made immutable and shared across threads using shared memory (no copying).</p></li>
<li><p>Sorbet does not track dependencies.</p>
<p>That means it doesn’t track which files <code>require</code> what other files. It doesn’t have a way to incrementally update its class hierarchy (symbol table) when something changes. It only caches parse results and which what errors came from which files. There are no module or package boundaries—Sorbet views a codebase as one codebase.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">This is starting to change, but only because the approach mentioned here doesn’t scale to 10 million-line Ruby codebases. It’s probably possible to count all such codebases on your fingers.<br />
<br />
</span></span></p></li>
<li><p>Given all of this, there are two paths in server mode: the fast path and the slow path.</p>
<p>When an edit comes in, Sorbet quickly decides whether the edit changes any global information. If it can, Sorbet throws everything away (except for cached parse results) and type checks the entire codebase from scratch. Otherwise, it leaves the symbol table unchanged and just retypechecks the edited file.</p></li>
</ul>
<p>On one hand, this is a very elegant architecture. Sorbet can be almost entirely understood by how it behaves in batch mode. Put another way, if a user reports a bug in the editor mode, it almost always reproduces outside of the editor mode. It’s rare in Sorbet to find a bug that only reproduces when the user makes one edit followed by another edit.</p>
<p>But on the other hand, if the parser can’t recover from a syntax error, not only can Sorbet not provide those fancy editor features, it also makes it look like all the definitions in a file were deleted, which makes it look like the contents of the symbol table will have changed, which kicks off a retypecheck of the whole codebase. Most syntax errors are introduced in completely benign places (like <code>x.</code> or <code>if x</code>), not as part of changing what’s defined in a file (like <code>def foo</code> or <code>X =</code>) because people spend more time editing method bodies than anything else. So most syntax errors can take the fast path as long as the parser can manage to return a decent result.</p>
<p><strong>All of this is to say</strong>: it’s important for Sorbet to recover from syntax errors for two reasons: it can’t provide editor features like completion consistently without it, and in large codebases it makes Sorbet deliver in-editor type checking errors far faster. In future posts we’ll ramp up to more technical and esoteric parsing topics. In particular, the next post gives some historical context about Sorbet’s parser and some ideas I rejected for how to get better parse results for syntax errors.</p>
<p style="text-align: right;">
<a href="/error-recovery-part-2/">Part 2: What I Didn’t Do →</a>
</p>
</main>


    <footer class="signoff">
      <p>
        More like this:
        
          <span class="smallcaps"><strong><a href="/categories/#sorbet">sorbet</a></strong></span>, 
        
          <span class="smallcaps"><strong><a href="/categories/#parsing">parsing</a></strong></span>
        
      </p>
      <p><a href="/">← Return home</a></p>
    </footer>
  
    <script src="/assets/js/enable_checkboxes.js"></script>

  



</body>
</html>

