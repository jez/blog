<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://blog.jez.io/feed/flow.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2025-04-26T15:27:53-04:00</updated><id>https://blog.jez.io/feed/flow.xml</id><title type="html">Jake Zimmerman | Flow</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Prefer .then() over .catch()</title><link href="https://blog.jez.io/prefer-then-over-catch/" rel="alternate" type="text/html" title="Prefer .then() over .catch()" /><published>2018-05-31T18:58:52-04:00</published><updated>2018-05-31T18:58:52-04:00</updated><id>https://blog.jez.io/prefer-then-over-catch</id><author><name>Jake Zimmerman</name></author><category term="flow" /><category term="fragment" /><category term="javascript" /><summary type="html"><![CDATA[When designing asynchronous APIs that could error in Flow, prefer using `.then` for both successful and failure cases. Flow exposes a relatively unsafe library definition for the `.catch` method, so it's best to avoid it if you can.]]></summary></entry><entry><title type="html">Union Types in Flow &amp;amp; Reason</title><link href="https://blog.jez.io/union-types-flow-reason/" rel="alternate" type="text/html" title="Union Types in Flow &amp;amp; Reason" /><published>2018-04-19T01:43:26-04:00</published><updated>2018-04-19T01:43:26-04:00</updated><id>https://blog.jez.io/union-types-flow-reason</id><author><name>Jake Zimmerman</name></author><category term="flow" /><category term="types" /><category term="javascript" /><category term="reasonml" /><summary type="html"><![CDATA[Union types are powerful yet often overlooked. At work, I've been using Flow which thankfully supports union types. But as I've refactored more of our code to use union types, I've noticed that our bundle size has been steadily increasing!]]></summary></entry><entry><title type="html">Case Exhaustiveness in Flow</title><link href="https://blog.jez.io/flow-exhaustiveness/" rel="alternate" type="text/html" title="Case Exhaustiveness in Flow" /><published>2018-04-15T23:02:26-04:00</published><updated>2018-04-15T23:02:26-04:00</updated><id>https://blog.jez.io/flow-exhaustiveness</id><author><name>Jake Zimmerman</name></author><category term="javascript" /><category term="types" /><category term="flow" /><category term="programming" /><summary type="html"><![CDATA[Compared to some other languages, Flow's story around exhaustiveness checking within 'if / else' and 'switch' statements leaves something to be desired. By default, Flow doesn't do any exhaustiveness checks! But we can opt-in to exhaustiveness checking one statement at a time. In this post, we'll discover from the ground up how Flow's exhaustiveness checking behaves.]]></summary></entry></feed>