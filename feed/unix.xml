<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://blog.jez.io/feed/unix.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2025-04-26T15:25:09-04:00</updated><id>https://blog.jez.io/feed/unix.xml</id><title type="html">Jake Zimmerman | Unix</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Surgery on Code from the Command Line</title><link href="https://blog.jez.io/surgery-on-code/" rel="alternate" type="text/html" title="Surgery on Code from the Command Line" /><published>2019-07-30T12:32:48-04:00</published><updated>2019-07-30T12:32:48-04:00</updated><id>https://blog.jez.io/surgery-on-code</id><author><name>Jake Zimmerman</name></author><category term="codemods" /><category term="bash" /><category term="unix" /><summary type="html"><![CDATA[One problem that comes up all the time for me is needing to manipulate files only on specific lines. Like, “find and replace this pattern, but only on specific lines.” In this post, I’ll introduce the CLI tools I’ve made to solve this class of problems with some examples.]]></summary></entry><entry><title type="html">Improving CLIs with isatty</title><link href="https://blog.jez.io/cli-tty/" rel="alternate" type="text/html" title="Improving CLIs with isatty" /><published>2019-06-11T15:17:59-04:00</published><updated>2019-06-11T15:17:59-04:00</updated><id>https://blog.jez.io/cli-tty</id><author><name>Jake Zimmerman</name></author><category term="unix" /><category term="bash" /><category term="terminal" /><summary type="html"><![CDATA[One thing I like to do to improve the command-line programs I maintain is to make them aware of whether they're being run interactively. In this post I'll show off an easy trick to make programs running interactively more usable.]]></summary></entry><entry><title type="html">Google Chrome: A Memory Hog</title><link href="https://blog.jez.io/2014/12/29/google-chrome-a-memory-hog/" rel="alternate" type="text/html" title="Google Chrome: A Memory Hog" /><published>2014-12-29T18:00:00-05:00</published><updated>2014-12-29T18:00:00-05:00</updated><id>https://blog.jez.io/2014/12/29/google-chrome-a-memory-hog</id><author><name>Jake Zimmerman</name></author><category term="unix" /><category term="bash" /><summary type="html"><![CDATA[A bash oneliner to determine how much memory Chrome is using.]]></summary></entry><entry><title type="html">Offline LaTeX Development</title><link href="https://blog.jez.io/2014/10/06/offline-latex-development/" rel="alternate" type="text/html" title="Offline LaTeX Development" /><published>2014-10-06T18:00:00-04:00</published><updated>2014-10-06T18:00:00-04:00</updated><id>https://blog.jez.io/2014/10/06/offline-latex-development</id><author><name>Jake Zimmerman</name></author><category term="latex" /><category term="make" /><category term="vim" /><category term="unix" /><summary type="html"><![CDATA[While online clients like ShareLaTeX or writeLaTeX are popular for getting started with LaTeX quickly, developing LaTeX locally with Vim and the command line is my preferred LaTeX workflow. In this post, I'll describe the changes I've made that make working with LaTeX on the command line a seamless experience.]]></summary></entry></feed>