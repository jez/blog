<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://blog.jez.io/feed/bash.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jez.io/" rel="alternate" type="text/html" /><updated>2023-01-24T16:19:17-05:00</updated><id>https://blog.jez.io/feed/bash.xml</id><title type="html">Jake Zimmerman | Bash</title><subtitle>A collection of blog posts about programming, software, types, programming languages, Sorbet, Vim, Markdown, and more.</subtitle><author><name>Jake Zimmerman</name></author><entry><title type="html">Surgery on Code from the Command Line</title><link href="https://blog.jez.io/surgery-on-code/" rel="alternate" type="text/html" title="Surgery on Code from the Command Line" /><published>2019-07-30T12:32:48-04:00</published><updated>2019-07-30T12:32:48-04:00</updated><id>https://blog.jez.io/surgery-on-code</id><author><name>Jake Zimmerman</name></author><category term="codemods" /><category term="bash" /><category term="unix" /><summary type="html"><![CDATA[One problem that comes up all the time for me is needing to manipulate files only on specific lines. Like, “find and replace this pattern, but only on specific lines.” In this post, I’ll introduce the CLI tools I’ve made to solve this class of problems with some examples.]]></summary></entry><entry><title type="html">A Debugger for Bash in Six Lines of Bash</title><link href="https://blog.jez.io/bash-debugger/" rel="alternate" type="text/html" title="A Debugger for Bash in Six Lines of Bash" /><published>2019-06-16T12:25:06-04:00</published><updated>2019-06-16T12:25:06-04:00</updated><id>https://blog.jez.io/bash-debugger</id><author><name>Jake Zimmerman</name></author><category term="bash" /><summary type="html"><![CDATA[I implemented a debugger for Bash in six lines of Bash.]]></summary></entry><entry><title type="html">Improving CLIs with isatty</title><link href="https://blog.jez.io/cli-tty/" rel="alternate" type="text/html" title="Improving CLIs with isatty" /><published>2019-06-11T15:17:59-04:00</published><updated>2019-06-11T15:17:59-04:00</updated><id>https://blog.jez.io/cli-tty</id><author><name>Jake Zimmerman</name></author><category term="unix" /><category term="bash" /><category term="terminal" /><summary type="html"><![CDATA[One thing I like to do to improve the command-line programs I maintain is to make them aware of whether they're being run interactively. In this post I'll show off an easy trick to make programs running interactively more usable.]]></summary></entry><entry><title type="html">Standard ML in Travis CI</title><link href="https://blog.jez.io/sml-travis-ci/" rel="alternate" type="text/html" title="Standard ML in Travis CI" /><published>2019-06-04T12:26:45-04:00</published><updated>2019-06-04T12:26:45-04:00</updated><id>https://blog.jez.io/sml-travis-ci</id><author><name>Jake Zimmerman</name></author><category term="sml" /><category term="bash" /><summary type="html"><![CDATA[For one of my recent projects I went through the work to get Standard ML building in Travis CI.]]></summary></entry><entry><title type="html">Code Review from the Command Line</title><link href="https://blog.jez.io/cli-code-review/" rel="alternate" type="text/html" title="Code Review from the Command Line" /><published>2018-01-13T16:14:24-05:00</published><updated>2018-01-13T16:14:24-05:00</updated><id>https://blog.jez.io/cli-code-review</id><author><name>Jake Zimmerman</name></author><category term="bash" /><category term="git" /><category term="programming" /><category term="vim" /><category term="javascript" /><summary type="html"><![CDATA[I do the bulk of my code reviews from the command line, especially when reviewing larger changes. I've built up a number of tools and config settings that help me dig into the nuances of the code I'm reviewing, so that I can understand it better than if I were just browsing online.]]></summary></entry><entry><title type="html">Show where a Python package is used</title><link href="https://blog.jez.io/2015/06/12/show-where-a-python-package-is-used/" rel="alternate" type="text/html" title="Show where a Python package is used" /><published>2015-06-12T02:36:05-04:00</published><updated>2015-06-12T02:36:05-04:00</updated><id>https://blog.jez.io/2015/06/12/show-where-a-python-package-is-used</id><author><name>Jake Zimmerman</name></author><category term="bash" /><category term="python" /><summary type="html"><![CDATA['I wrote a simple bash script that lists which Python packages use a given package.']]></summary></entry><entry><title type="html">Google Chrome: A Memory Hog</title><link href="https://blog.jez.io/2014/12/29/google-chrome-a-memory-hog/" rel="alternate" type="text/html" title="Google Chrome: A Memory Hog" /><published>2014-12-29T18:00:00-05:00</published><updated>2014-12-29T18:00:00-05:00</updated><id>https://blog.jez.io/2014/12/29/google-chrome-a-memory-hog</id><author><name>Jake Zimmerman</name></author><category term="unix" /><category term="bash" /><summary type="html"><![CDATA[A bash oneliner to determine how much memory Chrome is using.]]></summary></entry><entry><title type="html">Vim as a Man Page Viewer</title><link href="https://blog.jez.io/2014/12/20/vim-as-a-man-page-viewer/" rel="alternate" type="text/html" title="Vim as a Man Page Viewer" /><published>2014-12-20T21:17:46-05:00</published><updated>2014-12-20T21:17:46-05:00</updated><id>https://blog.jez.io/2014/12/20/vim-as-a-man-page-viewer</id><author><name>Jake Zimmerman</name></author><category term="vim" /><category term="bash" /><summary type="html"><![CDATA[Use vim as a man page viewer to get better syntax highlighting, scroll quickly with a mouse, tabs, and more.]]></summary></entry></feed>